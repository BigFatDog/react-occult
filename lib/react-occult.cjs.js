'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var React$1 = require('react');
var React$1__default = _interopDefault(React$1);

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function unwrapExports (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var reactIs_production_min = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports,"__esModule",{value:!0});
var b="function"===typeof Symbol&&Symbol.for,c=b?Symbol.for("react.element"):60103,d=b?Symbol.for("react.portal"):60106,e=b?Symbol.for("react.fragment"):60107,f=b?Symbol.for("react.strict_mode"):60108,g=b?Symbol.for("react.profiler"):60114,h=b?Symbol.for("react.provider"):60109,k=b?Symbol.for("react.context"):60110,l=b?Symbol.for("react.async_mode"):60111,m=b?Symbol.for("react.concurrent_mode"):60111,n=b?Symbol.for("react.forward_ref"):60112,p=b?Symbol.for("react.suspense"):60113,q=b?Symbol.for("react.suspense_list"):
60120,r=b?Symbol.for("react.memo"):60115,t=b?Symbol.for("react.lazy"):60116,v=b?Symbol.for("react.fundamental"):60117,w=b?Symbol.for("react.responder"):60118,x=b?Symbol.for("react.scope"):60119;function y(a){if("object"===typeof a&&null!==a){var u=a.$$typeof;switch(u){case c:switch(a=a.type,a){case l:case m:case e:case g:case f:case p:return a;default:switch(a=a&&a.$$typeof,a){case k:case n:case h:return a;default:return u}}case t:case r:case d:return u}}}function z(a){return y(a)===m}
exports.typeOf=y;exports.AsyncMode=l;exports.ConcurrentMode=m;exports.ContextConsumer=k;exports.ContextProvider=h;exports.Element=c;exports.ForwardRef=n;exports.Fragment=e;exports.Lazy=t;exports.Memo=r;exports.Portal=d;exports.Profiler=g;exports.StrictMode=f;exports.Suspense=p;
exports.isValidElementType=function(a){return "string"===typeof a||"function"===typeof a||a===e||a===m||a===g||a===f||a===p||a===q||"object"===typeof a&&null!==a&&(a.$$typeof===t||a.$$typeof===r||a.$$typeof===h||a.$$typeof===k||a.$$typeof===n||a.$$typeof===v||a.$$typeof===w||a.$$typeof===x)};exports.isAsyncMode=function(a){return z(a)||y(a)===l};exports.isConcurrentMode=z;exports.isContextConsumer=function(a){return y(a)===k};exports.isContextProvider=function(a){return y(a)===h};
exports.isElement=function(a){return "object"===typeof a&&null!==a&&a.$$typeof===c};exports.isForwardRef=function(a){return y(a)===n};exports.isFragment=function(a){return y(a)===e};exports.isLazy=function(a){return y(a)===t};exports.isMemo=function(a){return y(a)===r};exports.isPortal=function(a){return y(a)===d};exports.isProfiler=function(a){return y(a)===g};exports.isStrictMode=function(a){return y(a)===f};exports.isSuspense=function(a){return y(a)===p};
});

unwrapExports(reactIs_production_min);
var reactIs_production_min_1 = reactIs_production_min.typeOf;
var reactIs_production_min_2 = reactIs_production_min.AsyncMode;
var reactIs_production_min_3 = reactIs_production_min.ConcurrentMode;
var reactIs_production_min_4 = reactIs_production_min.ContextConsumer;
var reactIs_production_min_5 = reactIs_production_min.ContextProvider;
var reactIs_production_min_6 = reactIs_production_min.Element;
var reactIs_production_min_7 = reactIs_production_min.ForwardRef;
var reactIs_production_min_8 = reactIs_production_min.Fragment;
var reactIs_production_min_9 = reactIs_production_min.Lazy;
var reactIs_production_min_10 = reactIs_production_min.Memo;
var reactIs_production_min_11 = reactIs_production_min.Portal;
var reactIs_production_min_12 = reactIs_production_min.Profiler;
var reactIs_production_min_13 = reactIs_production_min.StrictMode;
var reactIs_production_min_14 = reactIs_production_min.Suspense;
var reactIs_production_min_15 = reactIs_production_min.isValidElementType;
var reactIs_production_min_16 = reactIs_production_min.isAsyncMode;
var reactIs_production_min_17 = reactIs_production_min.isConcurrentMode;
var reactIs_production_min_18 = reactIs_production_min.isContextConsumer;
var reactIs_production_min_19 = reactIs_production_min.isContextProvider;
var reactIs_production_min_20 = reactIs_production_min.isElement;
var reactIs_production_min_21 = reactIs_production_min.isForwardRef;
var reactIs_production_min_22 = reactIs_production_min.isFragment;
var reactIs_production_min_23 = reactIs_production_min.isLazy;
var reactIs_production_min_24 = reactIs_production_min.isMemo;
var reactIs_production_min_25 = reactIs_production_min.isPortal;
var reactIs_production_min_26 = reactIs_production_min.isProfiler;
var reactIs_production_min_27 = reactIs_production_min.isStrictMode;
var reactIs_production_min_28 = reactIs_production_min.isSuspense;

var reactIs_development = createCommonjsModule(function (module, exports) {



if (process.env.NODE_ENV !== "production") {
  (function() {

Object.defineProperty(exports, '__esModule', { value: true });

// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var hasSymbol = typeof Symbol === 'function' && Symbol.for;
var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;
var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;
var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;
var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;
var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;
var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;
var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace; // TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary
// (unstable) APIs that have been removed. Can we remove the symbols?

var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;
var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;
var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;
var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;
var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for('react.suspense_list') : 0xead8;
var REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;
var REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;
var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for('react.fundamental') : 0xead5;
var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for('react.responder') : 0xead6;
var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for('react.scope') : 0xead7;

function isValidElementType(type) {
  return typeof type === 'string' || typeof type === 'function' || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
  type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE);
}

/**
 * Forked from fbjs/warning:
 * https://github.com/facebook/fbjs/blob/e66ba20ad5be433eb54423f2b097d829324d9de6/packages/fbjs/src/__forks__/warning.js
 *
 * Only change is we use console.warn instead of console.error,
 * and do nothing when 'console' is not supported.
 * This really simplifies the code.
 * ---
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */
var lowPriorityWarningWithoutStack = function () {};

{
  var printWarning = function (format) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    var argIndex = 0;
    var message = 'Warning: ' + format.replace(/%s/g, function () {
      return args[argIndex++];
    });

    if (typeof console !== 'undefined') {
      console.warn(message);
    }

    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };

  lowPriorityWarningWithoutStack = function (condition, format) {
    if (format === undefined) {
      throw new Error('`lowPriorityWarningWithoutStack(condition, format, ...args)` requires a warning ' + 'message argument');
    }

    if (!condition) {
      for (var _len2 = arguments.length, args = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
        args[_key2 - 2] = arguments[_key2];
      }

      printWarning.apply(void 0, [format].concat(args));
    }
  };
}

var lowPriorityWarningWithoutStack$1 = lowPriorityWarningWithoutStack;

function typeOf(object) {
  if (typeof object === 'object' && object !== null) {
    var $$typeof = object.$$typeof;

    switch ($$typeof) {
      case REACT_ELEMENT_TYPE:
        var type = object.type;

        switch (type) {
          case REACT_ASYNC_MODE_TYPE:
          case REACT_CONCURRENT_MODE_TYPE:
          case REACT_FRAGMENT_TYPE:
          case REACT_PROFILER_TYPE:
          case REACT_STRICT_MODE_TYPE:
          case REACT_SUSPENSE_TYPE:
            return type;

          default:
            var $$typeofType = type && type.$$typeof;

            switch ($$typeofType) {
              case REACT_CONTEXT_TYPE:
              case REACT_FORWARD_REF_TYPE:
              case REACT_PROVIDER_TYPE:
                return $$typeofType;

              default:
                return $$typeof;
            }

        }

      case REACT_LAZY_TYPE:
      case REACT_MEMO_TYPE:
      case REACT_PORTAL_TYPE:
        return $$typeof;
    }
  }

  return undefined;
} // AsyncMode is deprecated along with isAsyncMode

var AsyncMode = REACT_ASYNC_MODE_TYPE;
var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
var ContextConsumer = REACT_CONTEXT_TYPE;
var ContextProvider = REACT_PROVIDER_TYPE;
var Element = REACT_ELEMENT_TYPE;
var ForwardRef = REACT_FORWARD_REF_TYPE;
var Fragment = REACT_FRAGMENT_TYPE;
var Lazy = REACT_LAZY_TYPE;
var Memo = REACT_MEMO_TYPE;
var Portal = REACT_PORTAL_TYPE;
var Profiler = REACT_PROFILER_TYPE;
var StrictMode = REACT_STRICT_MODE_TYPE;
var Suspense = REACT_SUSPENSE_TYPE;
var hasWarnedAboutDeprecatedIsAsyncMode = false; // AsyncMode should be deprecated

function isAsyncMode(object) {
  {
    if (!hasWarnedAboutDeprecatedIsAsyncMode) {
      hasWarnedAboutDeprecatedIsAsyncMode = true;
      lowPriorityWarningWithoutStack$1(false, 'The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 17+. Update your code to use ' + 'ReactIs.isConcurrentMode() instead. It has the exact same API.');
    }
  }

  return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
}
function isConcurrentMode(object) {
  return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
}
function isContextConsumer(object) {
  return typeOf(object) === REACT_CONTEXT_TYPE;
}
function isContextProvider(object) {
  return typeOf(object) === REACT_PROVIDER_TYPE;
}
function isElement(object) {
  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
}
function isForwardRef(object) {
  return typeOf(object) === REACT_FORWARD_REF_TYPE;
}
function isFragment(object) {
  return typeOf(object) === REACT_FRAGMENT_TYPE;
}
function isLazy(object) {
  return typeOf(object) === REACT_LAZY_TYPE;
}
function isMemo(object) {
  return typeOf(object) === REACT_MEMO_TYPE;
}
function isPortal(object) {
  return typeOf(object) === REACT_PORTAL_TYPE;
}
function isProfiler(object) {
  return typeOf(object) === REACT_PROFILER_TYPE;
}
function isStrictMode(object) {
  return typeOf(object) === REACT_STRICT_MODE_TYPE;
}
function isSuspense(object) {
  return typeOf(object) === REACT_SUSPENSE_TYPE;
}

exports.typeOf = typeOf;
exports.AsyncMode = AsyncMode;
exports.ConcurrentMode = ConcurrentMode;
exports.ContextConsumer = ContextConsumer;
exports.ContextProvider = ContextProvider;
exports.Element = Element;
exports.ForwardRef = ForwardRef;
exports.Fragment = Fragment;
exports.Lazy = Lazy;
exports.Memo = Memo;
exports.Portal = Portal;
exports.Profiler = Profiler;
exports.StrictMode = StrictMode;
exports.Suspense = Suspense;
exports.isValidElementType = isValidElementType;
exports.isAsyncMode = isAsyncMode;
exports.isConcurrentMode = isConcurrentMode;
exports.isContextConsumer = isContextConsumer;
exports.isContextProvider = isContextProvider;
exports.isElement = isElement;
exports.isForwardRef = isForwardRef;
exports.isFragment = isFragment;
exports.isLazy = isLazy;
exports.isMemo = isMemo;
exports.isPortal = isPortal;
exports.isProfiler = isProfiler;
exports.isStrictMode = isStrictMode;
exports.isSuspense = isSuspense;
  })();
}
});

unwrapExports(reactIs_development);
var reactIs_development_1 = reactIs_development.typeOf;
var reactIs_development_2 = reactIs_development.AsyncMode;
var reactIs_development_3 = reactIs_development.ConcurrentMode;
var reactIs_development_4 = reactIs_development.ContextConsumer;
var reactIs_development_5 = reactIs_development.ContextProvider;
var reactIs_development_6 = reactIs_development.Element;
var reactIs_development_7 = reactIs_development.ForwardRef;
var reactIs_development_8 = reactIs_development.Fragment;
var reactIs_development_9 = reactIs_development.Lazy;
var reactIs_development_10 = reactIs_development.Memo;
var reactIs_development_11 = reactIs_development.Portal;
var reactIs_development_12 = reactIs_development.Profiler;
var reactIs_development_13 = reactIs_development.StrictMode;
var reactIs_development_14 = reactIs_development.Suspense;
var reactIs_development_15 = reactIs_development.isValidElementType;
var reactIs_development_16 = reactIs_development.isAsyncMode;
var reactIs_development_17 = reactIs_development.isConcurrentMode;
var reactIs_development_18 = reactIs_development.isContextConsumer;
var reactIs_development_19 = reactIs_development.isContextProvider;
var reactIs_development_20 = reactIs_development.isElement;
var reactIs_development_21 = reactIs_development.isForwardRef;
var reactIs_development_22 = reactIs_development.isFragment;
var reactIs_development_23 = reactIs_development.isLazy;
var reactIs_development_24 = reactIs_development.isMemo;
var reactIs_development_25 = reactIs_development.isPortal;
var reactIs_development_26 = reactIs_development.isProfiler;
var reactIs_development_27 = reactIs_development.isStrictMode;
var reactIs_development_28 = reactIs_development.isSuspense;

var reactIs = createCommonjsModule(function (module) {

if (process.env.NODE_ENV === 'production') {
  module.exports = reactIs_production_min;
} else {
  module.exports = reactIs_development;
}
});

/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
/* eslint-disable no-unused-vars */
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

var objectAssign = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

var ReactPropTypesSecret_1 = ReactPropTypesSecret;

var printWarning = function() {};

if (process.env.NODE_ENV !== 'production') {
  var ReactPropTypesSecret$1 = ReactPropTypesSecret_1;
  var loggedTypeFailures = {};
  var has = Function.call.bind(Object.prototype.hasOwnProperty);

  printWarning = function(text) {
    var message = 'Warning: ' + text;
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };
}

/**
 * Assert that the values match with the type specs.
 * Error messages are memorized and will only be shown once.
 *
 * @param {object} typeSpecs Map of name to a ReactPropType
 * @param {object} values Runtime values that need to be type-checked
 * @param {string} location e.g. "prop", "context", "child context"
 * @param {string} componentName Name of the component for error messages.
 * @param {?Function} getStack Returns the component stack.
 * @private
 */
function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
  if (process.env.NODE_ENV !== 'production') {
    for (var typeSpecName in typeSpecs) {
      if (has(typeSpecs, typeSpecName)) {
        var error;
        // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.
        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          if (typeof typeSpecs[typeSpecName] !== 'function') {
            var err = Error(
              (componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' +
              'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.'
            );
            err.name = 'Invariant Violation';
            throw err;
          }
          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret$1);
        } catch (ex) {
          error = ex;
        }
        if (error && !(error instanceof Error)) {
          printWarning(
            (componentName || 'React class') + ': type specification of ' +
            location + ' `' + typeSpecName + '` is invalid; the type checker ' +
            'function must return `null` or an `Error` but returned a ' + typeof error + '. ' +
            'You may have forgotten to pass an argument to the type checker ' +
            'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' +
            'shape all require an argument).'
          );
        }
        if (error instanceof Error && !(error.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error.message] = true;

          var stack = getStack ? getStack() : '';

          printWarning(
            'Failed ' + location + ' type: ' + error.message + (stack != null ? stack : '')
          );
        }
      }
    }
  }
}

/**
 * Resets warning cache when testing.
 *
 * @private
 */
checkPropTypes.resetWarningCache = function() {
  if (process.env.NODE_ENV !== 'production') {
    loggedTypeFailures = {};
  }
};

var checkPropTypes_1 = checkPropTypes;

var has$1 = Function.call.bind(Object.prototype.hasOwnProperty);
var printWarning$1 = function() {};

if (process.env.NODE_ENV !== 'production') {
  printWarning$1 = function(text) {
    var message = 'Warning: ' + text;
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };
}

function emptyFunctionThatReturnsNull() {
  return null;
}

var factoryWithTypeCheckers = function(isValidElement, throwOnDirectAccess) {
  /* global Symbol */
  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

  /**
   * Returns the iterator method function contained on the iterable object.
   *
   * Be sure to invoke the function with the iterable as context:
   *
   *     var iteratorFn = getIteratorFn(myIterable);
   *     if (iteratorFn) {
   *       var iterator = iteratorFn.call(myIterable);
   *       ...
   *     }
   *
   * @param {?object} maybeIterable
   * @return {?function}
   */
  function getIteratorFn(maybeIterable) {
    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
    if (typeof iteratorFn === 'function') {
      return iteratorFn;
    }
  }

  /**
   * Collection of methods that allow declaration and validation of props that are
   * supplied to React components. Example usage:
   *
   *   var Props = require('ReactPropTypes');
   *   var MyArticle = React.createClass({
   *     propTypes: {
   *       // An optional string prop named "description".
   *       description: Props.string,
   *
   *       // A required enum prop named "category".
   *       category: Props.oneOf(['News','Photos']).isRequired,
   *
   *       // A prop named "dialog" that requires an instance of Dialog.
   *       dialog: Props.instanceOf(Dialog).isRequired
   *     },
   *     render: function() { ... }
   *   });
   *
   * A more formal specification of how these methods are used:
   *
   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
   *   decl := ReactPropTypes.{type}(.isRequired)?
   *
   * Each and every declaration produces a function with the same signature. This
   * allows the creation of custom validation functions. For example:
   *
   *  var MyLink = React.createClass({
   *    propTypes: {
   *      // An optional string or URI prop named "href".
   *      href: function(props, propName, componentName) {
   *        var propValue = props[propName];
   *        if (propValue != null && typeof propValue !== 'string' &&
   *            !(propValue instanceof URI)) {
   *          return new Error(
   *            'Expected a string or an URI for ' + propName + ' in ' +
   *            componentName
   *          );
   *        }
   *      }
   *    },
   *    render: function() {...}
   *  });
   *
   * @internal
   */

  var ANONYMOUS = '<<anonymous>>';

  // Important!
  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.
  var ReactPropTypes = {
    array: createPrimitiveTypeChecker('array'),
    bool: createPrimitiveTypeChecker('boolean'),
    func: createPrimitiveTypeChecker('function'),
    number: createPrimitiveTypeChecker('number'),
    object: createPrimitiveTypeChecker('object'),
    string: createPrimitiveTypeChecker('string'),
    symbol: createPrimitiveTypeChecker('symbol'),

    any: createAnyTypeChecker(),
    arrayOf: createArrayOfTypeChecker,
    element: createElementTypeChecker(),
    elementType: createElementTypeTypeChecker(),
    instanceOf: createInstanceTypeChecker,
    node: createNodeChecker(),
    objectOf: createObjectOfTypeChecker,
    oneOf: createEnumTypeChecker,
    oneOfType: createUnionTypeChecker,
    shape: createShapeTypeChecker,
    exact: createStrictShapeTypeChecker,
  };

  /**
   * inlined Object.is polyfill to avoid requiring consumers ship their own
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
   */
  /*eslint-disable no-self-compare*/
  function is(x, y) {
    // SameValue algorithm
    if (x === y) {
      // Steps 1-5, 7-10
      // Steps 6.b-6.e: +0 != -0
      return x !== 0 || 1 / x === 1 / y;
    } else {
      // Step 6.a: NaN == NaN
      return x !== x && y !== y;
    }
  }
  /*eslint-enable no-self-compare*/

  /**
   * We use an Error-like object for backward compatibility as people may call
   * PropTypes directly and inspect their output. However, we don't use real
   * Errors anymore. We don't inspect their stack anyway, and creating them
   * is prohibitively expensive if they are created too often, such as what
   * happens in oneOfType() for any type before the one that matched.
   */
  function PropTypeError(message) {
    this.message = message;
    this.stack = '';
  }
  // Make `instanceof Error` still work for returned errors.
  PropTypeError.prototype = Error.prototype;

  function createChainableTypeChecker(validate) {
    if (process.env.NODE_ENV !== 'production') {
      var manualPropTypeCallCache = {};
      var manualPropTypeWarningCount = 0;
    }
    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
      componentName = componentName || ANONYMOUS;
      propFullName = propFullName || propName;

      if (secret !== ReactPropTypesSecret_1) {
        if (throwOnDirectAccess) {
          // New behavior only for users of `prop-types` package
          var err = new Error(
            'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
            'Use `PropTypes.checkPropTypes()` to call them. ' +
            'Read more at http://fb.me/use-check-prop-types'
          );
          err.name = 'Invariant Violation';
          throw err;
        } else if (process.env.NODE_ENV !== 'production' && typeof console !== 'undefined') {
          // Old behavior for people using React.PropTypes
          var cacheKey = componentName + ':' + propName;
          if (
            !manualPropTypeCallCache[cacheKey] &&
            // Avoid spamming the console because they are often not actionable except for lib authors
            manualPropTypeWarningCount < 3
          ) {
            printWarning$1(
              'You are manually calling a React.PropTypes validation ' +
              'function for the `' + propFullName + '` prop on `' + componentName  + '`. This is deprecated ' +
              'and will throw in the standalone `prop-types` package. ' +
              'You may be seeing this warning due to a third-party PropTypes ' +
              'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.'
            );
            manualPropTypeCallCache[cacheKey] = true;
            manualPropTypeWarningCount++;
          }
        }
      }
      if (props[propName] == null) {
        if (isRequired) {
          if (props[propName] === null) {
            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
          }
          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
        }
        return null;
      } else {
        return validate(props, propName, componentName, location, propFullName);
      }
    }

    var chainedCheckType = checkType.bind(null, false);
    chainedCheckType.isRequired = checkType.bind(null, true);

    return chainedCheckType;
  }

  function createPrimitiveTypeChecker(expectedType) {
    function validate(props, propName, componentName, location, propFullName, secret) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== expectedType) {
        // `propValue` being instance of, say, date/regexp, pass the 'object'
        // check, but we can offer a more precise error message here rather than
        // 'of type `object`'.
        var preciseType = getPreciseType(propValue);

        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createAnyTypeChecker() {
    return createChainableTypeChecker(emptyFunctionThatReturnsNull);
  }

  function createArrayOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
      }
      var propValue = props[propName];
      if (!Array.isArray(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
      }
      for (var i = 0; i < propValue.length; i++) {
        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret_1);
        if (error instanceof Error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createElementTypeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      if (!isValidElement(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createElementTypeTypeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      if (!reactIs.isValidElementType(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement type.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createInstanceTypeChecker(expectedClass) {
    function validate(props, propName, componentName, location, propFullName) {
      if (!(props[propName] instanceof expectedClass)) {
        var expectedClassName = expectedClass.name || ANONYMOUS;
        var actualClassName = getClassName(props[propName]);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createEnumTypeChecker(expectedValues) {
    if (!Array.isArray(expectedValues)) {
      if (process.env.NODE_ENV !== 'production') {
        if (arguments.length > 1) {
          printWarning$1(
            'Invalid arguments supplied to oneOf, expected an array, got ' + arguments.length + ' arguments. ' +
            'A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z]).'
          );
        } else {
          printWarning$1('Invalid argument supplied to oneOf, expected an array.');
        }
      }
      return emptyFunctionThatReturnsNull;
    }

    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      for (var i = 0; i < expectedValues.length; i++) {
        if (is(propValue, expectedValues[i])) {
          return null;
        }
      }

      var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {
        var type = getPreciseType(value);
        if (type === 'symbol') {
          return String(value);
        }
        return value;
      });
      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + String(propValue) + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createObjectOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
      }
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
      }
      for (var key in propValue) {
        if (has$1(propValue, key)) {
          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret_1);
          if (error instanceof Error) {
            return error;
          }
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createUnionTypeChecker(arrayOfTypeCheckers) {
    if (!Array.isArray(arrayOfTypeCheckers)) {
      process.env.NODE_ENV !== 'production' ? printWarning$1('Invalid argument supplied to oneOfType, expected an instance of array.') : void 0;
      return emptyFunctionThatReturnsNull;
    }

    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
      var checker = arrayOfTypeCheckers[i];
      if (typeof checker !== 'function') {
        printWarning$1(
          'Invalid argument supplied to oneOfType. Expected an array of check functions, but ' +
          'received ' + getPostfixForTypeWarning(checker) + ' at index ' + i + '.'
        );
        return emptyFunctionThatReturnsNull;
      }
    }

    function validate(props, propName, componentName, location, propFullName) {
      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
        var checker = arrayOfTypeCheckers[i];
        if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret_1) == null) {
          return null;
        }
      }

      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createNodeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      if (!isNode(props[propName])) {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      for (var key in shapeTypes) {
        var checker = shapeTypes[key];
        if (!checker) {
          continue;
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret_1);
        if (error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createStrictShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      // We need to check all keys in case some are required but missing from
      // props.
      var allKeys = objectAssign({}, props[propName], shapeTypes);
      for (var key in allKeys) {
        var checker = shapeTypes[key];
        if (!checker) {
          return new PropTypeError(
            'Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' +
            '\nBad object: ' + JSON.stringify(props[propName], null, '  ') +
            '\nValid keys: ' +  JSON.stringify(Object.keys(shapeTypes), null, '  ')
          );
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret_1);
        if (error) {
          return error;
        }
      }
      return null;
    }

    return createChainableTypeChecker(validate);
  }

  function isNode(propValue) {
    switch (typeof propValue) {
      case 'number':
      case 'string':
      case 'undefined':
        return true;
      case 'boolean':
        return !propValue;
      case 'object':
        if (Array.isArray(propValue)) {
          return propValue.every(isNode);
        }
        if (propValue === null || isValidElement(propValue)) {
          return true;
        }

        var iteratorFn = getIteratorFn(propValue);
        if (iteratorFn) {
          var iterator = iteratorFn.call(propValue);
          var step;
          if (iteratorFn !== propValue.entries) {
            while (!(step = iterator.next()).done) {
              if (!isNode(step.value)) {
                return false;
              }
            }
          } else {
            // Iterator will provide entry [k,v] tuples rather than values.
            while (!(step = iterator.next()).done) {
              var entry = step.value;
              if (entry) {
                if (!isNode(entry[1])) {
                  return false;
                }
              }
            }
          }
        } else {
          return false;
        }

        return true;
      default:
        return false;
    }
  }

  function isSymbol(propType, propValue) {
    // Native Symbol.
    if (propType === 'symbol') {
      return true;
    }

    // falsy value can't be a Symbol
    if (!propValue) {
      return false;
    }

    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
    if (propValue['@@toStringTag'] === 'Symbol') {
      return true;
    }

    // Fallback for non-spec compliant Symbols which are polyfilled.
    if (typeof Symbol === 'function' && propValue instanceof Symbol) {
      return true;
    }

    return false;
  }

  // Equivalent of `typeof` but with special handling for array and regexp.
  function getPropType(propValue) {
    var propType = typeof propValue;
    if (Array.isArray(propValue)) {
      return 'array';
    }
    if (propValue instanceof RegExp) {
      // Old webkits (at least until Android 4.0) return 'function' rather than
      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
      // passes PropTypes.object.
      return 'object';
    }
    if (isSymbol(propType, propValue)) {
      return 'symbol';
    }
    return propType;
  }

  // This handles more types than `getPropType`. Only used for error messages.
  // See `createPrimitiveTypeChecker`.
  function getPreciseType(propValue) {
    if (typeof propValue === 'undefined' || propValue === null) {
      return '' + propValue;
    }
    var propType = getPropType(propValue);
    if (propType === 'object') {
      if (propValue instanceof Date) {
        return 'date';
      } else if (propValue instanceof RegExp) {
        return 'regexp';
      }
    }
    return propType;
  }

  // Returns a string that is postfixed to a warning about an invalid type.
  // For example, "undefined" or "of type array"
  function getPostfixForTypeWarning(value) {
    var type = getPreciseType(value);
    switch (type) {
      case 'array':
      case 'object':
        return 'an ' + type;
      case 'boolean':
      case 'date':
      case 'regexp':
        return 'a ' + type;
      default:
        return type;
    }
  }

  // Returns class name of the object, if any.
  function getClassName(propValue) {
    if (!propValue.constructor || !propValue.constructor.name) {
      return ANONYMOUS;
    }
    return propValue.constructor.name;
  }

  ReactPropTypes.checkPropTypes = checkPropTypes_1;
  ReactPropTypes.resetWarningCache = checkPropTypes_1.resetWarningCache;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};

function emptyFunction() {}
function emptyFunctionWithReset() {}
emptyFunctionWithReset.resetWarningCache = emptyFunction;

var factoryWithThrowingShims = function() {
  function shim(props, propName, componentName, location, propFullName, secret) {
    if (secret === ReactPropTypesSecret_1) {
      // It is still safe when called from React.
      return;
    }
    var err = new Error(
      'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
      'Use PropTypes.checkPropTypes() to call them. ' +
      'Read more at http://fb.me/use-check-prop-types'
    );
    err.name = 'Invariant Violation';
    throw err;
  }  shim.isRequired = shim;
  function getShim() {
    return shim;
  }  // Important!
  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.
  var ReactPropTypes = {
    array: shim,
    bool: shim,
    func: shim,
    number: shim,
    object: shim,
    string: shim,
    symbol: shim,

    any: shim,
    arrayOf: getShim,
    element: shim,
    elementType: shim,
    instanceOf: getShim,
    node: shim,
    objectOf: getShim,
    oneOf: getShim,
    oneOfType: getShim,
    shape: getShim,
    exact: getShim,

    checkPropTypes: emptyFunctionWithReset,
    resetWarningCache: emptyFunction
  };

  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};

var propTypes = createCommonjsModule(function (module) {
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

if (process.env.NODE_ENV !== 'production') {
  var ReactIs = reactIs;

  // By explicitly using `prop-types` you are opting into new development behavior.
  // http://fb.me/prop-types-in-prod
  var throwOnDirectAccess = true;
  module.exports = factoryWithTypeCheckers(ReactIs.isElement, throwOnDirectAccess);
} else {
  // By explicitly using `prop-types` you are opting into new production behavior.
  // http://fb.me/prop-types-in-prod
  module.exports = factoryWithThrowingShims();
}
});

function ascending(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}

function bisector(compare) {
  if (compare.length === 1) compare = ascendingComparator(compare);
  return {
    left: function(a, x, lo, hi) {
      if (lo == null) lo = 0;
      if (hi == null) hi = a.length;
      while (lo < hi) {
        var mid = lo + hi >>> 1;
        if (compare(a[mid], x) < 0) lo = mid + 1;
        else hi = mid;
      }
      return lo;
    },
    right: function(a, x, lo, hi) {
      if (lo == null) lo = 0;
      if (hi == null) hi = a.length;
      while (lo < hi) {
        var mid = lo + hi >>> 1;
        if (compare(a[mid], x) > 0) hi = mid;
        else lo = mid + 1;
      }
      return lo;
    }
  };
}

function ascendingComparator(f) {
  return function(d, x) {
    return ascending(f(d), x);
  };
}

var ascendingBisect = bisector(ascending);
var bisectRight = ascendingBisect.right;

function count(values, valueof) {
  let count = 0;
  if (valueof === undefined) {
    for (let value of values) {
      if (value != null && (value = +value) >= value) {
        ++count;
      }
    }
  } else {
    let index = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index, values)) != null && (value = +value) >= value) {
        ++count;
      }
    }
  }
  return count;
}

function extent(values, valueof) {
  let min;
  let max;
  if (valueof === undefined) {
    for (const value of values) {
      if (value != null) {
        if (min === undefined) {
          if (value >= value) min = max = value;
        } else {
          if (min > value) min = value;
          if (max < value) max = value;
        }
      }
    }
  } else {
    let index = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index, values)) != null) {
        if (min === undefined) {
          if (value >= value) min = max = value;
        } else {
          if (min > value) min = value;
          if (max < value) max = value;
        }
      }
    }
  }
  return [min, max];
}

function identity(x) {
  return x;
}

function group(values, ...keys) {
  return nest(values, identity, identity, keys);
}

function nest(values, map, reduce, keys) {
  return (function regroup(values, i) {
    if (i >= keys.length) return reduce(values);
    const groups = new Map();
    const keyof = keys[i++];
    let index = -1;
    for (const value of values) {
      const key = keyof(value, ++index, values);
      const group = groups.get(key);
      if (group) group.push(value);
      else groups.set(key, [value]);
    }
    for (const [key, values] of groups) {
      groups.set(key, regroup(values, i));
    }
    return map(groups);
  })(values, 0);
}

var array = Array.prototype;

var slice = array.slice;

function constant(x) {
  return function() {
    return x;
  };
}

function sequence(start, stop, step) {
  start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;

  var i = -1,
      n = Math.max(0, Math.ceil((stop - start) / step)) | 0,
      range = new Array(n);

  while (++i < n) {
    range[i] = start + i * step;
  }

  return range;
}

var e10 = Math.sqrt(50),
    e5 = Math.sqrt(10),
    e2 = Math.sqrt(2);

function ticks(start, stop, count) {
  var reverse,
      i = -1,
      n,
      ticks,
      step;

  stop = +stop, start = +start, count = +count;
  if (start === stop && count > 0) return [start];
  if (reverse = stop < start) n = start, start = stop, stop = n;
  if ((step = tickIncrement(start, stop, count)) === 0 || !isFinite(step)) return [];

  if (step > 0) {
    start = Math.ceil(start / step);
    stop = Math.floor(stop / step);
    ticks = new Array(n = Math.ceil(stop - start + 1));
    while (++i < n) ticks[i] = (start + i) * step;
  } else {
    start = Math.floor(start * step);
    stop = Math.ceil(stop * step);
    ticks = new Array(n = Math.ceil(start - stop + 1));
    while (++i < n) ticks[i] = (start - i) / step;
  }

  if (reverse) ticks.reverse();

  return ticks;
}

function tickIncrement(start, stop, count) {
  var step = (stop - start) / Math.max(0, count),
      power = Math.floor(Math.log(step) / Math.LN10),
      error = step / Math.pow(10, power);
  return power >= 0
      ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power)
      : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);
}

function tickStep(start, stop, count) {
  var step0 = Math.abs(stop - start) / Math.max(0, count),
      step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)),
      error = step0 / step1;
  if (error >= e10) step1 *= 10;
  else if (error >= e5) step1 *= 5;
  else if (error >= e2) step1 *= 2;
  return stop < start ? -step1 : step1;
}

function sturges(values) {
  return Math.ceil(Math.log(count(values)) / Math.LN2) + 1;
}

function histogram() {
  var value = identity,
      domain = extent,
      threshold = sturges;

  function histogram(data) {
    if (!Array.isArray(data)) data = Array.from(data);

    var i,
        n = data.length,
        x,
        values = new Array(n);

    for (i = 0; i < n; ++i) {
      values[i] = value(data[i], i, data);
    }

    var xz = domain(values),
        x0 = xz[0],
        x1 = xz[1],
        tz = threshold(values, x0, x1);

    // Convert number of thresholds into uniform thresholds.
    if (!Array.isArray(tz)) {
      tz = tickStep(x0, x1, tz);
      tz = sequence(Math.ceil(x0 / tz) * tz, x1, tz); // exclusive
    }

    // Remove any thresholds outside the domain.
    var m = tz.length;
    while (tz[0] <= x0) tz.shift(), --m;
    while (tz[m - 1] > x1) tz.pop(), --m;

    var bins = new Array(m + 1),
        bin;

    // Initialize bins.
    for (i = 0; i <= m; ++i) {
      bin = bins[i] = [];
      bin.x0 = i > 0 ? tz[i - 1] : x0;
      bin.x1 = i < m ? tz[i] : x1;
    }

    // Assign data to bins by value, ignoring any outside the domain.
    for (i = 0; i < n; ++i) {
      x = values[i];
      if (x0 <= x && x <= x1) {
        bins[bisectRight(tz, x, 0, m)].push(data[i]);
      }
    }

    return bins;
  }

  histogram.value = function(_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : constant(_), histogram) : value;
  };

  histogram.domain = function(_) {
    return arguments.length ? (domain = typeof _ === "function" ? _ : constant([_[0], _[1]]), histogram) : domain;
  };

  histogram.thresholds = function(_) {
    return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? constant(slice.call(_)) : constant(_), histogram) : threshold;
  };

  return histogram;
}

function max(values, valueof) {
  let max;
  if (valueof === undefined) {
    for (const value of values) {
      if (value != null
          && (max < value || (max === undefined && value >= value))) {
        max = value;
      }
    }
  } else {
    let index = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index, values)) != null
          && (max < value || (max === undefined && value >= value))) {
        max = value;
      }
    }
  }
  return max;
}

function min(values, valueof) {
  let min;
  if (valueof === undefined) {
    for (const value of values) {
      if (value != null
          && (min > value || (min === undefined && value >= value))) {
        min = value;
      }
    }
  } else {
    let index = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index, values)) != null
          && (min > value || (min === undefined && value >= value))) {
        min = value;
      }
    }
  }
  return min;
}

// Based on https://github.com/mourner/quickselect
// ISC license, Copyright 2018 Vladimir Agafonkin.
function quickselect(array, k, left = 0, right = array.length - 1, compare = ascending) {
  while (right > left) {
    if (right - left > 600) {
      const n = right - left + 1;
      const m = k - left + 1;
      const z = Math.log(n);
      const s = 0.5 * Math.exp(2 * z / 3);
      const sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
      const newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
      const newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
      quickselect(array, k, newLeft, newRight, compare);
    }

    const t = array[k];
    let i = left;
    let j = right;

    swap(array, left, k);
    if (compare(array[right], t) > 0) swap(array, left, right);

    while (i < j) {
      swap(array, i, j), ++i, --j;
      while (compare(array[i], t) < 0) ++i;
      while (compare(array[j], t) > 0) --j;
    }

    if (compare(array[left], t) === 0) swap(array, left, j);
    else ++j, swap(array, j, right);

    if (j <= k) left = j + 1;
    if (k <= j) right = j - 1;
  }
  return array;
}

function swap(array, i, j) {
  const t = array[i];
  array[i] = array[j];
  array[j] = t;
}

function* numbers(values, valueof) {
  if (valueof === undefined) {
    for (let value of values) {
      if (value != null && (value = +value) >= value) {
        yield value;
      }
    }
  } else {
    let index = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index, values)) != null && (value = +value) >= value) {
        yield value;
      }
    }
  }
}

function quantile(values, p, valueof) {
  values = Float64Array.from(numbers(values, valueof));
  if (!(n = values.length)) return;
  if ((p = +p) <= 0 || n < 2) return min(values);
  if (p >= 1) return max(values);
  var n,
      i = (n - 1) * p,
      i0 = Math.floor(i),
      value0 = max(quickselect(values, i0).subarray(0, i0 + 1)),
      value1 = min(values.subarray(i0 + 1));
  return value0 + (value1 - value0) * (i - i0);
}

function sum(values, valueof) {
  let sum = 0;
  if (valueof === undefined) {
    for (let value of values) {
      if (value = +value) {
        sum += value;
      }
    }
  } else {
    let index = -1;
    for (let value of values) {
      if (value = +valueof(value, ++index, values)) {
        sum += value;
      }
    }
  }
  return sum;
}

function initRange(domain, range) {
  switch (arguments.length) {
    case 0: break;
    case 1: this.range(domain); break;
    default: this.range(range).domain(domain); break;
  }
  return this;
}

const implicit = Symbol("implicit");

function ordinal() {
  var index = new Map(),
      domain = [],
      range = [],
      unknown = implicit;

  function scale(d) {
    var key = d + "", i = index.get(key);
    if (!i) {
      if (unknown !== implicit) return unknown;
      index.set(key, i = domain.push(d));
    }
    return range[(i - 1) % range.length];
  }

  scale.domain = function(_) {
    if (!arguments.length) return domain.slice();
    domain = [], index = new Map();
    for (const value of _) {
      const key = value + "";
      if (index.has(key)) continue;
      index.set(key, domain.push(value));
    }
    return scale;
  };

  scale.range = function(_) {
    return arguments.length ? (range = Array.from(_), scale) : range.slice();
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  scale.copy = function() {
    return ordinal(domain, range).unknown(unknown);
  };

  initRange.apply(scale, arguments);

  return scale;
}

function band() {
  var scale = ordinal().unknown(undefined),
      domain = scale.domain,
      ordinalRange = scale.range,
      r0 = 0,
      r1 = 1,
      step,
      bandwidth,
      round = false,
      paddingInner = 0,
      paddingOuter = 0,
      align = 0.5;

  delete scale.unknown;

  function rescale() {
    var n = domain().length,
        reverse = r1 < r0,
        start = reverse ? r1 : r0,
        stop = reverse ? r0 : r1;
    step = (stop - start) / Math.max(1, n - paddingInner + paddingOuter * 2);
    if (round) step = Math.floor(step);
    start += (stop - start - step * (n - paddingInner)) * align;
    bandwidth = step * (1 - paddingInner);
    if (round) start = Math.round(start), bandwidth = Math.round(bandwidth);
    var values = sequence(n).map(function(i) { return start + step * i; });
    return ordinalRange(reverse ? values.reverse() : values);
  }

  scale.domain = function(_) {
    return arguments.length ? (domain(_), rescale()) : domain();
  };

  scale.range = function(_) {
    return arguments.length ? ([r0, r1] = _, r0 = +r0, r1 = +r1, rescale()) : [r0, r1];
  };

  scale.rangeRound = function(_) {
    return [r0, r1] = _, r0 = +r0, r1 = +r1, round = true, rescale();
  };

  scale.bandwidth = function() {
    return bandwidth;
  };

  scale.step = function() {
    return step;
  };

  scale.round = function(_) {
    return arguments.length ? (round = !!_, rescale()) : round;
  };

  scale.padding = function(_) {
    return arguments.length ? (paddingInner = Math.min(1, paddingOuter = +_), rescale()) : paddingInner;
  };

  scale.paddingInner = function(_) {
    return arguments.length ? (paddingInner = Math.min(1, _), rescale()) : paddingInner;
  };

  scale.paddingOuter = function(_) {
    return arguments.length ? (paddingOuter = +_, rescale()) : paddingOuter;
  };

  scale.align = function(_) {
    return arguments.length ? (align = Math.max(0, Math.min(1, _)), rescale()) : align;
  };

  scale.copy = function() {
    return band(domain(), [r0, r1])
        .round(round)
        .paddingInner(paddingInner)
        .paddingOuter(paddingOuter)
        .align(align);
  };

  return initRange.apply(rescale(), arguments);
}

function define(constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
}

function extend(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key in definition) prototype[key] = definition[key];
  return prototype;
}

function Color() {}

var darker = 0.7;
var brighter = 1 / darker;

var reI = "\\s*([+-]?\\d+)\\s*",
    reN = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*",
    reP = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*",
    reHex = /^#([0-9a-f]{3,8})$/,
    reRgbInteger = new RegExp("^rgb\\(" + [reI, reI, reI] + "\\)$"),
    reRgbPercent = new RegExp("^rgb\\(" + [reP, reP, reP] + "\\)$"),
    reRgbaInteger = new RegExp("^rgba\\(" + [reI, reI, reI, reN] + "\\)$"),
    reRgbaPercent = new RegExp("^rgba\\(" + [reP, reP, reP, reN] + "\\)$"),
    reHslPercent = new RegExp("^hsl\\(" + [reN, reP, reP] + "\\)$"),
    reHslaPercent = new RegExp("^hsla\\(" + [reN, reP, reP, reN] + "\\)$");

var named = {
  aliceblue: 0xf0f8ff,
  antiquewhite: 0xfaebd7,
  aqua: 0x00ffff,
  aquamarine: 0x7fffd4,
  azure: 0xf0ffff,
  beige: 0xf5f5dc,
  bisque: 0xffe4c4,
  black: 0x000000,
  blanchedalmond: 0xffebcd,
  blue: 0x0000ff,
  blueviolet: 0x8a2be2,
  brown: 0xa52a2a,
  burlywood: 0xdeb887,
  cadetblue: 0x5f9ea0,
  chartreuse: 0x7fff00,
  chocolate: 0xd2691e,
  coral: 0xff7f50,
  cornflowerblue: 0x6495ed,
  cornsilk: 0xfff8dc,
  crimson: 0xdc143c,
  cyan: 0x00ffff,
  darkblue: 0x00008b,
  darkcyan: 0x008b8b,
  darkgoldenrod: 0xb8860b,
  darkgray: 0xa9a9a9,
  darkgreen: 0x006400,
  darkgrey: 0xa9a9a9,
  darkkhaki: 0xbdb76b,
  darkmagenta: 0x8b008b,
  darkolivegreen: 0x556b2f,
  darkorange: 0xff8c00,
  darkorchid: 0x9932cc,
  darkred: 0x8b0000,
  darksalmon: 0xe9967a,
  darkseagreen: 0x8fbc8f,
  darkslateblue: 0x483d8b,
  darkslategray: 0x2f4f4f,
  darkslategrey: 0x2f4f4f,
  darkturquoise: 0x00ced1,
  darkviolet: 0x9400d3,
  deeppink: 0xff1493,
  deepskyblue: 0x00bfff,
  dimgray: 0x696969,
  dimgrey: 0x696969,
  dodgerblue: 0x1e90ff,
  firebrick: 0xb22222,
  floralwhite: 0xfffaf0,
  forestgreen: 0x228b22,
  fuchsia: 0xff00ff,
  gainsboro: 0xdcdcdc,
  ghostwhite: 0xf8f8ff,
  gold: 0xffd700,
  goldenrod: 0xdaa520,
  gray: 0x808080,
  green: 0x008000,
  greenyellow: 0xadff2f,
  grey: 0x808080,
  honeydew: 0xf0fff0,
  hotpink: 0xff69b4,
  indianred: 0xcd5c5c,
  indigo: 0x4b0082,
  ivory: 0xfffff0,
  khaki: 0xf0e68c,
  lavender: 0xe6e6fa,
  lavenderblush: 0xfff0f5,
  lawngreen: 0x7cfc00,
  lemonchiffon: 0xfffacd,
  lightblue: 0xadd8e6,
  lightcoral: 0xf08080,
  lightcyan: 0xe0ffff,
  lightgoldenrodyellow: 0xfafad2,
  lightgray: 0xd3d3d3,
  lightgreen: 0x90ee90,
  lightgrey: 0xd3d3d3,
  lightpink: 0xffb6c1,
  lightsalmon: 0xffa07a,
  lightseagreen: 0x20b2aa,
  lightskyblue: 0x87cefa,
  lightslategray: 0x778899,
  lightslategrey: 0x778899,
  lightsteelblue: 0xb0c4de,
  lightyellow: 0xffffe0,
  lime: 0x00ff00,
  limegreen: 0x32cd32,
  linen: 0xfaf0e6,
  magenta: 0xff00ff,
  maroon: 0x800000,
  mediumaquamarine: 0x66cdaa,
  mediumblue: 0x0000cd,
  mediumorchid: 0xba55d3,
  mediumpurple: 0x9370db,
  mediumseagreen: 0x3cb371,
  mediumslateblue: 0x7b68ee,
  mediumspringgreen: 0x00fa9a,
  mediumturquoise: 0x48d1cc,
  mediumvioletred: 0xc71585,
  midnightblue: 0x191970,
  mintcream: 0xf5fffa,
  mistyrose: 0xffe4e1,
  moccasin: 0xffe4b5,
  navajowhite: 0xffdead,
  navy: 0x000080,
  oldlace: 0xfdf5e6,
  olive: 0x808000,
  olivedrab: 0x6b8e23,
  orange: 0xffa500,
  orangered: 0xff4500,
  orchid: 0xda70d6,
  palegoldenrod: 0xeee8aa,
  palegreen: 0x98fb98,
  paleturquoise: 0xafeeee,
  palevioletred: 0xdb7093,
  papayawhip: 0xffefd5,
  peachpuff: 0xffdab9,
  peru: 0xcd853f,
  pink: 0xffc0cb,
  plum: 0xdda0dd,
  powderblue: 0xb0e0e6,
  purple: 0x800080,
  rebeccapurple: 0x663399,
  red: 0xff0000,
  rosybrown: 0xbc8f8f,
  royalblue: 0x4169e1,
  saddlebrown: 0x8b4513,
  salmon: 0xfa8072,
  sandybrown: 0xf4a460,
  seagreen: 0x2e8b57,
  seashell: 0xfff5ee,
  sienna: 0xa0522d,
  silver: 0xc0c0c0,
  skyblue: 0x87ceeb,
  slateblue: 0x6a5acd,
  slategray: 0x708090,
  slategrey: 0x708090,
  snow: 0xfffafa,
  springgreen: 0x00ff7f,
  steelblue: 0x4682b4,
  tan: 0xd2b48c,
  teal: 0x008080,
  thistle: 0xd8bfd8,
  tomato: 0xff6347,
  turquoise: 0x40e0d0,
  violet: 0xee82ee,
  wheat: 0xf5deb3,
  white: 0xffffff,
  whitesmoke: 0xf5f5f5,
  yellow: 0xffff00,
  yellowgreen: 0x9acd32
};

define(Color, color, {
  copy: function(channels) {
    return Object.assign(new this.constructor, this, channels);
  },
  displayable: function() {
    return this.rgb().displayable();
  },
  hex: color_formatHex, // Deprecated! Use color.formatHex.
  formatHex: color_formatHex,
  formatHsl: color_formatHsl,
  formatRgb: color_formatRgb,
  toString: color_formatRgb
});

function color_formatHex() {
  return this.rgb().formatHex();
}

function color_formatHsl() {
  return hslConvert(this).formatHsl();
}

function color_formatRgb() {
  return this.rgb().formatRgb();
}

function color(format) {
  var m, l;
  format = (format + "").trim().toLowerCase();
  return (m = reHex.exec(format)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) // #ff0000
      : l === 3 ? new Rgb((m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), ((m & 0xf) << 4) | (m & 0xf), 1) // #f00
      : l === 8 ? new Rgb(m >> 24 & 0xff, m >> 16 & 0xff, m >> 8 & 0xff, (m & 0xff) / 0xff) // #ff000000
      : l === 4 ? new Rgb((m >> 12 & 0xf) | (m >> 8 & 0xf0), (m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), (((m & 0xf) << 4) | (m & 0xf)) / 0xff) // #f000
      : null) // invalid hex
      : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) // rgb(255, 0, 0)
      : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)
      : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)
      : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)
      : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)
      : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)
      : named.hasOwnProperty(format) ? rgbn(named[format]) // eslint-disable-line no-prototype-builtins
      : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0)
      : null;
}

function rgbn(n) {
  return new Rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);
}

function rgba(r, g, b, a) {
  if (a <= 0) r = g = b = NaN;
  return new Rgb(r, g, b, a);
}

function rgbConvert(o) {
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Rgb;
  o = o.rgb();
  return new Rgb(o.r, o.g, o.b, o.opacity);
}

function rgb(r, g, b, opacity) {
  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
}

function Rgb(r, g, b, opacity) {
  this.r = +r;
  this.g = +g;
  this.b = +b;
  this.opacity = +opacity;
}

define(Rgb, rgb, extend(Color, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  rgb: function() {
    return this;
  },
  displayable: function() {
    return (-0.5 <= this.r && this.r < 255.5)
        && (-0.5 <= this.g && this.g < 255.5)
        && (-0.5 <= this.b && this.b < 255.5)
        && (0 <= this.opacity && this.opacity <= 1);
  },
  hex: rgb_formatHex, // Deprecated! Use color.formatHex.
  formatHex: rgb_formatHex,
  formatRgb: rgb_formatRgb,
  toString: rgb_formatRgb
}));

function rgb_formatHex() {
  return "#" + hex(this.r) + hex(this.g) + hex(this.b);
}

function rgb_formatRgb() {
  var a = this.opacity; a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
  return (a === 1 ? "rgb(" : "rgba(")
      + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", "
      + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", "
      + Math.max(0, Math.min(255, Math.round(this.b) || 0))
      + (a === 1 ? ")" : ", " + a + ")");
}

function hex(value) {
  value = Math.max(0, Math.min(255, Math.round(value) || 0));
  return (value < 16 ? "0" : "") + value.toString(16);
}

function hsla(h, s, l, a) {
  if (a <= 0) h = s = l = NaN;
  else if (l <= 0 || l >= 1) h = s = NaN;
  else if (s <= 0) h = NaN;
  return new Hsl(h, s, l, a);
}

function hslConvert(o) {
  if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Hsl;
  if (o instanceof Hsl) return o;
  o = o.rgb();
  var r = o.r / 255,
      g = o.g / 255,
      b = o.b / 255,
      min = Math.min(r, g, b),
      max = Math.max(r, g, b),
      h = NaN,
      s = max - min,
      l = (max + min) / 2;
  if (s) {
    if (r === max) h = (g - b) / s + (g < b) * 6;
    else if (g === max) h = (b - r) / s + 2;
    else h = (r - g) / s + 4;
    s /= l < 0.5 ? max + min : 2 - max - min;
    h *= 60;
  } else {
    s = l > 0 && l < 1 ? 0 : h;
  }
  return new Hsl(h, s, l, o.opacity);
}

function hsl(h, s, l, opacity) {
  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
}

function Hsl(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}

define(Hsl, hsl, extend(Color, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  rgb: function() {
    var h = this.h % 360 + (this.h < 0) * 360,
        s = isNaN(h) || isNaN(this.s) ? 0 : this.s,
        l = this.l,
        m2 = l + (l < 0.5 ? l : 1 - l) * s,
        m1 = 2 * l - m2;
    return new Rgb(
      hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
      hsl2rgb(h, m1, m2),
      hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
      this.opacity
    );
  },
  displayable: function() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s))
        && (0 <= this.l && this.l <= 1)
        && (0 <= this.opacity && this.opacity <= 1);
  },
  formatHsl: function() {
    var a = this.opacity; a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
    return (a === 1 ? "hsl(" : "hsla(")
        + (this.h || 0) + ", "
        + (this.s || 0) * 100 + "%, "
        + (this.l || 0) * 100 + "%"
        + (a === 1 ? ")" : ", " + a + ")");
  }
}));

/* From FvD 13.37, CSS Color Module Level 3 */
function hsl2rgb(h, m1, m2) {
  return (h < 60 ? m1 + (m2 - m1) * h / 60
      : h < 180 ? m2
      : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60
      : m1) * 255;
}

var deg2rad = Math.PI / 180;
var rad2deg = 180 / Math.PI;

// https://observablehq.com/@mbostock/lab-and-rgb
var K = 18,
    Xn = 0.96422,
    Yn = 1,
    Zn = 0.82521,
    t0 = 4 / 29,
    t1 = 6 / 29,
    t2 = 3 * t1 * t1,
    t3 = t1 * t1 * t1;

function labConvert(o) {
  if (o instanceof Lab) return new Lab(o.l, o.a, o.b, o.opacity);
  if (o instanceof Hcl) return hcl2lab(o);
  if (!(o instanceof Rgb)) o = rgbConvert(o);
  var r = rgb2lrgb(o.r),
      g = rgb2lrgb(o.g),
      b = rgb2lrgb(o.b),
      y = xyz2lab((0.2225045 * r + 0.7168786 * g + 0.0606169 * b) / Yn), x, z;
  if (r === g && g === b) x = z = y; else {
    x = xyz2lab((0.4360747 * r + 0.3850649 * g + 0.1430804 * b) / Xn);
    z = xyz2lab((0.0139322 * r + 0.0971045 * g + 0.7141733 * b) / Zn);
  }
  return new Lab(116 * y - 16, 500 * (x - y), 200 * (y - z), o.opacity);
}

function gray(l, opacity) {
  return new Lab(l, 0, 0, opacity == null ? 1 : opacity);
}

function lab(l, a, b, opacity) {
  return arguments.length === 1 ? labConvert(l) : new Lab(l, a, b, opacity == null ? 1 : opacity);
}

function Lab(l, a, b, opacity) {
  this.l = +l;
  this.a = +a;
  this.b = +b;
  this.opacity = +opacity;
}

define(Lab, lab, extend(Color, {
  brighter: function(k) {
    return new Lab(this.l + K * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  darker: function(k) {
    return new Lab(this.l - K * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  rgb: function() {
    var y = (this.l + 16) / 116,
        x = isNaN(this.a) ? y : y + this.a / 500,
        z = isNaN(this.b) ? y : y - this.b / 200;
    x = Xn * lab2xyz(x);
    y = Yn * lab2xyz(y);
    z = Zn * lab2xyz(z);
    return new Rgb(
      lrgb2rgb( 3.1338561 * x - 1.6168667 * y - 0.4906146 * z),
      lrgb2rgb(-0.9787684 * x + 1.9161415 * y + 0.0334540 * z),
      lrgb2rgb( 0.0719453 * x - 0.2289914 * y + 1.4052427 * z),
      this.opacity
    );
  }
}));

function xyz2lab(t) {
  return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;
}

function lab2xyz(t) {
  return t > t1 ? t * t * t : t2 * (t - t0);
}

function lrgb2rgb(x) {
  return 255 * (x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);
}

function rgb2lrgb(x) {
  return (x /= 255) <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
}

function hclConvert(o) {
  if (o instanceof Hcl) return new Hcl(o.h, o.c, o.l, o.opacity);
  if (!(o instanceof Lab)) o = labConvert(o);
  if (o.a === 0 && o.b === 0) return new Hcl(NaN, 0 < o.l && o.l < 100 ? 0 : NaN, o.l, o.opacity);
  var h = Math.atan2(o.b, o.a) * rad2deg;
  return new Hcl(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
}

function lch(l, c, h, opacity) {
  return arguments.length === 1 ? hclConvert(l) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
}

function hcl(h, c, l, opacity) {
  return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
}

function Hcl(h, c, l, opacity) {
  this.h = +h;
  this.c = +c;
  this.l = +l;
  this.opacity = +opacity;
}

function hcl2lab(o) {
  if (isNaN(o.h)) return new Lab(o.l, 0, 0, o.opacity);
  var h = o.h * deg2rad;
  return new Lab(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);
}

define(Hcl, hcl, extend(Color, {
  brighter: function(k) {
    return new Hcl(this.h, this.c, this.l + K * (k == null ? 1 : k), this.opacity);
  },
  darker: function(k) {
    return new Hcl(this.h, this.c, this.l - K * (k == null ? 1 : k), this.opacity);
  },
  rgb: function() {
    return hcl2lab(this).rgb();
  }
}));

var A = -0.14861,
    B = +1.78277,
    C = -0.29227,
    D = -0.90649,
    E = +1.97294,
    ED = E * D,
    EB = E * B,
    BC_DA = B * C - D * A;

function cubehelixConvert(o) {
  if (o instanceof Cubehelix) return new Cubehelix(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Rgb)) o = rgbConvert(o);
  var r = o.r / 255,
      g = o.g / 255,
      b = o.b / 255,
      l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB),
      bl = b - l,
      k = (E * (g - l) - C * bl) / D,
      s = Math.sqrt(k * k + bl * bl) / (E * l * (1 - l)), // NaN if l=0 or l=1
      h = s ? Math.atan2(k, bl) * rad2deg - 120 : NaN;
  return new Cubehelix(h < 0 ? h + 360 : h, s, l, o.opacity);
}

function cubehelix(h, s, l, opacity) {
  return arguments.length === 1 ? cubehelixConvert(h) : new Cubehelix(h, s, l, opacity == null ? 1 : opacity);
}

function Cubehelix(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}

define(Cubehelix, cubehelix, extend(Color, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  rgb: function() {
    var h = isNaN(this.h) ? 0 : (this.h + 120) * deg2rad,
        l = +this.l,
        a = isNaN(this.s) ? 0 : this.s * l * (1 - l),
        cosh = Math.cos(h),
        sinh = Math.sin(h);
    return new Rgb(
      255 * (l + a * (A * cosh + B * sinh)),
      255 * (l + a * (C * cosh + D * sinh)),
      255 * (l + a * (E * cosh)),
      this.opacity
    );
  }
}));



var src = /*#__PURE__*/Object.freeze({
	__proto__: null,
	color: color,
	rgb: rgb,
	hsl: hsl,
	lab: lab,
	hcl: hcl,
	lch: lch,
	gray: gray,
	cubehelix: cubehelix
});

function constant$1(x) {
  return function() {
    return x;
  };
}

function linear(a, d) {
  return function(t) {
    return a + t * d;
  };
}

function exponential(a, b, y) {
  return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
    return Math.pow(a + t * b, y);
  };
}

function hue(a, b) {
  var d = b - a;
  return d ? linear(a, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : constant$1(isNaN(a) ? b : a);
}

function gamma(y) {
  return (y = +y) === 1 ? nogamma : function(a, b) {
    return b - a ? exponential(a, b, y) : constant$1(isNaN(a) ? b : a);
  };
}

function nogamma(a, b) {
  var d = b - a;
  return d ? linear(a, d) : constant$1(isNaN(a) ? b : a);
}

var interpolateRgb = (function rgbGamma(y) {
  var color = gamma(y);

  function rgb$1(start, end) {
    var r = color((start = rgb(start)).r, (end = rgb(end)).r),
        g = color(start.g, end.g),
        b = color(start.b, end.b),
        opacity = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.r = r(t);
      start.g = g(t);
      start.b = b(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }

  rgb$1.gamma = rgbGamma;

  return rgb$1;
})(1);

function numberArray(a, b) {
  if (!b) b = [];
  var n = a ? Math.min(b.length, a.length) : 0,
      c = b.slice(),
      i;
  return function(t) {
    for (i = 0; i < n; ++i) c[i] = a[i] * (1 - t) + b[i] * t;
    return c;
  };
}

function isNumberArray(x) {
  return ArrayBuffer.isView(x) && !(x instanceof DataView);
}

function genericArray(a, b) {
  var nb = b ? b.length : 0,
      na = a ? Math.min(nb, a.length) : 0,
      x = new Array(na),
      c = new Array(nb),
      i;

  for (i = 0; i < na; ++i) x[i] = interpolate(a[i], b[i]);
  for (; i < nb; ++i) c[i] = b[i];

  return function(t) {
    for (i = 0; i < na; ++i) c[i] = x[i](t);
    return c;
  };
}

function date(a, b) {
  var d = new Date;
  return a = +a, b = +b, function(t) {
    return d.setTime(a * (1 - t) + b * t), d;
  };
}

function interpolateNumber(a, b) {
  return a = +a, b = +b, function(t) {
    return a * (1 - t) + b * t;
  };
}

function object(a, b) {
  var i = {},
      c = {},
      k;

  if (a === null || typeof a !== "object") a = {};
  if (b === null || typeof b !== "object") b = {};

  for (k in b) {
    if (k in a) {
      i[k] = interpolate(a[k], b[k]);
    } else {
      c[k] = b[k];
    }
  }

  return function(t) {
    for (k in i) c[k] = i[k](t);
    return c;
  };
}

var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
    reB = new RegExp(reA.source, "g");

function zero(b) {
  return function() {
    return b;
  };
}

function one(b) {
  return function(t) {
    return b(t) + "";
  };
}

function interpolateString(a, b) {
  var bi = reA.lastIndex = reB.lastIndex = 0, // scan index for next number in b
      am, // current match in a
      bm, // current match in b
      bs, // string preceding current number in b, if any
      i = -1, // index in s
      s = [], // string constants and placeholders
      q = []; // number interpolators

  // Coerce inputs to strings.
  a = a + "", b = b + "";

  // Interpolate pairs of numbers in a & b.
  while ((am = reA.exec(a))
      && (bm = reB.exec(b))) {
    if ((bs = bm.index) > bi) { // a string precedes the next number in b
      bs = b.slice(bi, bs);
      if (s[i]) s[i] += bs; // coalesce with previous string
      else s[++i] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) { // numbers in a & b match
      if (s[i]) s[i] += bm; // coalesce with previous string
      else s[++i] = bm;
    } else { // interpolate non-matching numbers
      s[++i] = null;
      q.push({i: i, x: interpolateNumber(am, bm)});
    }
    bi = reB.lastIndex;
  }

  // Add remains of b.
  if (bi < b.length) {
    bs = b.slice(bi);
    if (s[i]) s[i] += bs; // coalesce with previous string
    else s[++i] = bs;
  }

  // Special optimization for only a single match.
  // Otherwise, interpolate each of the numbers and rejoin the string.
  return s.length < 2 ? (q[0]
      ? one(q[0].x)
      : zero(b))
      : (b = q.length, function(t) {
          for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);
          return s.join("");
        });
}

function interpolate(a, b) {
  var t = typeof b, c;
  return b == null || t === "boolean" ? constant$1(b)
      : (t === "number" ? interpolateNumber
      : t === "string" ? ((c = color(b)) ? (b = c, interpolateRgb) : interpolateString)
      : b instanceof color ? interpolateRgb
      : b instanceof Date ? date
      : isNumberArray(b) ? numberArray
      : Array.isArray(b) ? genericArray
      : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? object
      : interpolateNumber)(a, b);
}

function interpolateRound(a, b) {
  return a = +a, b = +b, function(t) {
    return Math.round(a * (1 - t) + b * t);
  };
}

var degrees = 180 / Math.PI;

var identity$1 = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};

function decompose(a, b, c, d, e, f) {
  var scaleX, scaleY, skewX;
  if (scaleX = Math.sqrt(a * a + b * b)) a /= scaleX, b /= scaleX;
  if (skewX = a * c + b * d) c -= a * skewX, d -= b * skewX;
  if (scaleY = Math.sqrt(c * c + d * d)) c /= scaleY, d /= scaleY, skewX /= scaleY;
  if (a * d < b * c) a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
  return {
    translateX: e,
    translateY: f,
    rotate: Math.atan2(b, a) * degrees,
    skewX: Math.atan(skewX) * degrees,
    scaleX: scaleX,
    scaleY: scaleY
  };
}

var cssNode,
    cssRoot,
    cssView,
    svgNode;

function parseCss(value) {
  if (value === "none") return identity$1;
  if (!cssNode) cssNode = document.createElement("DIV"), cssRoot = document.documentElement, cssView = document.defaultView;
  cssNode.style.transform = value;
  value = cssView.getComputedStyle(cssRoot.appendChild(cssNode), null).getPropertyValue("transform");
  cssRoot.removeChild(cssNode);
  value = value.slice(7, -1).split(",");
  return decompose(+value[0], +value[1], +value[2], +value[3], +value[4], +value[5]);
}

function parseSvg(value) {
  if (value == null) return identity$1;
  if (!svgNode) svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
  svgNode.setAttribute("transform", value);
  if (!(value = svgNode.transform.baseVal.consolidate())) return identity$1;
  value = value.matrix;
  return decompose(value.a, value.b, value.c, value.d, value.e, value.f);
}

function interpolateTransform(parse, pxComma, pxParen, degParen) {

  function pop(s) {
    return s.length ? s.pop() + " " : "";
  }

  function translate(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push("translate(", null, pxComma, null, pxParen);
      q.push({i: i - 4, x: interpolateNumber(xa, xb)}, {i: i - 2, x: interpolateNumber(ya, yb)});
    } else if (xb || yb) {
      s.push("translate(" + xb + pxComma + yb + pxParen);
    }
  }

  function rotate(a, b, s, q) {
    if (a !== b) {
      if (a - b > 180) b += 360; else if (b - a > 180) a += 360; // shortest path
      q.push({i: s.push(pop(s) + "rotate(", null, degParen) - 2, x: interpolateNumber(a, b)});
    } else if (b) {
      s.push(pop(s) + "rotate(" + b + degParen);
    }
  }

  function skewX(a, b, s, q) {
    if (a !== b) {
      q.push({i: s.push(pop(s) + "skewX(", null, degParen) - 2, x: interpolateNumber(a, b)});
    } else if (b) {
      s.push(pop(s) + "skewX(" + b + degParen);
    }
  }

  function scale(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push(pop(s) + "scale(", null, ",", null, ")");
      q.push({i: i - 4, x: interpolateNumber(xa, xb)}, {i: i - 2, x: interpolateNumber(ya, yb)});
    } else if (xb !== 1 || yb !== 1) {
      s.push(pop(s) + "scale(" + xb + "," + yb + ")");
    }
  }

  return function(a, b) {
    var s = [], // string constants and placeholders
        q = []; // number interpolators
    a = parse(a), b = parse(b);
    translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);
    rotate(a.rotate, b.rotate, s, q);
    skewX(a.skewX, b.skewX, s, q);
    scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
    a = b = null; // gc
    return function(t) {
      var i = -1, n = q.length, o;
      while (++i < n) s[(o = q[i]).i] = o.x(t);
      return s.join("");
    };
  };
}

var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");

function cubehelix$1(hue) {
  return (function cubehelixGamma(y) {
    y = +y;

    function cubehelix$1(start, end) {
      var h = hue((start = cubehelix(start)).h, (end = cubehelix(end)).h),
          s = nogamma(start.s, end.s),
          l = nogamma(start.l, end.l),
          opacity = nogamma(start.opacity, end.opacity);
      return function(t) {
        start.h = h(t);
        start.s = s(t);
        start.l = l(Math.pow(t, y));
        start.opacity = opacity(t);
        return start + "";
      };
    }

    cubehelix$1.gamma = cubehelixGamma;

    return cubehelix$1;
  })(1);
}

cubehelix$1(hue);
var cubehelixLong = cubehelix$1(nogamma);

function constant$2(x) {
  return function() {
    return x;
  };
}

function number(x) {
  return +x;
}

var unit = [0, 1];

function identity$2(x) {
  return x;
}

function normalize(a, b) {
  return (b -= (a = +a))
      ? function(x) { return (x - a) / b; }
      : constant$2(isNaN(b) ? NaN : 0.5);
}

function clamper(a, b) {
  var t;
  if (a > b) t = a, a = b, b = t;
  return function(x) { return Math.max(a, Math.min(b, x)); };
}

// normalize(a, b)(x) takes a domain value x in [a,b] and returns the corresponding parameter t in [0,1].
// interpolate(a, b)(t) takes a parameter t in [0,1] and returns the corresponding range value x in [a,b].
function bimap(domain, range, interpolate) {
  var d0 = domain[0], d1 = domain[1], r0 = range[0], r1 = range[1];
  if (d1 < d0) d0 = normalize(d1, d0), r0 = interpolate(r1, r0);
  else d0 = normalize(d0, d1), r0 = interpolate(r0, r1);
  return function(x) { return r0(d0(x)); };
}

function polymap(domain, range, interpolate) {
  var j = Math.min(domain.length, range.length) - 1,
      d = new Array(j),
      r = new Array(j),
      i = -1;

  // Reverse descending domains.
  if (domain[j] < domain[0]) {
    domain = domain.slice().reverse();
    range = range.slice().reverse();
  }

  while (++i < j) {
    d[i] = normalize(domain[i], domain[i + 1]);
    r[i] = interpolate(range[i], range[i + 1]);
  }

  return function(x) {
    var i = bisectRight(domain, x, 1, j) - 1;
    return r[i](d[i](x));
  };
}

function copy(source, target) {
  return target
      .domain(source.domain())
      .range(source.range())
      .interpolate(source.interpolate())
      .clamp(source.clamp())
      .unknown(source.unknown());
}

function transformer() {
  var domain = unit,
      range = unit,
      interpolate$1 = interpolate,
      transform,
      untransform,
      unknown,
      clamp = identity$2,
      piecewise,
      output,
      input;

  function rescale() {
    var n = Math.min(domain.length, range.length);
    if (clamp !== identity$2) clamp = clamper(domain[0], domain[n - 1]);
    piecewise = n > 2 ? polymap : bimap;
    output = input = null;
    return scale;
  }

  function scale(x) {
    return isNaN(x = +x) ? unknown : (output || (output = piecewise(domain.map(transform), range, interpolate$1)))(transform(clamp(x)));
  }

  scale.invert = function(y) {
    return clamp(untransform((input || (input = piecewise(range, domain.map(transform), interpolateNumber)))(y)));
  };

  scale.domain = function(_) {
    return arguments.length ? (domain = Array.from(_, number), rescale()) : domain.slice();
  };

  scale.range = function(_) {
    return arguments.length ? (range = Array.from(_), rescale()) : range.slice();
  };

  scale.rangeRound = function(_) {
    return range = Array.from(_), interpolate$1 = interpolateRound, rescale();
  };

  scale.clamp = function(_) {
    return arguments.length ? (clamp = _ ? true : identity$2, rescale()) : clamp !== identity$2;
  };

  scale.interpolate = function(_) {
    return arguments.length ? (interpolate$1 = _, rescale()) : interpolate$1;
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  return function(t, u) {
    transform = t, untransform = u;
    return rescale();
  };
}

function continuous() {
  return transformer()(identity$2, identity$2);
}

// Computes the decimal coefficient and exponent of the specified number x with
// significant digits p, where x is positive and p is in [1, 21] or undefined.
// For example, formatDecimal(1.23) returns ["123", 0].
function formatDecimal(x, p) {
  if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0) return null; // NaN, ±Infinity
  var i, coefficient = x.slice(0, i);

  // The string returned by toExponential either has the form \d\.\d+e[-+]\d+
  // (e.g., 1.2e+3) or the form \de[-+]\d+ (e.g., 1e+3).
  return [
    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
    +x.slice(i + 1)
  ];
}

function exponent(x) {
  return x = formatDecimal(Math.abs(x)), x ? x[1] : NaN;
}

function formatGroup(grouping, thousands) {
  return function(value, width) {
    var i = value.length,
        t = [],
        j = 0,
        g = grouping[0],
        length = 0;

    while (i > 0 && g > 0) {
      if (length + g + 1 > width) g = Math.max(1, width - length);
      t.push(value.substring(i -= g, i + g));
      if ((length += g + 1) > width) break;
      g = grouping[j = (j + 1) % grouping.length];
    }

    return t.reverse().join(thousands);
  };
}

function formatNumerals(numerals) {
  return function(value) {
    return value.replace(/[0-9]/g, function(i) {
      return numerals[+i];
    });
  };
}

// [[fill]align][sign][symbol][0][width][,][.precision][~][type]
var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;

function formatSpecifier(specifier) {
  if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);
  var match;
  return new FormatSpecifier({
    fill: match[1],
    align: match[2],
    sign: match[3],
    symbol: match[4],
    zero: match[5],
    width: match[6],
    comma: match[7],
    precision: match[8] && match[8].slice(1),
    trim: match[9],
    type: match[10]
  });
}

formatSpecifier.prototype = FormatSpecifier.prototype; // instanceof

function FormatSpecifier(specifier) {
  this.fill = specifier.fill === undefined ? " " : specifier.fill + "";
  this.align = specifier.align === undefined ? ">" : specifier.align + "";
  this.sign = specifier.sign === undefined ? "-" : specifier.sign + "";
  this.symbol = specifier.symbol === undefined ? "" : specifier.symbol + "";
  this.zero = !!specifier.zero;
  this.width = specifier.width === undefined ? undefined : +specifier.width;
  this.comma = !!specifier.comma;
  this.precision = specifier.precision === undefined ? undefined : +specifier.precision;
  this.trim = !!specifier.trim;
  this.type = specifier.type === undefined ? "" : specifier.type + "";
}

FormatSpecifier.prototype.toString = function() {
  return this.fill
      + this.align
      + this.sign
      + this.symbol
      + (this.zero ? "0" : "")
      + (this.width === undefined ? "" : Math.max(1, this.width | 0))
      + (this.comma ? "," : "")
      + (this.precision === undefined ? "" : "." + Math.max(0, this.precision | 0))
      + (this.trim ? "~" : "")
      + this.type;
};

// Trims insignificant zeros, e.g., replaces 1.2000k with 1.2k.
function formatTrim(s) {
  out: for (var n = s.length, i = 1, i0 = -1, i1; i < n; ++i) {
    switch (s[i]) {
      case ".": i0 = i1 = i; break;
      case "0": if (i0 === 0) i0 = i; i1 = i; break;
      default: if (i0 > 0) { if (!+s[i]) break out; i0 = 0; } break;
    }
  }
  return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;
}

var prefixExponent;

function formatPrefixAuto(x, p) {
  var d = formatDecimal(x, p);
  if (!d) return x + "";
  var coefficient = d[0],
      exponent = d[1],
      i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,
      n = coefficient.length;
  return i === n ? coefficient
      : i > n ? coefficient + new Array(i - n + 1).join("0")
      : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i)
      : "0." + new Array(1 - i).join("0") + formatDecimal(x, Math.max(0, p + i - 1))[0]; // less than 1y!
}

function formatRounded(x, p) {
  var d = formatDecimal(x, p);
  if (!d) return x + "";
  var coefficient = d[0],
      exponent = d[1];
  return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient
      : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1)
      : coefficient + new Array(exponent - coefficient.length + 2).join("0");
}

var formatTypes = {
  "%": function(x, p) { return (x * 100).toFixed(p); },
  "b": function(x) { return Math.round(x).toString(2); },
  "c": function(x) { return x + ""; },
  "d": function(x) { return Math.round(x).toString(10); },
  "e": function(x, p) { return x.toExponential(p); },
  "f": function(x, p) { return x.toFixed(p); },
  "g": function(x, p) { return x.toPrecision(p); },
  "o": function(x) { return Math.round(x).toString(8); },
  "p": function(x, p) { return formatRounded(x * 100, p); },
  "r": formatRounded,
  "s": formatPrefixAuto,
  "X": function(x) { return Math.round(x).toString(16).toUpperCase(); },
  "x": function(x) { return Math.round(x).toString(16); }
};

function identity$3(x) {
  return x;
}

var map = Array.prototype.map,
    prefixes = ["y","z","a","f","p","n","µ","m","","k","M","G","T","P","E","Z","Y"];

function formatLocale(locale) {
  var group = locale.grouping === undefined || locale.thousands === undefined ? identity$3 : formatGroup(map.call(locale.grouping, Number), locale.thousands + ""),
      currencyPrefix = locale.currency === undefined ? "" : locale.currency[0] + "",
      currencySuffix = locale.currency === undefined ? "" : locale.currency[1] + "",
      decimal = locale.decimal === undefined ? "." : locale.decimal + "",
      numerals = locale.numerals === undefined ? identity$3 : formatNumerals(map.call(locale.numerals, String)),
      percent = locale.percent === undefined ? "%" : locale.percent + "",
      minus = locale.minus === undefined ? "-" : locale.minus + "",
      nan = locale.nan === undefined ? "NaN" : locale.nan + "";

  function newFormat(specifier) {
    specifier = formatSpecifier(specifier);

    var fill = specifier.fill,
        align = specifier.align,
        sign = specifier.sign,
        symbol = specifier.symbol,
        zero = specifier.zero,
        width = specifier.width,
        comma = specifier.comma,
        precision = specifier.precision,
        trim = specifier.trim,
        type = specifier.type;

    // The "n" type is an alias for ",g".
    if (type === "n") comma = true, type = "g";

    // The "" type, and any invalid type, is an alias for ".12~g".
    else if (!formatTypes[type]) precision === undefined && (precision = 12), trim = true, type = "g";

    // If zero fill is specified, padding goes after sign and before digits.
    if (zero || (fill === "0" && align === "=")) zero = true, fill = "0", align = "=";

    // Compute the prefix and suffix.
    // For SI-prefix, the suffix is lazily computed.
    var prefix = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "",
        suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type) ? percent : "";

    // What format function should we use?
    // Is this an integer type?
    // Can this type generate exponential notation?
    var formatType = formatTypes[type],
        maybeSuffix = /[defgprs%]/.test(type);

    // Set the default precision if not specified,
    // or clamp the specified precision to the supported range.
    // For significant precision, it must be in [1, 21].
    // For fixed precision, it must be in [0, 20].
    precision = precision === undefined ? 6
        : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision))
        : Math.max(0, Math.min(20, precision));

    function format(value) {
      var valuePrefix = prefix,
          valueSuffix = suffix,
          i, n, c;

      if (type === "c") {
        valueSuffix = formatType(value) + valueSuffix;
        value = "";
      } else {
        value = +value;

        // Perform the initial formatting.
        var valueNegative = value < 0;
        value = isNaN(value) ? nan : formatType(Math.abs(value), precision);

        // Trim insignificant zeros.
        if (trim) value = formatTrim(value);

        // If a negative value rounds to zero during formatting, treat as positive.
        if (valueNegative && +value === 0) valueNegative = false;

        // Compute the prefix and suffix.
        valuePrefix = (valueNegative ? (sign === "(" ? sign : minus) : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;

        valueSuffix = (type === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign === "(" ? ")" : "");

        // Break the formatted value into the integer “value” part that can be
        // grouped, and fractional or exponential “suffix” part that is not.
        if (maybeSuffix) {
          i = -1, n = value.length;
          while (++i < n) {
            if (c = value.charCodeAt(i), 48 > c || c > 57) {
              valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
              value = value.slice(0, i);
              break;
            }
          }
        }
      }

      // If the fill character is not "0", grouping is applied before padding.
      if (comma && !zero) value = group(value, Infinity);

      // Compute the padding.
      var length = valuePrefix.length + value.length + valueSuffix.length,
          padding = length < width ? new Array(width - length + 1).join(fill) : "";

      // If the fill character is "0", grouping is applied after padding.
      if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";

      // Reconstruct the final output based on the desired alignment.
      switch (align) {
        case "<": value = valuePrefix + value + valueSuffix + padding; break;
        case "=": value = valuePrefix + padding + value + valueSuffix; break;
        case "^": value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length); break;
        default: value = padding + valuePrefix + value + valueSuffix; break;
      }

      return numerals(value);
    }

    format.toString = function() {
      return specifier + "";
    };

    return format;
  }

  function formatPrefix(specifier, value) {
    var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)),
        e = Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3,
        k = Math.pow(10, -e),
        prefix = prefixes[8 + e / 3];
    return function(value) {
      return f(k * value) + prefix;
    };
  }

  return {
    format: newFormat,
    formatPrefix: formatPrefix
  };
}

var locale;
var format;
var formatPrefix;

defaultLocale({
  decimal: ".",
  thousands: ",",
  grouping: [3],
  currency: ["$", ""],
  minus: "-"
});

function defaultLocale(definition) {
  locale = formatLocale(definition);
  format = locale.format;
  formatPrefix = locale.formatPrefix;
  return locale;
}

function precisionFixed(step) {
  return Math.max(0, -exponent(Math.abs(step)));
}

function precisionPrefix(step, value) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3 - exponent(Math.abs(step)));
}

function precisionRound(step, max) {
  step = Math.abs(step), max = Math.abs(max) - step;
  return Math.max(0, exponent(max) - exponent(step)) + 1;
}

function tickFormat(start, stop, count, specifier) {
  var step = tickStep(start, stop, count),
      precision;
  specifier = formatSpecifier(specifier == null ? ",f" : specifier);
  switch (specifier.type) {
    case "s": {
      var value = Math.max(Math.abs(start), Math.abs(stop));
      if (specifier.precision == null && !isNaN(precision = precisionPrefix(step, value))) specifier.precision = precision;
      return formatPrefix(specifier, value);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      if (specifier.precision == null && !isNaN(precision = precisionRound(step, Math.max(Math.abs(start), Math.abs(stop))))) specifier.precision = precision - (specifier.type === "e");
      break;
    }
    case "f":
    case "%": {
      if (specifier.precision == null && !isNaN(precision = precisionFixed(step))) specifier.precision = precision - (specifier.type === "%") * 2;
      break;
    }
  }
  return format(specifier);
}

function linearish(scale) {
  var domain = scale.domain;

  scale.ticks = function(count) {
    var d = domain();
    return ticks(d[0], d[d.length - 1], count == null ? 10 : count);
  };

  scale.tickFormat = function(count, specifier) {
    var d = domain();
    return tickFormat(d[0], d[d.length - 1], count == null ? 10 : count, specifier);
  };

  scale.nice = function(count) {
    if (count == null) count = 10;

    var d = domain(),
        i0 = 0,
        i1 = d.length - 1,
        start = d[i0],
        stop = d[i1],
        step;

    if (stop < start) {
      step = start, start = stop, stop = step;
      step = i0, i0 = i1, i1 = step;
    }

    step = tickIncrement(start, stop, count);

    if (step > 0) {
      start = Math.floor(start / step) * step;
      stop = Math.ceil(stop / step) * step;
      step = tickIncrement(start, stop, count);
    } else if (step < 0) {
      start = Math.ceil(start * step) / step;
      stop = Math.floor(stop * step) / step;
      step = tickIncrement(start, stop, count);
    }

    if (step > 0) {
      d[i0] = Math.floor(start / step) * step;
      d[i1] = Math.ceil(stop / step) * step;
      domain(d);
    } else if (step < 0) {
      d[i0] = Math.ceil(start * step) / step;
      d[i1] = Math.floor(stop * step) / step;
      domain(d);
    }

    return scale;
  };

  return scale;
}

function linear$1() {
  var scale = continuous();

  scale.copy = function() {
    return copy(scale, linear$1());
  };

  initRange.apply(scale, arguments);

  return linearish(scale);
}

var t0$1 = new Date,
    t1$1 = new Date;

function newInterval(floori, offseti, count, field) {

  function interval(date) {
    return floori(date = arguments.length === 0 ? new Date : new Date(+date)), date;
  }

  interval.floor = function(date) {
    return floori(date = new Date(+date)), date;
  };

  interval.ceil = function(date) {
    return floori(date = new Date(date - 1)), offseti(date, 1), floori(date), date;
  };

  interval.round = function(date) {
    var d0 = interval(date),
        d1 = interval.ceil(date);
    return date - d0 < d1 - date ? d0 : d1;
  };

  interval.offset = function(date, step) {
    return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;
  };

  interval.range = function(start, stop, step) {
    var range = [], previous;
    start = interval.ceil(start);
    step = step == null ? 1 : Math.floor(step);
    if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date
    do range.push(previous = new Date(+start)), offseti(start, step), floori(start);
    while (previous < start && start < stop);
    return range;
  };

  interval.filter = function(test) {
    return newInterval(function(date) {
      if (date >= date) while (floori(date), !test(date)) date.setTime(date - 1);
    }, function(date, step) {
      if (date >= date) {
        if (step < 0) while (++step <= 0) {
          while (offseti(date, -1), !test(date)) {} // eslint-disable-line no-empty
        } else while (--step >= 0) {
          while (offseti(date, +1), !test(date)) {} // eslint-disable-line no-empty
        }
      }
    });
  };

  if (count) {
    interval.count = function(start, end) {
      t0$1.setTime(+start), t1$1.setTime(+end);
      floori(t0$1), floori(t1$1);
      return Math.floor(count(t0$1, t1$1));
    };

    interval.every = function(step) {
      step = Math.floor(step);
      return !isFinite(step) || !(step > 0) ? null
          : !(step > 1) ? interval
          : interval.filter(field
              ? function(d) { return field(d) % step === 0; }
              : function(d) { return interval.count(0, d) % step === 0; });
    };
  }

  return interval;
}

var millisecond = newInterval(function() {
  // noop
}, function(date, step) {
  date.setTime(+date + step);
}, function(start, end) {
  return end - start;
});

// An optimized implementation for this simple case.
millisecond.every = function(k) {
  k = Math.floor(k);
  if (!isFinite(k) || !(k > 0)) return null;
  if (!(k > 1)) return millisecond;
  return newInterval(function(date) {
    date.setTime(Math.floor(date / k) * k);
  }, function(date, step) {
    date.setTime(+date + step * k);
  }, function(start, end) {
    return (end - start) / k;
  });
};

var durationSecond = 1e3;
var durationMinute = 6e4;
var durationHour = 36e5;
var durationDay = 864e5;
var durationWeek = 6048e5;

var second = newInterval(function(date) {
  date.setTime(date - date.getMilliseconds());
}, function(date, step) {
  date.setTime(+date + step * durationSecond);
}, function(start, end) {
  return (end - start) / durationSecond;
}, function(date) {
  return date.getUTCSeconds();
});

var minute = newInterval(function(date) {
  date.setTime(date - date.getMilliseconds() - date.getSeconds() * durationSecond);
}, function(date, step) {
  date.setTime(+date + step * durationMinute);
}, function(start, end) {
  return (end - start) / durationMinute;
}, function(date) {
  return date.getMinutes();
});

var hour = newInterval(function(date) {
  date.setTime(date - date.getMilliseconds() - date.getSeconds() * durationSecond - date.getMinutes() * durationMinute);
}, function(date, step) {
  date.setTime(+date + step * durationHour);
}, function(start, end) {
  return (end - start) / durationHour;
}, function(date) {
  return date.getHours();
});

var day = newInterval(function(date) {
  date.setHours(0, 0, 0, 0);
}, function(date, step) {
  date.setDate(date.getDate() + step);
}, function(start, end) {
  return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationDay;
}, function(date) {
  return date.getDate() - 1;
});

function weekday(i) {
  return newInterval(function(date) {
    date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);
    date.setHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setDate(date.getDate() + step * 7);
  }, function(start, end) {
    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationWeek;
  });
}

var sunday = weekday(0);
var monday = weekday(1);
var tuesday = weekday(2);
var wednesday = weekday(3);
var thursday = weekday(4);
var friday = weekday(5);
var saturday = weekday(6);

var month = newInterval(function(date) {
  date.setDate(1);
  date.setHours(0, 0, 0, 0);
}, function(date, step) {
  date.setMonth(date.getMonth() + step);
}, function(start, end) {
  return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;
}, function(date) {
  return date.getMonth();
});

var year = newInterval(function(date) {
  date.setMonth(0, 1);
  date.setHours(0, 0, 0, 0);
}, function(date, step) {
  date.setFullYear(date.getFullYear() + step);
}, function(start, end) {
  return end.getFullYear() - start.getFullYear();
}, function(date) {
  return date.getFullYear();
});

// An optimized implementation for this simple case.
year.every = function(k) {
  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date) {
    date.setFullYear(Math.floor(date.getFullYear() / k) * k);
    date.setMonth(0, 1);
    date.setHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setFullYear(date.getFullYear() + step * k);
  });
};

var utcMinute = newInterval(function(date) {
  date.setUTCSeconds(0, 0);
}, function(date, step) {
  date.setTime(+date + step * durationMinute);
}, function(start, end) {
  return (end - start) / durationMinute;
}, function(date) {
  return date.getUTCMinutes();
});

var utcHour = newInterval(function(date) {
  date.setUTCMinutes(0, 0, 0);
}, function(date, step) {
  date.setTime(+date + step * durationHour);
}, function(start, end) {
  return (end - start) / durationHour;
}, function(date) {
  return date.getUTCHours();
});

var utcDay = newInterval(function(date) {
  date.setUTCHours(0, 0, 0, 0);
}, function(date, step) {
  date.setUTCDate(date.getUTCDate() + step);
}, function(start, end) {
  return (end - start) / durationDay;
}, function(date) {
  return date.getUTCDate() - 1;
});

function utcWeekday(i) {
  return newInterval(function(date) {
    date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);
    date.setUTCHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setUTCDate(date.getUTCDate() + step * 7);
  }, function(start, end) {
    return (end - start) / durationWeek;
  });
}

var utcSunday = utcWeekday(0);
var utcMonday = utcWeekday(1);
var utcTuesday = utcWeekday(2);
var utcWednesday = utcWeekday(3);
var utcThursday = utcWeekday(4);
var utcFriday = utcWeekday(5);
var utcSaturday = utcWeekday(6);

var utcMonth = newInterval(function(date) {
  date.setUTCDate(1);
  date.setUTCHours(0, 0, 0, 0);
}, function(date, step) {
  date.setUTCMonth(date.getUTCMonth() + step);
}, function(start, end) {
  return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;
}, function(date) {
  return date.getUTCMonth();
});

var utcYear = newInterval(function(date) {
  date.setUTCMonth(0, 1);
  date.setUTCHours(0, 0, 0, 0);
}, function(date, step) {
  date.setUTCFullYear(date.getUTCFullYear() + step);
}, function(start, end) {
  return end.getUTCFullYear() - start.getUTCFullYear();
}, function(date) {
  return date.getUTCFullYear();
});

// An optimized implementation for this simple case.
utcYear.every = function(k) {
  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date) {
    date.setUTCFullYear(Math.floor(date.getUTCFullYear() / k) * k);
    date.setUTCMonth(0, 1);
    date.setUTCHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setUTCFullYear(date.getUTCFullYear() + step * k);
  });
};

function localDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
    date.setFullYear(d.y);
    return date;
  }
  return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
}

function utcDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
    date.setUTCFullYear(d.y);
    return date;
  }
  return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
}

function newDate(y, m, d) {
  return {y: y, m: m, d: d, H: 0, M: 0, S: 0, L: 0};
}

function formatLocale$1(locale) {
  var locale_dateTime = locale.dateTime,
      locale_date = locale.date,
      locale_time = locale.time,
      locale_periods = locale.periods,
      locale_weekdays = locale.days,
      locale_shortWeekdays = locale.shortDays,
      locale_months = locale.months,
      locale_shortMonths = locale.shortMonths;

  var periodRe = formatRe(locale_periods),
      periodLookup = formatLookup(locale_periods),
      weekdayRe = formatRe(locale_weekdays),
      weekdayLookup = formatLookup(locale_weekdays),
      shortWeekdayRe = formatRe(locale_shortWeekdays),
      shortWeekdayLookup = formatLookup(locale_shortWeekdays),
      monthRe = formatRe(locale_months),
      monthLookup = formatLookup(locale_months),
      shortMonthRe = formatRe(locale_shortMonths),
      shortMonthLookup = formatLookup(locale_shortMonths);

  var formats = {
    "a": formatShortWeekday,
    "A": formatWeekday,
    "b": formatShortMonth,
    "B": formatMonth,
    "c": null,
    "d": formatDayOfMonth,
    "e": formatDayOfMonth,
    "f": formatMicroseconds,
    "H": formatHour24,
    "I": formatHour12,
    "j": formatDayOfYear,
    "L": formatMilliseconds,
    "m": formatMonthNumber,
    "M": formatMinutes,
    "p": formatPeriod,
    "q": formatQuarter,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatSeconds,
    "u": formatWeekdayNumberMonday,
    "U": formatWeekNumberSunday,
    "V": formatWeekNumberISO,
    "w": formatWeekdayNumberSunday,
    "W": formatWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatYear,
    "Y": formatFullYear,
    "Z": formatZone,
    "%": formatLiteralPercent
  };

  var utcFormats = {
    "a": formatUTCShortWeekday,
    "A": formatUTCWeekday,
    "b": formatUTCShortMonth,
    "B": formatUTCMonth,
    "c": null,
    "d": formatUTCDayOfMonth,
    "e": formatUTCDayOfMonth,
    "f": formatUTCMicroseconds,
    "H": formatUTCHour24,
    "I": formatUTCHour12,
    "j": formatUTCDayOfYear,
    "L": formatUTCMilliseconds,
    "m": formatUTCMonthNumber,
    "M": formatUTCMinutes,
    "p": formatUTCPeriod,
    "q": formatUTCQuarter,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatUTCSeconds,
    "u": formatUTCWeekdayNumberMonday,
    "U": formatUTCWeekNumberSunday,
    "V": formatUTCWeekNumberISO,
    "w": formatUTCWeekdayNumberSunday,
    "W": formatUTCWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatUTCYear,
    "Y": formatUTCFullYear,
    "Z": formatUTCZone,
    "%": formatLiteralPercent
  };

  var parses = {
    "a": parseShortWeekday,
    "A": parseWeekday,
    "b": parseShortMonth,
    "B": parseMonth,
    "c": parseLocaleDateTime,
    "d": parseDayOfMonth,
    "e": parseDayOfMonth,
    "f": parseMicroseconds,
    "H": parseHour24,
    "I": parseHour24,
    "j": parseDayOfYear,
    "L": parseMilliseconds,
    "m": parseMonthNumber,
    "M": parseMinutes,
    "p": parsePeriod,
    "q": parseQuarter,
    "Q": parseUnixTimestamp,
    "s": parseUnixTimestampSeconds,
    "S": parseSeconds,
    "u": parseWeekdayNumberMonday,
    "U": parseWeekNumberSunday,
    "V": parseWeekNumberISO,
    "w": parseWeekdayNumberSunday,
    "W": parseWeekNumberMonday,
    "x": parseLocaleDate,
    "X": parseLocaleTime,
    "y": parseYear,
    "Y": parseFullYear,
    "Z": parseZone,
    "%": parseLiteralPercent
  };

  // These recursive directive definitions must be deferred.
  formats.x = newFormat(locale_date, formats);
  formats.X = newFormat(locale_time, formats);
  formats.c = newFormat(locale_dateTime, formats);
  utcFormats.x = newFormat(locale_date, utcFormats);
  utcFormats.X = newFormat(locale_time, utcFormats);
  utcFormats.c = newFormat(locale_dateTime, utcFormats);

  function newFormat(specifier, formats) {
    return function(date) {
      var string = [],
          i = -1,
          j = 0,
          n = specifier.length,
          c,
          pad,
          format;

      if (!(date instanceof Date)) date = new Date(+date);

      while (++i < n) {
        if (specifier.charCodeAt(i) === 37) {
          string.push(specifier.slice(j, i));
          if ((pad = pads[c = specifier.charAt(++i)]) != null) c = specifier.charAt(++i);
          else pad = c === "e" ? " " : "0";
          if (format = formats[c]) c = format(date, pad);
          string.push(c);
          j = i + 1;
        }
      }

      string.push(specifier.slice(j, i));
      return string.join("");
    };
  }

  function newParse(specifier, Z) {
    return function(string) {
      var d = newDate(1900, undefined, 1),
          i = parseSpecifier(d, specifier, string += "", 0),
          week, day$1;
      if (i != string.length) return null;

      // If a UNIX timestamp is specified, return it.
      if ("Q" in d) return new Date(d.Q);
      if ("s" in d) return new Date(d.s * 1000 + ("L" in d ? d.L : 0));

      // If this is utcParse, never use the local timezone.
      if (Z && !("Z" in d)) d.Z = 0;

      // The am-pm flag is 0 for AM, and 1 for PM.
      if ("p" in d) d.H = d.H % 12 + d.p * 12;

      // If the month was not specified, inherit from the quarter.
      if (d.m === undefined) d.m = "q" in d ? d.q : 0;

      // Convert day-of-week and week-of-year to day-of-year.
      if ("V" in d) {
        if (d.V < 1 || d.V > 53) return null;
        if (!("w" in d)) d.w = 1;
        if ("Z" in d) {
          week = utcDate(newDate(d.y, 0, 1)), day$1 = week.getUTCDay();
          week = day$1 > 4 || day$1 === 0 ? utcMonday.ceil(week) : utcMonday(week);
          week = utcDay.offset(week, (d.V - 1) * 7);
          d.y = week.getUTCFullYear();
          d.m = week.getUTCMonth();
          d.d = week.getUTCDate() + (d.w + 6) % 7;
        } else {
          week = localDate(newDate(d.y, 0, 1)), day$1 = week.getDay();
          week = day$1 > 4 || day$1 === 0 ? monday.ceil(week) : monday(week);
          week = day.offset(week, (d.V - 1) * 7);
          d.y = week.getFullYear();
          d.m = week.getMonth();
          d.d = week.getDate() + (d.w + 6) % 7;
        }
      } else if ("W" in d || "U" in d) {
        if (!("w" in d)) d.w = "u" in d ? d.u % 7 : "W" in d ? 1 : 0;
        day$1 = "Z" in d ? utcDate(newDate(d.y, 0, 1)).getUTCDay() : localDate(newDate(d.y, 0, 1)).getDay();
        d.m = 0;
        d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day$1 + 5) % 7 : d.w + d.U * 7 - (day$1 + 6) % 7;
      }

      // If a time zone is specified, all fields are interpreted as UTC and then
      // offset according to the specified time zone.
      if ("Z" in d) {
        d.H += d.Z / 100 | 0;
        d.M += d.Z % 100;
        return utcDate(d);
      }

      // Otherwise, all fields are in local time.
      return localDate(d);
    };
  }

  function parseSpecifier(d, specifier, string, j) {
    var i = 0,
        n = specifier.length,
        m = string.length,
        c,
        parse;

    while (i < n) {
      if (j >= m) return -1;
      c = specifier.charCodeAt(i++);
      if (c === 37) {
        c = specifier.charAt(i++);
        parse = parses[c in pads ? specifier.charAt(i++) : c];
        if (!parse || ((j = parse(d, string, j)) < 0)) return -1;
      } else if (c != string.charCodeAt(j++)) {
        return -1;
      }
    }

    return j;
  }

  function parsePeriod(d, string, i) {
    var n = periodRe.exec(string.slice(i));
    return n ? (d.p = periodLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseShortWeekday(d, string, i) {
    var n = shortWeekdayRe.exec(string.slice(i));
    return n ? (d.w = shortWeekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseWeekday(d, string, i) {
    var n = weekdayRe.exec(string.slice(i));
    return n ? (d.w = weekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseShortMonth(d, string, i) {
    var n = shortMonthRe.exec(string.slice(i));
    return n ? (d.m = shortMonthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseMonth(d, string, i) {
    var n = monthRe.exec(string.slice(i));
    return n ? (d.m = monthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseLocaleDateTime(d, string, i) {
    return parseSpecifier(d, locale_dateTime, string, i);
  }

  function parseLocaleDate(d, string, i) {
    return parseSpecifier(d, locale_date, string, i);
  }

  function parseLocaleTime(d, string, i) {
    return parseSpecifier(d, locale_time, string, i);
  }

  function formatShortWeekday(d) {
    return locale_shortWeekdays[d.getDay()];
  }

  function formatWeekday(d) {
    return locale_weekdays[d.getDay()];
  }

  function formatShortMonth(d) {
    return locale_shortMonths[d.getMonth()];
  }

  function formatMonth(d) {
    return locale_months[d.getMonth()];
  }

  function formatPeriod(d) {
    return locale_periods[+(d.getHours() >= 12)];
  }

  function formatQuarter(d) {
    return 1 + ~~(d.getMonth() / 3);
  }

  function formatUTCShortWeekday(d) {
    return locale_shortWeekdays[d.getUTCDay()];
  }

  function formatUTCWeekday(d) {
    return locale_weekdays[d.getUTCDay()];
  }

  function formatUTCShortMonth(d) {
    return locale_shortMonths[d.getUTCMonth()];
  }

  function formatUTCMonth(d) {
    return locale_months[d.getUTCMonth()];
  }

  function formatUTCPeriod(d) {
    return locale_periods[+(d.getUTCHours() >= 12)];
  }

  function formatUTCQuarter(d) {
    return 1 + ~~(d.getUTCMonth() / 3);
  }

  return {
    format: function(specifier) {
      var f = newFormat(specifier += "", formats);
      f.toString = function() { return specifier; };
      return f;
    },
    parse: function(specifier) {
      var p = newParse(specifier += "", false);
      p.toString = function() { return specifier; };
      return p;
    },
    utcFormat: function(specifier) {
      var f = newFormat(specifier += "", utcFormats);
      f.toString = function() { return specifier; };
      return f;
    },
    utcParse: function(specifier) {
      var p = newParse(specifier += "", true);
      p.toString = function() { return specifier; };
      return p;
    }
  };
}

var pads = {"-": "", "_": " ", "0": "0"},
    numberRe = /^\s*\d+/, // note: ignores next directive
    percentRe = /^%/,
    requoteRe = /[\\^$*+?|[\]().{}]/g;

function pad(value, fill, width) {
  var sign = value < 0 ? "-" : "",
      string = (sign ? -value : value) + "",
      length = string.length;
  return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
}

function requote(s) {
  return s.replace(requoteRe, "\\$&");
}

function formatRe(names) {
  return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
}

function formatLookup(names) {
  var map = {}, i = -1, n = names.length;
  while (++i < n) map[names[i].toLowerCase()] = i;
  return map;
}

function parseWeekdayNumberSunday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.w = +n[0], i + n[0].length) : -1;
}

function parseWeekdayNumberMonday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.u = +n[0], i + n[0].length) : -1;
}

function parseWeekNumberSunday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.U = +n[0], i + n[0].length) : -1;
}

function parseWeekNumberISO(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.V = +n[0], i + n[0].length) : -1;
}

function parseWeekNumberMonday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.W = +n[0], i + n[0].length) : -1;
}

function parseFullYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 4));
  return n ? (d.y = +n[0], i + n[0].length) : -1;
}

function parseYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2000), i + n[0].length) : -1;
}

function parseZone(d, string, i) {
  var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string.slice(i, i + 6));
  return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
}

function parseQuarter(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.q = n[0] * 3 - 3, i + n[0].length) : -1;
}

function parseMonthNumber(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
}

function parseDayOfMonth(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.d = +n[0], i + n[0].length) : -1;
}

function parseDayOfYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 3));
  return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
}

function parseHour24(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.H = +n[0], i + n[0].length) : -1;
}

function parseMinutes(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.M = +n[0], i + n[0].length) : -1;
}

function parseSeconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.S = +n[0], i + n[0].length) : -1;
}

function parseMilliseconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 3));
  return n ? (d.L = +n[0], i + n[0].length) : -1;
}

function parseMicroseconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 6));
  return n ? (d.L = Math.floor(n[0] / 1000), i + n[0].length) : -1;
}

function parseLiteralPercent(d, string, i) {
  var n = percentRe.exec(string.slice(i, i + 1));
  return n ? i + n[0].length : -1;
}

function parseUnixTimestamp(d, string, i) {
  var n = numberRe.exec(string.slice(i));
  return n ? (d.Q = +n[0], i + n[0].length) : -1;
}

function parseUnixTimestampSeconds(d, string, i) {
  var n = numberRe.exec(string.slice(i));
  return n ? (d.s = +n[0], i + n[0].length) : -1;
}

function formatDayOfMonth(d, p) {
  return pad(d.getDate(), p, 2);
}

function formatHour24(d, p) {
  return pad(d.getHours(), p, 2);
}

function formatHour12(d, p) {
  return pad(d.getHours() % 12 || 12, p, 2);
}

function formatDayOfYear(d, p) {
  return pad(1 + day.count(year(d), d), p, 3);
}

function formatMilliseconds(d, p) {
  return pad(d.getMilliseconds(), p, 3);
}

function formatMicroseconds(d, p) {
  return formatMilliseconds(d, p) + "000";
}

function formatMonthNumber(d, p) {
  return pad(d.getMonth() + 1, p, 2);
}

function formatMinutes(d, p) {
  return pad(d.getMinutes(), p, 2);
}

function formatSeconds(d, p) {
  return pad(d.getSeconds(), p, 2);
}

function formatWeekdayNumberMonday(d) {
  var day = d.getDay();
  return day === 0 ? 7 : day;
}

function formatWeekNumberSunday(d, p) {
  return pad(sunday.count(year(d) - 1, d), p, 2);
}

function formatWeekNumberISO(d, p) {
  var day = d.getDay();
  d = (day >= 4 || day === 0) ? thursday(d) : thursday.ceil(d);
  return pad(thursday.count(year(d), d) + (year(d).getDay() === 4), p, 2);
}

function formatWeekdayNumberSunday(d) {
  return d.getDay();
}

function formatWeekNumberMonday(d, p) {
  return pad(monday.count(year(d) - 1, d), p, 2);
}

function formatYear(d, p) {
  return pad(d.getFullYear() % 100, p, 2);
}

function formatFullYear(d, p) {
  return pad(d.getFullYear() % 10000, p, 4);
}

function formatZone(d) {
  var z = d.getTimezoneOffset();
  return (z > 0 ? "-" : (z *= -1, "+"))
      + pad(z / 60 | 0, "0", 2)
      + pad(z % 60, "0", 2);
}

function formatUTCDayOfMonth(d, p) {
  return pad(d.getUTCDate(), p, 2);
}

function formatUTCHour24(d, p) {
  return pad(d.getUTCHours(), p, 2);
}

function formatUTCHour12(d, p) {
  return pad(d.getUTCHours() % 12 || 12, p, 2);
}

function formatUTCDayOfYear(d, p) {
  return pad(1 + utcDay.count(utcYear(d), d), p, 3);
}

function formatUTCMilliseconds(d, p) {
  return pad(d.getUTCMilliseconds(), p, 3);
}

function formatUTCMicroseconds(d, p) {
  return formatUTCMilliseconds(d, p) + "000";
}

function formatUTCMonthNumber(d, p) {
  return pad(d.getUTCMonth() + 1, p, 2);
}

function formatUTCMinutes(d, p) {
  return pad(d.getUTCMinutes(), p, 2);
}

function formatUTCSeconds(d, p) {
  return pad(d.getUTCSeconds(), p, 2);
}

function formatUTCWeekdayNumberMonday(d) {
  var dow = d.getUTCDay();
  return dow === 0 ? 7 : dow;
}

function formatUTCWeekNumberSunday(d, p) {
  return pad(utcSunday.count(utcYear(d) - 1, d), p, 2);
}

function formatUTCWeekNumberISO(d, p) {
  var day = d.getUTCDay();
  d = (day >= 4 || day === 0) ? utcThursday(d) : utcThursday.ceil(d);
  return pad(utcThursday.count(utcYear(d), d) + (utcYear(d).getUTCDay() === 4), p, 2);
}

function formatUTCWeekdayNumberSunday(d) {
  return d.getUTCDay();
}

function formatUTCWeekNumberMonday(d, p) {
  return pad(utcMonday.count(utcYear(d) - 1, d), p, 2);
}

function formatUTCYear(d, p) {
  return pad(d.getUTCFullYear() % 100, p, 2);
}

function formatUTCFullYear(d, p) {
  return pad(d.getUTCFullYear() % 10000, p, 4);
}

function formatUTCZone() {
  return "+0000";
}

function formatLiteralPercent() {
  return "%";
}

function formatUnixTimestamp(d) {
  return +d;
}

function formatUnixTimestampSeconds(d) {
  return Math.floor(+d / 1000);
}

var locale$1;
var timeFormat;
var timeParse;
var utcFormat;
var utcParse;

defaultLocale$1({
  dateTime: "%x, %X",
  date: "%-m/%-d/%Y",
  time: "%-I:%M:%S %p",
  periods: ["AM", "PM"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
});

function defaultLocale$1(definition) {
  locale$1 = formatLocale$1(definition);
  timeFormat = locale$1.format;
  timeParse = locale$1.parse;
  utcFormat = locale$1.utcFormat;
  utcParse = locale$1.utcParse;
  return locale$1;
}

const BaseProps = {
  // routine
  width: propTypes.number,
  height: propTypes.number,
  name: propTypes.string,
  className: propTypes.string,
  frameKey: propTypes.string,
  renderKey: propTypes.string,
  renderMode: propTypes.oneOfType([propTypes.string, propTypes.object]),
  title: propTypes.oneOfType([propTypes.string, propTypes.object]),
  useSpans: propTypes.bool,
  additionalDefs: propTypes.array,
  margin: propTypes.oneOfType([propTypes.number, propTypes.object]),
  matte: propTypes.oneOfType([propTypes.bool, propTypes.node, propTypes.func, propTypes.object]),
  // render as it is
  beforeElements: propTypes.object,
  afterElements: propTypes.object,
  backgroundGraphics: propTypes.oneOfType([propTypes.node, propTypes.object]),
  foregroundGraphics: propTypes.oneOfType([propTypes.node, propTypes.object]),
  canvasPostProcess: propTypes.string,
  baseMarkProps: propTypes.object,
  // interaction
  hoverAnnotation: propTypes.oneOfType([propTypes.func, propTypes.array, propTypes.bool]),
  interaction: propTypes.func,
  customClickBehavior: propTypes.func,
  customHoverBehavior: propTypes.func,
  customDoubleClickBehavior: propTypes.func,
  overlay: propTypes.array,
  interactionOverflow: propTypes.func,
  tooltipContent: propTypes.oneOfType([propTypes.node, propTypes.object, propTypes.func]),
  disableCanvasInteraction: propTypes.bool
};
const BaseDefaultProps = {
  width: 800,
  height: 600,
  name: '',
  className: '',
  margin: {
    top: 0,
    bottom: 0,
    left: 0,
    right: 0
  },
  title: {
    title: '',
    orient: 'top'
  },
  useSpans: false,
  beforeElements: null,
  afterElements: null,
  backgroundGraphics: null,
  foregroundGraphics: null,
  additionalDefs: null,
  canvasPostProcess: 'chunkClose',
  frameXScale: linear$1(),
  frameYScale: linear$1()
};

const Annotation = props => {
  return null;
};

Annotation.propTypes = {
  x: propTypes.number,
  y: propTypes.number,
  coordinates: propTypes.oneOfType([propTypes.object, propTypes.array]),
  note: propTypes.oneOfType([propTypes.object, propTypes.string]),
  subject: propTypes.object
};

var pi = Math.PI,
    tau = 2 * pi,
    epsilon = 1e-6,
    tauEpsilon = tau - epsilon;

function Path() {
  this._x0 = this._y0 = // start of current subpath
  this._x1 = this._y1 = null; // end of current subpath
  this._ = "";
}

function path() {
  return new Path;
}

Path.prototype = path.prototype = {
  constructor: Path,
  moveTo: function(x, y) {
    this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y);
  },
  closePath: function() {
    if (this._x1 !== null) {
      this._x1 = this._x0, this._y1 = this._y0;
      this._ += "Z";
    }
  },
  lineTo: function(x, y) {
    this._ += "L" + (this._x1 = +x) + "," + (this._y1 = +y);
  },
  quadraticCurveTo: function(x1, y1, x, y) {
    this._ += "Q" + (+x1) + "," + (+y1) + "," + (this._x1 = +x) + "," + (this._y1 = +y);
  },
  bezierCurveTo: function(x1, y1, x2, y2, x, y) {
    this._ += "C" + (+x1) + "," + (+y1) + "," + (+x2) + "," + (+y2) + "," + (this._x1 = +x) + "," + (this._y1 = +y);
  },
  arcTo: function(x1, y1, x2, y2, r) {
    x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;
    var x0 = this._x1,
        y0 = this._y1,
        x21 = x2 - x1,
        y21 = y2 - y1,
        x01 = x0 - x1,
        y01 = y0 - y1,
        l01_2 = x01 * x01 + y01 * y01;

    // Is the radius negative? Error.
    if (r < 0) throw new Error("negative radius: " + r);

    // Is this path empty? Move to (x1,y1).
    if (this._x1 === null) {
      this._ += "M" + (this._x1 = x1) + "," + (this._y1 = y1);
    }

    // Or, is (x1,y1) coincident with (x0,y0)? Do nothing.
    else if (!(l01_2 > epsilon));

    // Or, are (x0,y0), (x1,y1) and (x2,y2) collinear?
    // Equivalently, is (x1,y1) coincident with (x2,y2)?
    // Or, is the radius zero? Line to (x1,y1).
    else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon) || !r) {
      this._ += "L" + (this._x1 = x1) + "," + (this._y1 = y1);
    }

    // Otherwise, draw an arc!
    else {
      var x20 = x2 - x0,
          y20 = y2 - y0,
          l21_2 = x21 * x21 + y21 * y21,
          l20_2 = x20 * x20 + y20 * y20,
          l21 = Math.sqrt(l21_2),
          l01 = Math.sqrt(l01_2),
          l = r * Math.tan((pi - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2),
          t01 = l / l01,
          t21 = l / l21;

      // If the start tangent is not coincident with (x0,y0), line to.
      if (Math.abs(t01 - 1) > epsilon) {
        this._ += "L" + (x1 + t01 * x01) + "," + (y1 + t01 * y01);
      }

      this._ += "A" + r + "," + r + ",0,0," + (+(y01 * x20 > x01 * y20)) + "," + (this._x1 = x1 + t21 * x21) + "," + (this._y1 = y1 + t21 * y21);
    }
  },
  arc: function(x, y, r, a0, a1, ccw) {
    x = +x, y = +y, r = +r, ccw = !!ccw;
    var dx = r * Math.cos(a0),
        dy = r * Math.sin(a0),
        x0 = x + dx,
        y0 = y + dy,
        cw = 1 ^ ccw,
        da = ccw ? a0 - a1 : a1 - a0;

    // Is the radius negative? Error.
    if (r < 0) throw new Error("negative radius: " + r);

    // Is this path empty? Move to (x0,y0).
    if (this._x1 === null) {
      this._ += "M" + x0 + "," + y0;
    }

    // Or, is (x0,y0) not coincident with the previous point? Line to (x0,y0).
    else if (Math.abs(this._x1 - x0) > epsilon || Math.abs(this._y1 - y0) > epsilon) {
      this._ += "L" + x0 + "," + y0;
    }

    // Is this arc empty? We’re done.
    if (!r) return;

    // Does the angle go the wrong way? Flip the direction.
    if (da < 0) da = da % tau + tau;

    // Is this a complete circle? Draw two arcs to complete the circle.
    if (da > tauEpsilon) {
      this._ += "A" + r + "," + r + ",0,1," + cw + "," + (x - dx) + "," + (y - dy) + "A" + r + "," + r + ",0,1," + cw + "," + (this._x1 = x0) + "," + (this._y1 = y0);
    }

    // Is this arc non-empty? Draw an arc!
    else if (da > epsilon) {
      this._ += "A" + r + "," + r + ",0," + (+(da >= pi)) + "," + cw + "," + (this._x1 = x + r * Math.cos(a1)) + "," + (this._y1 = y + r * Math.sin(a1));
    }
  },
  rect: function(x, y, w, h) {
    this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y) + "h" + (+w) + "v" + (+h) + "h" + (-w) + "Z";
  },
  toString: function() {
    return this._;
  }
};

function constant$3(x) {
  return function constant() {
    return x;
  };
}

var abs = Math.abs;
var atan2 = Math.atan2;
var cos = Math.cos;
var max$1 = Math.max;
var min$1 = Math.min;
var sin = Math.sin;
var sqrt = Math.sqrt;

var epsilon$1 = 1e-12;
var pi$1 = Math.PI;
var halfPi = pi$1 / 2;
var tau$1 = 2 * pi$1;

function acos(x) {
  return x > 1 ? 0 : x < -1 ? pi$1 : Math.acos(x);
}

function asin(x) {
  return x >= 1 ? halfPi : x <= -1 ? -halfPi : Math.asin(x);
}

function arcInnerRadius(d) {
  return d.innerRadius;
}

function arcOuterRadius(d) {
  return d.outerRadius;
}

function arcStartAngle(d) {
  return d.startAngle;
}

function arcEndAngle(d) {
  return d.endAngle;
}

function arcPadAngle(d) {
  return d && d.padAngle; // Note: optional!
}

function intersect(x0, y0, x1, y1, x2, y2, x3, y3) {
  var x10 = x1 - x0, y10 = y1 - y0,
      x32 = x3 - x2, y32 = y3 - y2,
      t = (x32 * (y0 - y2) - y32 * (x0 - x2)) / (y32 * x10 - x32 * y10);
  return [x0 + t * x10, y0 + t * y10];
}

// Compute perpendicular offset line of length rc.
// http://mathworld.wolfram.com/Circle-LineIntersection.html
function cornerTangents(x0, y0, x1, y1, r1, rc, cw) {
  var x01 = x0 - x1,
      y01 = y0 - y1,
      lo = (cw ? rc : -rc) / sqrt(x01 * x01 + y01 * y01),
      ox = lo * y01,
      oy = -lo * x01,
      x11 = x0 + ox,
      y11 = y0 + oy,
      x10 = x1 + ox,
      y10 = y1 + oy,
      x00 = (x11 + x10) / 2,
      y00 = (y11 + y10) / 2,
      dx = x10 - x11,
      dy = y10 - y11,
      d2 = dx * dx + dy * dy,
      r = r1 - rc,
      D = x11 * y10 - x10 * y11,
      d = (dy < 0 ? -1 : 1) * sqrt(max$1(0, r * r * d2 - D * D)),
      cx0 = (D * dy - dx * d) / d2,
      cy0 = (-D * dx - dy * d) / d2,
      cx1 = (D * dy + dx * d) / d2,
      cy1 = (-D * dx + dy * d) / d2,
      dx0 = cx0 - x00,
      dy0 = cy0 - y00,
      dx1 = cx1 - x00,
      dy1 = cy1 - y00;

  // Pick the closer of the two intersection points.
  // TODO Is there a faster way to determine which intersection to use?
  if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;

  return {
    cx: cx0,
    cy: cy0,
    x01: -ox,
    y01: -oy,
    x11: cx0 * (r1 / r - 1),
    y11: cy0 * (r1 / r - 1)
  };
}

function arc$1() {
  var innerRadius = arcInnerRadius,
      outerRadius = arcOuterRadius,
      cornerRadius = constant$3(0),
      padRadius = null,
      startAngle = arcStartAngle,
      endAngle = arcEndAngle,
      padAngle = arcPadAngle,
      context = null;

  function arc() {
    var buffer,
        r,
        r0 = +innerRadius.apply(this, arguments),
        r1 = +outerRadius.apply(this, arguments),
        a0 = startAngle.apply(this, arguments) - halfPi,
        a1 = endAngle.apply(this, arguments) - halfPi,
        da = abs(a1 - a0),
        cw = a1 > a0;

    if (!context) context = buffer = path();

    // Ensure that the outer radius is always larger than the inner radius.
    if (r1 < r0) r = r1, r1 = r0, r0 = r;

    // Is it a point?
    if (!(r1 > epsilon$1)) context.moveTo(0, 0);

    // Or is it a circle or annulus?
    else if (da > tau$1 - epsilon$1) {
      context.moveTo(r1 * cos(a0), r1 * sin(a0));
      context.arc(0, 0, r1, a0, a1, !cw);
      if (r0 > epsilon$1) {
        context.moveTo(r0 * cos(a1), r0 * sin(a1));
        context.arc(0, 0, r0, a1, a0, cw);
      }
    }

    // Or is it a circular or annular sector?
    else {
      var a01 = a0,
          a11 = a1,
          a00 = a0,
          a10 = a1,
          da0 = da,
          da1 = da,
          ap = padAngle.apply(this, arguments) / 2,
          rp = (ap > epsilon$1) && (padRadius ? +padRadius.apply(this, arguments) : sqrt(r0 * r0 + r1 * r1)),
          rc = min$1(abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments)),
          rc0 = rc,
          rc1 = rc,
          t0,
          t1;

      // Apply padding? Note that since r1 ≥ r0, da1 ≥ da0.
      if (rp > epsilon$1) {
        var p0 = asin(rp / r0 * sin(ap)),
            p1 = asin(rp / r1 * sin(ap));
        if ((da0 -= p0 * 2) > epsilon$1) p0 *= (cw ? 1 : -1), a00 += p0, a10 -= p0;
        else da0 = 0, a00 = a10 = (a0 + a1) / 2;
        if ((da1 -= p1 * 2) > epsilon$1) p1 *= (cw ? 1 : -1), a01 += p1, a11 -= p1;
        else da1 = 0, a01 = a11 = (a0 + a1) / 2;
      }

      var x01 = r1 * cos(a01),
          y01 = r1 * sin(a01),
          x10 = r0 * cos(a10),
          y10 = r0 * sin(a10);

      // Apply rounded corners?
      if (rc > epsilon$1) {
        var x11 = r1 * cos(a11),
            y11 = r1 * sin(a11),
            x00 = r0 * cos(a00),
            y00 = r0 * sin(a00);

        // Restrict the corner radius according to the sector angle.
        if (da < pi$1) {
          var oc = da0 > epsilon$1 ? intersect(x01, y01, x00, y00, x11, y11, x10, y10) : [x10, y10],
              ax = x01 - oc[0],
              ay = y01 - oc[1],
              bx = x11 - oc[0],
              by = y11 - oc[1],
              kc = 1 / sin(acos((ax * bx + ay * by) / (sqrt(ax * ax + ay * ay) * sqrt(bx * bx + by * by))) / 2),
              lc = sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
          rc0 = min$1(rc, (r0 - lc) / (kc - 1));
          rc1 = min$1(rc, (r1 - lc) / (kc + 1));
        }
      }

      // Is the sector collapsed to a line?
      if (!(da1 > epsilon$1)) context.moveTo(x01, y01);

      // Does the sector’s outer ring have rounded corners?
      else if (rc1 > epsilon$1) {
        t0 = cornerTangents(x00, y00, x01, y01, r1, rc1, cw);
        t1 = cornerTangents(x11, y11, x10, y10, r1, rc1, cw);

        context.moveTo(t0.cx + t0.x01, t0.cy + t0.y01);

        // Have the corners merged?
        if (rc1 < rc) context.arc(t0.cx, t0.cy, rc1, atan2(t0.y01, t0.x01), atan2(t1.y01, t1.x01), !cw);

        // Otherwise, draw the two corners and the ring.
        else {
          context.arc(t0.cx, t0.cy, rc1, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !cw);
          context.arc(0, 0, r1, atan2(t0.cy + t0.y11, t0.cx + t0.x11), atan2(t1.cy + t1.y11, t1.cx + t1.x11), !cw);
          context.arc(t1.cx, t1.cy, rc1, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !cw);
        }
      }

      // Or is the outer ring just a circular arc?
      else context.moveTo(x01, y01), context.arc(0, 0, r1, a01, a11, !cw);

      // Is there no inner ring, and it’s a circular sector?
      // Or perhaps it’s an annular sector collapsed due to padding?
      if (!(r0 > epsilon$1) || !(da0 > epsilon$1)) context.lineTo(x10, y10);

      // Does the sector’s inner ring (or point) have rounded corners?
      else if (rc0 > epsilon$1) {
        t0 = cornerTangents(x10, y10, x11, y11, r0, -rc0, cw);
        t1 = cornerTangents(x01, y01, x00, y00, r0, -rc0, cw);

        context.lineTo(t0.cx + t0.x01, t0.cy + t0.y01);

        // Have the corners merged?
        if (rc0 < rc) context.arc(t0.cx, t0.cy, rc0, atan2(t0.y01, t0.x01), atan2(t1.y01, t1.x01), !cw);

        // Otherwise, draw the two corners and the ring.
        else {
          context.arc(t0.cx, t0.cy, rc0, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !cw);
          context.arc(0, 0, r0, atan2(t0.cy + t0.y11, t0.cx + t0.x11), atan2(t1.cy + t1.y11, t1.cx + t1.x11), cw);
          context.arc(t1.cx, t1.cy, rc0, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !cw);
        }
      }

      // Or is the inner ring just a circular arc?
      else context.arc(0, 0, r0, a10, a00, cw);
    }

    context.closePath();

    if (buffer) return context = null, buffer + "" || null;
  }

  arc.centroid = function() {
    var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2,
        a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - pi$1 / 2;
    return [cos(a) * r, sin(a) * r];
  };

  arc.innerRadius = function(_) {
    return arguments.length ? (innerRadius = typeof _ === "function" ? _ : constant$3(+_), arc) : innerRadius;
  };

  arc.outerRadius = function(_) {
    return arguments.length ? (outerRadius = typeof _ === "function" ? _ : constant$3(+_), arc) : outerRadius;
  };

  arc.cornerRadius = function(_) {
    return arguments.length ? (cornerRadius = typeof _ === "function" ? _ : constant$3(+_), arc) : cornerRadius;
  };

  arc.padRadius = function(_) {
    return arguments.length ? (padRadius = _ == null ? null : typeof _ === "function" ? _ : constant$3(+_), arc) : padRadius;
  };

  arc.startAngle = function(_) {
    return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant$3(+_), arc) : startAngle;
  };

  arc.endAngle = function(_) {
    return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant$3(+_), arc) : endAngle;
  };

  arc.padAngle = function(_) {
    return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant$3(+_), arc) : padAngle;
  };

  arc.context = function(_) {
    return arguments.length ? ((context = _ == null ? null : _), arc) : context;
  };

  return arc;
}

function Linear(context) {
  this._context = context;
}

Linear.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; // proceed
      default: this._context.lineTo(x, y); break;
    }
  }
};

function curveLinear(context) {
  return new Linear(context);
}

function x(p) {
  return p[0];
}

function y(p) {
  return p[1];
}

function line() {
  var x$1 = x,
      y$1 = y,
      defined = constant$3(true),
      context = null,
      curve = curveLinear,
      output = null;

  function line(data) {
    var i,
        n = data.length,
        d,
        defined0 = false,
        buffer;

    if (context == null) output = curve(buffer = path());

    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined(d = data[i], i, data)) === defined0) {
        if (defined0 = !defined0) output.lineStart();
        else output.lineEnd();
      }
      if (defined0) output.point(+x$1(d, i, data), +y$1(d, i, data));
    }

    if (buffer) return output = null, buffer + "" || null;
  }

  line.x = function(_) {
    return arguments.length ? (x$1 = typeof _ === "function" ? _ : constant$3(+_), line) : x$1;
  };

  line.y = function(_) {
    return arguments.length ? (y$1 = typeof _ === "function" ? _ : constant$3(+_), line) : y$1;
  };

  line.defined = function(_) {
    return arguments.length ? (defined = typeof _ === "function" ? _ : constant$3(!!_), line) : defined;
  };

  line.curve = function(_) {
    return arguments.length ? (curve = _, context != null && (output = curve(context)), line) : curve;
  };

  line.context = function(_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), line) : context;
  };

  return line;
}

function area() {
  var x0 = x,
      x1 = null,
      y0 = constant$3(0),
      y1 = y,
      defined = constant$3(true),
      context = null,
      curve = curveLinear,
      output = null;

  function area(data) {
    var i,
        j,
        k,
        n = data.length,
        d,
        defined0 = false,
        buffer,
        x0z = new Array(n),
        y0z = new Array(n);

    if (context == null) output = curve(buffer = path());

    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined(d = data[i], i, data)) === defined0) {
        if (defined0 = !defined0) {
          j = i;
          output.areaStart();
          output.lineStart();
        } else {
          output.lineEnd();
          output.lineStart();
          for (k = i - 1; k >= j; --k) {
            output.point(x0z[k], y0z[k]);
          }
          output.lineEnd();
          output.areaEnd();
        }
      }
      if (defined0) {
        x0z[i] = +x0(d, i, data), y0z[i] = +y0(d, i, data);
        output.point(x1 ? +x1(d, i, data) : x0z[i], y1 ? +y1(d, i, data) : y0z[i]);
      }
    }

    if (buffer) return output = null, buffer + "" || null;
  }

  function arealine() {
    return line().defined(defined).curve(curve).context(context);
  }

  area.x = function(_) {
    return arguments.length ? (x0 = typeof _ === "function" ? _ : constant$3(+_), x1 = null, area) : x0;
  };

  area.x0 = function(_) {
    return arguments.length ? (x0 = typeof _ === "function" ? _ : constant$3(+_), area) : x0;
  };

  area.x1 = function(_) {
    return arguments.length ? (x1 = _ == null ? null : typeof _ === "function" ? _ : constant$3(+_), area) : x1;
  };

  area.y = function(_) {
    return arguments.length ? (y0 = typeof _ === "function" ? _ : constant$3(+_), y1 = null, area) : y0;
  };

  area.y0 = function(_) {
    return arguments.length ? (y0 = typeof _ === "function" ? _ : constant$3(+_), area) : y0;
  };

  area.y1 = function(_) {
    return arguments.length ? (y1 = _ == null ? null : typeof _ === "function" ? _ : constant$3(+_), area) : y1;
  };

  area.lineX0 =
  area.lineY0 = function() {
    return arealine().x(x0).y(y0);
  };

  area.lineY1 = function() {
    return arealine().x(x0).y(y1);
  };

  area.lineX1 = function() {
    return arealine().x(x1).y(y0);
  };

  area.defined = function(_) {
    return arguments.length ? (defined = typeof _ === "function" ? _ : constant$3(!!_), area) : defined;
  };

  area.curve = function(_) {
    return arguments.length ? (curve = _, context != null && (output = curve(context)), area) : curve;
  };

  area.context = function(_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), area) : context;
  };

  return area;
}

function descending(a, b) {
  return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
}

function identity$4(d) {
  return d;
}

function pie() {
  var value = identity$4,
      sortValues = descending,
      sort = null,
      startAngle = constant$3(0),
      endAngle = constant$3(tau$1),
      padAngle = constant$3(0);

  function pie(data) {
    var i,
        n = data.length,
        j,
        k,
        sum = 0,
        index = new Array(n),
        arcs = new Array(n),
        a0 = +startAngle.apply(this, arguments),
        da = Math.min(tau$1, Math.max(-tau$1, endAngle.apply(this, arguments) - a0)),
        a1,
        p = Math.min(Math.abs(da) / n, padAngle.apply(this, arguments)),
        pa = p * (da < 0 ? -1 : 1),
        v;

    for (i = 0; i < n; ++i) {
      if ((v = arcs[index[i] = i] = +value(data[i], i, data)) > 0) {
        sum += v;
      }
    }

    // Optionally sort the arcs by previously-computed values or by data.
    if (sortValues != null) index.sort(function(i, j) { return sortValues(arcs[i], arcs[j]); });
    else if (sort != null) index.sort(function(i, j) { return sort(data[i], data[j]); });

    // Compute the arcs! They are stored in the original data's order.
    for (i = 0, k = sum ? (da - n * pa) / sum : 0; i < n; ++i, a0 = a1) {
      j = index[i], v = arcs[j], a1 = a0 + (v > 0 ? v * k : 0) + pa, arcs[j] = {
        data: data[j],
        index: i,
        value: v,
        startAngle: a0,
        endAngle: a1,
        padAngle: p
      };
    }

    return arcs;
  }

  pie.value = function(_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : constant$3(+_), pie) : value;
  };

  pie.sortValues = function(_) {
    return arguments.length ? (sortValues = _, sort = null, pie) : sortValues;
  };

  pie.sort = function(_) {
    return arguments.length ? (sort = _, sortValues = null, pie) : sort;
  };

  pie.startAngle = function(_) {
    return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant$3(+_), pie) : startAngle;
  };

  pie.endAngle = function(_) {
    return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant$3(+_), pie) : endAngle;
  };

  pie.padAngle = function(_) {
    return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant$3(+_), pie) : padAngle;
  };

  return pie;
}

var curveRadialLinear = curveRadial(curveLinear);

function Radial(curve) {
  this._curve = curve;
}

Radial.prototype = {
  areaStart: function() {
    this._curve.areaStart();
  },
  areaEnd: function() {
    this._curve.areaEnd();
  },
  lineStart: function() {
    this._curve.lineStart();
  },
  lineEnd: function() {
    this._curve.lineEnd();
  },
  point: function(a, r) {
    this._curve.point(r * Math.sin(a), r * -Math.cos(a));
  }
};

function curveRadial(curve) {

  function radial(context) {
    return new Radial(curve(context));
  }

  radial._curve = curve;

  return radial;
}

function radialLine(l) {
  var c = l.curve;

  l.angle = l.x, delete l.x;
  l.radius = l.y, delete l.y;

  l.curve = function(_) {
    return arguments.length ? c(curveRadial(_)) : c()._curve;
  };

  return l;
}

function radialLine$1() {
  return radialLine(line().curve(curveRadialLinear));
}

function radialArea() {
  var a = area().curve(curveRadialLinear),
      c = a.curve,
      x0 = a.lineX0,
      x1 = a.lineX1,
      y0 = a.lineY0,
      y1 = a.lineY1;

  a.angle = a.x, delete a.x;
  a.startAngle = a.x0, delete a.x0;
  a.endAngle = a.x1, delete a.x1;
  a.radius = a.y, delete a.y;
  a.innerRadius = a.y0, delete a.y0;
  a.outerRadius = a.y1, delete a.y1;
  a.lineStartAngle = function() { return radialLine(x0()); }, delete a.lineX0;
  a.lineEndAngle = function() { return radialLine(x1()); }, delete a.lineX1;
  a.lineInnerRadius = function() { return radialLine(y0()); }, delete a.lineY0;
  a.lineOuterRadius = function() { return radialLine(y1()); }, delete a.lineY1;

  a.curve = function(_) {
    return arguments.length ? c(curveRadial(_)) : c()._curve;
  };

  return a;
}

var circle = {
  draw: function(context, size) {
    var r = Math.sqrt(size / pi$1);
    context.moveTo(r, 0);
    context.arc(0, 0, r, 0, tau$1);
  }
};

var cross = {
  draw: function(context, size) {
    var r = Math.sqrt(size / 5) / 2;
    context.moveTo(-3 * r, -r);
    context.lineTo(-r, -r);
    context.lineTo(-r, -3 * r);
    context.lineTo(r, -3 * r);
    context.lineTo(r, -r);
    context.lineTo(3 * r, -r);
    context.lineTo(3 * r, r);
    context.lineTo(r, r);
    context.lineTo(r, 3 * r);
    context.lineTo(-r, 3 * r);
    context.lineTo(-r, r);
    context.lineTo(-3 * r, r);
    context.closePath();
  }
};

var tan30 = Math.sqrt(1 / 3),
    tan30_2 = tan30 * 2;

var diamond = {
  draw: function(context, size) {
    var y = Math.sqrt(size / tan30_2),
        x = y * tan30;
    context.moveTo(0, -y);
    context.lineTo(x, 0);
    context.lineTo(0, y);
    context.lineTo(-x, 0);
    context.closePath();
  }
};

var ka = 0.89081309152928522810,
    kr = Math.sin(pi$1 / 10) / Math.sin(7 * pi$1 / 10),
    kx = Math.sin(tau$1 / 10) * kr,
    ky = -Math.cos(tau$1 / 10) * kr;

var star = {
  draw: function(context, size) {
    var r = Math.sqrt(size * ka),
        x = kx * r,
        y = ky * r;
    context.moveTo(0, -r);
    context.lineTo(x, y);
    for (var i = 1; i < 5; ++i) {
      var a = tau$1 * i / 5,
          c = Math.cos(a),
          s = Math.sin(a);
      context.lineTo(s * r, -c * r);
      context.lineTo(c * x - s * y, s * x + c * y);
    }
    context.closePath();
  }
};

var square = {
  draw: function(context, size) {
    var w = Math.sqrt(size),
        x = -w / 2;
    context.rect(x, x, w, w);
  }
};

var sqrt3 = Math.sqrt(3);

var triangle = {
  draw: function(context, size) {
    var y = -Math.sqrt(size / (sqrt3 * 3));
    context.moveTo(0, y * 2);
    context.lineTo(-sqrt3 * y, -y);
    context.lineTo(sqrt3 * y, -y);
    context.closePath();
  }
};

var c = -0.5,
    s = Math.sqrt(3) / 2,
    k = 1 / Math.sqrt(12),
    a = (k / 2 + 1) * 3;

var wye = {
  draw: function(context, size) {
    var r = Math.sqrt(size / a),
        x0 = r / 2,
        y0 = r * k,
        x1 = x0,
        y1 = r * k + r,
        x2 = -x1,
        y2 = y1;
    context.moveTo(x0, y0);
    context.lineTo(x1, y1);
    context.lineTo(x2, y2);
    context.lineTo(c * x0 - s * y0, s * x0 + c * y0);
    context.lineTo(c * x1 - s * y1, s * x1 + c * y1);
    context.lineTo(c * x2 - s * y2, s * x2 + c * y2);
    context.lineTo(c * x0 + s * y0, c * y0 - s * x0);
    context.lineTo(c * x1 + s * y1, c * y1 - s * x1);
    context.lineTo(c * x2 + s * y2, c * y2 - s * x2);
    context.closePath();
  }
};

var symbols = [
  circle,
  cross,
  diamond,
  square,
  star,
  triangle,
  wye
];

function symbol() {
  var type = constant$3(circle),
      size = constant$3(64),
      context = null;

  function symbol() {
    var buffer;
    if (!context) context = buffer = path();
    type.apply(this, arguments).draw(context, +size.apply(this, arguments));
    if (buffer) return context = null, buffer + "" || null;
  }

  symbol.type = function(_) {
    return arguments.length ? (type = typeof _ === "function" ? _ : constant$3(_), symbol) : type;
  };

  symbol.size = function(_) {
    return arguments.length ? (size = typeof _ === "function" ? _ : constant$3(+_), symbol) : size;
  };

  symbol.context = function(_) {
    return arguments.length ? (context = _ == null ? null : _, symbol) : context;
  };

  return symbol;
}

function noop() {}

function point(that, x, y) {
  that._context.bezierCurveTo(
    (2 * that._x0 + that._x1) / 3,
    (2 * that._y0 + that._y1) / 3,
    (that._x0 + 2 * that._x1) / 3,
    (that._y0 + 2 * that._y1) / 3,
    (that._x0 + 4 * that._x1 + x) / 6,
    (that._y0 + 4 * that._y1 + y) / 6
  );
}

function Basis(context) {
  this._context = context;
}

Basis.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 =
    this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 3: point(this, this._x1, this._y1); // proceed
      case 2: this._context.lineTo(this._x1, this._y1); break;
    }
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6); // proceed
      default: point(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
  }
};

function basis(context) {
  return new Basis(context);
}

function BasisClosed(context) {
  this._context = context;
}

BasisClosed.prototype = {
  areaStart: noop,
  areaEnd: noop,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 =
    this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x2, this._y2);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);
        this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x2, this._y2);
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        break;
      }
    }
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._x2 = x, this._y2 = y; break;
      case 1: this._point = 2; this._x3 = x, this._y3 = y; break;
      case 2: this._point = 3; this._x4 = x, this._y4 = y; this._context.moveTo((this._x0 + 4 * this._x1 + x) / 6, (this._y0 + 4 * this._y1 + y) / 6); break;
      default: point(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
  }
};

function basisClosed(context) {
  return new BasisClosed(context);
}

function BasisOpen(context) {
  this._context = context;
}

BasisOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 =
    this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; var x0 = (this._x0 + 4 * this._x1 + x) / 6, y0 = (this._y0 + 4 * this._y1 + y) / 6; this._line ? this._context.lineTo(x0, y0) : this._context.moveTo(x0, y0); break;
      case 3: this._point = 4; // proceed
      default: point(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
  }
};

function basisOpen(context) {
  return new BasisOpen(context);
}

function Bundle(context, beta) {
  this._basis = new Basis(context);
  this._beta = beta;
}

Bundle.prototype = {
  lineStart: function() {
    this._x = [];
    this._y = [];
    this._basis.lineStart();
  },
  lineEnd: function() {
    var x = this._x,
        y = this._y,
        j = x.length - 1;

    if (j > 0) {
      var x0 = x[0],
          y0 = y[0],
          dx = x[j] - x0,
          dy = y[j] - y0,
          i = -1,
          t;

      while (++i <= j) {
        t = i / j;
        this._basis.point(
          this._beta * x[i] + (1 - this._beta) * (x0 + t * dx),
          this._beta * y[i] + (1 - this._beta) * (y0 + t * dy)
        );
      }
    }

    this._x = this._y = null;
    this._basis.lineEnd();
  },
  point: function(x, y) {
    this._x.push(+x);
    this._y.push(+y);
  }
};

var bundle = (function custom(beta) {

  function bundle(context) {
    return beta === 1 ? new Basis(context) : new Bundle(context, beta);
  }

  bundle.beta = function(beta) {
    return custom(+beta);
  };

  return bundle;
})(0.85);

function point$1(that, x, y) {
  that._context.bezierCurveTo(
    that._x1 + that._k * (that._x2 - that._x0),
    that._y1 + that._k * (that._y2 - that._y0),
    that._x2 + that._k * (that._x1 - x),
    that._y2 + that._k * (that._y1 - y),
    that._x2,
    that._y2
  );
}

function Cardinal(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}

Cardinal.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 =
    this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2: this._context.lineTo(this._x2, this._y2); break;
      case 3: point$1(this, this._x1, this._y1); break;
    }
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; this._x1 = x, this._y1 = y; break;
      case 2: this._point = 3; // proceed
      default: point$1(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

var cardinal = (function custom(tension) {

  function cardinal(context) {
    return new Cardinal(context, tension);
  }

  cardinal.tension = function(tension) {
    return custom(+tension);
  };

  return cardinal;
})(0);

function CardinalClosed(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}

CardinalClosed.prototype = {
  areaStart: noop,
  areaEnd: noop,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 =
    this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._x3 = x, this._y3 = y; break;
      case 1: this._point = 2; this._context.moveTo(this._x4 = x, this._y4 = y); break;
      case 2: this._point = 3; this._x5 = x, this._y5 = y; break;
      default: point$1(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

var cardinalClosed = (function custom(tension) {

  function cardinal(context) {
    return new CardinalClosed(context, tension);
  }

  cardinal.tension = function(tension) {
    return custom(+tension);
  };

  return cardinal;
})(0);

function CardinalOpen(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}

CardinalOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 =
    this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2); break;
      case 3: this._point = 4; // proceed
      default: point$1(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

var cardinalOpen = (function custom(tension) {

  function cardinal(context) {
    return new CardinalOpen(context, tension);
  }

  cardinal.tension = function(tension) {
    return custom(+tension);
  };

  return cardinal;
})(0);

function point$2(that, x, y) {
  var x1 = that._x1,
      y1 = that._y1,
      x2 = that._x2,
      y2 = that._y2;

  if (that._l01_a > epsilon$1) {
    var a = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a,
        n = 3 * that._l01_a * (that._l01_a + that._l12_a);
    x1 = (x1 * a - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n;
    y1 = (y1 * a - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n;
  }

  if (that._l23_a > epsilon$1) {
    var b = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a,
        m = 3 * that._l23_a * (that._l23_a + that._l12_a);
    x2 = (x2 * b + that._x1 * that._l23_2a - x * that._l12_2a) / m;
    y2 = (y2 * b + that._y1 * that._l23_2a - y * that._l12_2a) / m;
  }

  that._context.bezierCurveTo(x1, y1, x2, y2, that._x2, that._y2);
}

function CatmullRom(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}

CatmullRom.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 =
    this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a =
    this._l01_2a = this._l12_2a = this._l23_2a =
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2: this._context.lineTo(this._x2, this._y2); break;
      case 3: this.point(this._x2, this._y2); break;
    }
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;

    if (this._point) {
      var x23 = this._x2 - x,
          y23 = this._y2 - y;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }

    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; // proceed
      default: point$2(this, x, y); break;
    }

    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

var catmullRom = (function custom(alpha) {

  function catmullRom(context) {
    return alpha ? new CatmullRom(context, alpha) : new Cardinal(context, 0);
  }

  catmullRom.alpha = function(alpha) {
    return custom(+alpha);
  };

  return catmullRom;
})(0.5);

function CatmullRomClosed(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}

CatmullRomClosed.prototype = {
  areaStart: noop,
  areaEnd: noop,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 =
    this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._l01_a = this._l12_a = this._l23_a =
    this._l01_2a = this._l12_2a = this._l23_2a =
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(x, y) {
    x = +x, y = +y;

    if (this._point) {
      var x23 = this._x2 - x,
          y23 = this._y2 - y;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }

    switch (this._point) {
      case 0: this._point = 1; this._x3 = x, this._y3 = y; break;
      case 1: this._point = 2; this._context.moveTo(this._x4 = x, this._y4 = y); break;
      case 2: this._point = 3; this._x5 = x, this._y5 = y; break;
      default: point$2(this, x, y); break;
    }

    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

var catmullRomClosed = (function custom(alpha) {

  function catmullRom(context) {
    return alpha ? new CatmullRomClosed(context, alpha) : new CardinalClosed(context, 0);
  }

  catmullRom.alpha = function(alpha) {
    return custom(+alpha);
  };

  return catmullRom;
})(0.5);

function CatmullRomOpen(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}

CatmullRomOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 =
    this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a =
    this._l01_2a = this._l12_2a = this._l23_2a =
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;

    if (this._point) {
      var x23 = this._x2 - x,
          y23 = this._y2 - y;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }

    switch (this._point) {
      case 0: this._point = 1; break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2); break;
      case 3: this._point = 4; // proceed
      default: point$2(this, x, y); break;
    }

    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

var catmullRomOpen = (function custom(alpha) {

  function catmullRom(context) {
    return alpha ? new CatmullRomOpen(context, alpha) : new CardinalOpen(context, 0);
  }

  catmullRom.alpha = function(alpha) {
    return custom(+alpha);
  };

  return catmullRom;
})(0.5);

function LinearClosed(context) {
  this._context = context;
}

LinearClosed.prototype = {
  areaStart: noop,
  areaEnd: noop,
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._point) this._context.closePath();
  },
  point: function(x, y) {
    x = +x, y = +y;
    if (this._point) this._context.lineTo(x, y);
    else this._point = 1, this._context.moveTo(x, y);
  }
};

function linearClosed(context) {
  return new LinearClosed(context);
}

function sign(x) {
  return x < 0 ? -1 : 1;
}

// Calculate the slopes of the tangents (Hermite-type interpolation) based on
// the following paper: Steffen, M. 1990. A Simple Method for Monotonic
// Interpolation in One Dimension. Astronomy and Astrophysics, Vol. 239, NO.
// NOV(II), P. 443, 1990.
function slope3(that, x2, y2) {
  var h0 = that._x1 - that._x0,
      h1 = x2 - that._x1,
      s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0),
      s1 = (y2 - that._y1) / (h1 || h0 < 0 && -0),
      p = (s0 * h1 + s1 * h0) / (h0 + h1);
  return (sign(s0) + sign(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;
}

// Calculate a one-sided slope.
function slope2(that, t) {
  var h = that._x1 - that._x0;
  return h ? (3 * (that._y1 - that._y0) / h - t) / 2 : t;
}

// According to https://en.wikipedia.org/wiki/Cubic_Hermite_spline#Representations
// "you can express cubic Hermite interpolation in terms of cubic Bézier curves
// with respect to the four values p0, p0 + m0 / 3, p1 - m1 / 3, p1".
function point$3(that, t0, t1) {
  var x0 = that._x0,
      y0 = that._y0,
      x1 = that._x1,
      y1 = that._y1,
      dx = (x1 - x0) / 3;
  that._context.bezierCurveTo(x0 + dx, y0 + dx * t0, x1 - dx, y1 - dx * t1, x1, y1);
}

function MonotoneX(context) {
  this._context = context;
}

MonotoneX.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 =
    this._y0 = this._y1 =
    this._t0 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2: this._context.lineTo(this._x1, this._y1); break;
      case 3: point$3(this, this._t0, slope2(this, this._t0)); break;
    }
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    var t1 = NaN;

    x = +x, y = +y;
    if (x === this._x1 && y === this._y1) return; // Ignore coincident points.
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; point$3(this, slope2(this, t1 = slope3(this, x, y)), t1); break;
      default: point$3(this, this._t0, t1 = slope3(this, x, y)); break;
    }

    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
    this._t0 = t1;
  }
};

function MonotoneY(context) {
  this._context = new ReflectContext(context);
}

(MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function(x, y) {
  MonotoneX.prototype.point.call(this, y, x);
};

function ReflectContext(context) {
  this._context = context;
}

ReflectContext.prototype = {
  moveTo: function(x, y) { this._context.moveTo(y, x); },
  closePath: function() { this._context.closePath(); },
  lineTo: function(x, y) { this._context.lineTo(y, x); },
  bezierCurveTo: function(x1, y1, x2, y2, x, y) { this._context.bezierCurveTo(y1, x1, y2, x2, y, x); }
};

function monotoneX(context) {
  return new MonotoneX(context);
}

function monotoneY(context) {
  return new MonotoneY(context);
}

function Natural(context) {
  this._context = context;
}

Natural.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = [];
    this._y = [];
  },
  lineEnd: function() {
    var x = this._x,
        y = this._y,
        n = x.length;

    if (n) {
      this._line ? this._context.lineTo(x[0], y[0]) : this._context.moveTo(x[0], y[0]);
      if (n === 2) {
        this._context.lineTo(x[1], y[1]);
      } else {
        var px = controlPoints(x),
            py = controlPoints(y);
        for (var i0 = 0, i1 = 1; i1 < n; ++i0, ++i1) {
          this._context.bezierCurveTo(px[0][i0], py[0][i0], px[1][i0], py[1][i0], x[i1], y[i1]);
        }
      }
    }

    if (this._line || (this._line !== 0 && n === 1)) this._context.closePath();
    this._line = 1 - this._line;
    this._x = this._y = null;
  },
  point: function(x, y) {
    this._x.push(+x);
    this._y.push(+y);
  }
};

// See https://www.particleincell.com/2012/bezier-splines/ for derivation.
function controlPoints(x) {
  var i,
      n = x.length - 1,
      m,
      a = new Array(n),
      b = new Array(n),
      r = new Array(n);
  a[0] = 0, b[0] = 2, r[0] = x[0] + 2 * x[1];
  for (i = 1; i < n - 1; ++i) a[i] = 1, b[i] = 4, r[i] = 4 * x[i] + 2 * x[i + 1];
  a[n - 1] = 2, b[n - 1] = 7, r[n - 1] = 8 * x[n - 1] + x[n];
  for (i = 1; i < n; ++i) m = a[i] / b[i - 1], b[i] -= m, r[i] -= m * r[i - 1];
  a[n - 1] = r[n - 1] / b[n - 1];
  for (i = n - 2; i >= 0; --i) a[i] = (r[i] - a[i + 1]) / b[i];
  b[n - 1] = (x[n] + a[n - 1]) / 2;
  for (i = 0; i < n - 1; ++i) b[i] = 2 * x[i + 1] - a[i + 1];
  return [a, b];
}

function natural(context) {
  return new Natural(context);
}

function Step(context, t) {
  this._context = context;
  this._t = t;
}

Step.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = this._y = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (0 < this._t && this._t < 1 && this._point === 2) this._context.lineTo(this._x, this._y);
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    if (this._line >= 0) this._t = 1 - this._t, this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; // proceed
      default: {
        if (this._t <= 0) {
          this._context.lineTo(this._x, y);
          this._context.lineTo(x, y);
        } else {
          var x1 = this._x * (1 - this._t) + x * this._t;
          this._context.lineTo(x1, this._y);
          this._context.lineTo(x1, y);
        }
        break;
      }
    }
    this._x = x, this._y = y;
  }
};

function step(context) {
  return new Step(context, 0.5);
}

function stepBefore(context) {
  return new Step(context, 0);
}

function stepAfter(context) {
  return new Step(context, 1);
}

var slice$1 = Array.prototype.slice;

function none(series, order) {
  if (!((n = series.length) > 1)) return;
  for (var i = 1, s0, s1 = series[order[0]], n, m = s1.length; i < n; ++i) {
    s0 = s1, s1 = series[order[i]];
    for (var j = 0; j < m; ++j) {
      s1[j][1] += s1[j][0] = isNaN(s0[j][1]) ? s0[j][0] : s0[j][1];
    }
  }
}

function none$1(series) {
  var n = series.length, o = new Array(n);
  while (--n >= 0) o[n] = n;
  return o;
}

function stackValue(d, key) {
  return d[key];
}

function stack() {
  var keys = constant$3([]),
      order = none$1,
      offset = none,
      value = stackValue;

  function stack(data) {
    var kz = keys.apply(this, arguments),
        i,
        m = data.length,
        n = kz.length,
        sz = new Array(n),
        oz;

    for (i = 0; i < n; ++i) {
      for (var ki = kz[i], si = sz[i] = new Array(m), j = 0, sij; j < m; ++j) {
        si[j] = sij = [0, +value(data[j], ki, j, data)];
        sij.data = data[j];
      }
      si.key = ki;
    }

    for (i = 0, oz = order(sz); i < n; ++i) {
      sz[oz[i]].index = i;
    }

    offset(sz, oz);
    return sz;
  }

  stack.keys = function(_) {
    return arguments.length ? (keys = typeof _ === "function" ? _ : constant$3(slice$1.call(_)), stack) : keys;
  };

  stack.value = function(_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : constant$3(+_), stack) : value;
  };

  stack.order = function(_) {
    return arguments.length ? (order = _ == null ? none$1 : typeof _ === "function" ? _ : constant$3(slice$1.call(_)), stack) : order;
  };

  stack.offset = function(_) {
    return arguments.length ? (offset = _ == null ? none : _, stack) : offset;
  };

  return stack;
}

function expand(series, order) {
  if (!((n = series.length) > 0)) return;
  for (var i, n, j = 0, m = series[0].length, y; j < m; ++j) {
    for (y = i = 0; i < n; ++i) y += series[i][j][1] || 0;
    if (y) for (i = 0; i < n; ++i) series[i][j][1] /= y;
  }
  none(series, order);
}

function silhouette(series, order) {
  if (!((n = series.length) > 0)) return;
  for (var j = 0, s0 = series[order[0]], n, m = s0.length; j < m; ++j) {
    for (var i = 0, y = 0; i < n; ++i) y += series[i][j][1] || 0;
    s0[j][1] += s0[j][0] = -y / 2;
  }
  none(series, order);
}

function wiggle(series, order) {
  if (!((n = series.length) > 0) || !((m = (s0 = series[order[0]]).length) > 0)) return;
  for (var y = 0, j = 1, s0, m, n; j < m; ++j) {
    for (var i = 0, s1 = 0, s2 = 0; i < n; ++i) {
      var si = series[order[i]],
          sij0 = si[j][1] || 0,
          sij1 = si[j - 1][1] || 0,
          s3 = (sij0 - sij1) / 2;
      for (var k = 0; k < i; ++k) {
        var sk = series[order[k]],
            skj0 = sk[j][1] || 0,
            skj1 = sk[j - 1][1] || 0;
        s3 += skj0 - skj1;
      }
      s1 += sij0, s2 += s3 * sij0;
    }
    s0[j - 1][1] += s0[j - 1][0] = y;
    if (s1) y -= s2 / s1;
  }
  s0[j - 1][1] += s0[j - 1][0] = y;
  none(series, order);
}

function ascending$1(series) {
  var sums = series.map(sum$1);
  return none$1(series).sort(function(a, b) { return sums[a] - sums[b]; });
}

function sum$1(series) {
  var s = 0, i = -1, n = series.length, v;
  while (++i < n) if (v = +series[i][1]) s += v;
  return s;
}

function descending$1(series) {
  return ascending$1(series).reverse();
}

function insideOut(series) {
  var n = series.length,
      i,
      j,
      sums = series.map(sum$1),
      order = none$1(series).sort(function(a, b) { return sums[b] - sums[a]; }),
      top = 0,
      bottom = 0,
      tops = [],
      bottoms = [];

  for (i = 0; i < n; ++i) {
    j = order[i];
    if (top < bottom) {
      top += sums[j];
      tops.push(j);
    } else {
      bottom += sums[j];
      bottoms.push(j);
    }
  }

  return bottoms.reverse().concat(tops);
}

function reverse(series) {
  return none$1(series).reverse();
}



var d3Shape = /*#__PURE__*/Object.freeze({
	__proto__: null,
	arc: arc$1,
	area: area,
	line: line,
	pie: pie,
	radialArea: radialArea,
	radialLine: radialLine$1,
	symbol: symbol,
	symbols: symbols,
	symbolCircle: circle,
	symbolCross: cross,
	symbolDiamond: diamond,
	symbolSquare: square,
	symbolStar: star,
	symbolTriangle: triangle,
	symbolWye: wye,
	curveBasisClosed: basisClosed,
	curveBasisOpen: basisOpen,
	curveBasis: basis,
	curveBundle: bundle,
	curveCardinalClosed: cardinalClosed,
	curveCardinalOpen: cardinalOpen,
	curveCardinal: cardinal,
	curveCatmullRomClosed: catmullRomClosed,
	curveCatmullRomOpen: catmullRomOpen,
	curveCatmullRom: catmullRom,
	curveLinearClosed: linearClosed,
	curveLinear: curveLinear,
	curveMonotoneX: monotoneX,
	curveMonotoneY: monotoneY,
	curveNatural: natural,
	curveStep: step,
	curveStepAfter: stepAfter,
	curveStepBefore: stepBefore,
	stack: stack,
	stackOffsetExpand: expand,
	stackOffsetNone: none,
	stackOffsetSilhouette: silhouette,
	stackOffsetWiggle: wiggle,
	stackOrderAscending: ascending$1,
	stackOrderDescending: descending$1,
	stackOrderInsideOut: insideOut,
	stackOrderNone: none$1,
	stackOrderReverse: reverse
});

var Builder = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.arcBuilder = exports.pathBuilder = exports.lineBuilder = undefined;



var lineBuilder = exports.lineBuilder = function lineBuilder(_ref) {
  var data = _ref.data,
      _ref$curve = _ref.curve,
      curve = _ref$curve === undefined ? d3Shape.curveLinear : _ref$curve,
      canvasContext = _ref.canvasContext,
      className = _ref.className,
      classID = _ref.classID;

  var lineGen = (0, d3Shape.line)().curve(curve);

  var builder = {
    type: "path",
    className: className,
    classID: classID,
    data: data
  };

  if (canvasContext) {
    lineGen.context(canvasContext);
    builder.pathMethods = lineGen;
  } else {
    builder.attrs = {
      d: lineGen(data)
    };
  }

  return builder;
};

var pathBuilder = exports.pathBuilder = function pathBuilder(_ref2) {
  var d = _ref2.d,
      _ref2$curve = _ref2.curve,
      curve = _ref2$curve === undefined ? d3Shape.curveLinear : _ref2$curve,
      canvasContext = _ref2.canvasContext,
      className = _ref2.className,
      classID = _ref2.classID;

  var lineGen = (0, d3Shape.line)().curve(curve);

  var builder = {
    type: "path",
    className: className,
    classID: classID
  };

  if (canvasContext) {
    lineGen.context(canvasContext);
  } else {
    builder.attrs = {
      d: d
    };
  }

  return builder;
};

var arcBuilder = exports.arcBuilder = function arcBuilder(_ref3) {
  var data = _ref3.data,
      canvasContext = _ref3.canvasContext,
      className = _ref3.className,
      classID = _ref3.classID;

  var builder = {
    type: "path",
    className: className,
    classID: classID,
    data: data
  };

  var arcShape = (0, d3Shape.arc)().innerRadius(data.innerRadius || 0).outerRadius(data.outerRadius || data.radius || 2).startAngle(data.startAngle || 0).endAngle(data.endAngle || 2 * Math.PI);

  if (canvasContext) {
    arcShape.context(canvasContext);
  } else {
    builder.attrs = {
      d: arcShape()
    };
  }

  return builder;
};
});

unwrapExports(Builder);
var Builder_1 = Builder.arcBuilder;
var Builder_2 = Builder.pathBuilder;
var Builder_3 = Builder.lineBuilder;

var circle$1 = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.circleHandles = undefined;



var circleHandles = exports.circleHandles = function circleHandles(_ref) {
  var _ref$cx = _ref.cx,
      cx = _ref$cx === undefined ? 0 : _ref$cx,
      _ref$cy = _ref.cy,
      cy = _ref$cy === undefined ? 0 : _ref$cy,
      r1 = _ref.r1,
      r2 = _ref.r2,
      padding = _ref.padding;

  var h = { move: { x: cx, y: cy } };

  if (r1 !== undefined) {
    h.r1 = { x: cx + r1 / Math.sqrt(2), y: cy + r1 / Math.sqrt(2) };
  }

  if (r2 !== undefined) {
    h.r2 = { x: cx + r2 / Math.sqrt(2), y: cy + r2 / Math.sqrt(2) };
  }

  if (padding !== undefined) {
    h.padding = { x: cx + r1 + padding, y: cy };
  }

  return h;
};

exports.default = function (_ref2) {
  var radius = _ref2.radius,
      radiusPadding = _ref2.radiusPadding,
      outerRadius = _ref2.outerRadius,
      innerRadius = _ref2.innerRadius,
      editMode = _ref2.editMode;

  var handles = [];
  var c = (0, Builder.arcBuilder)({
    data: { radius: radius, outerRadius: outerRadius, innerRadius: innerRadius },
    className: "subject"
  });

  if (editMode) {
    var h = circleHandles({
      r1: c.data.outerRadius || c.data.radius,
      r2: c.data.innerRadius,
      padding: radiusPadding
    });

    var cHandles = [{
      x: h.r1.x,
      y: h.r1.y,
      key: c.data.outerRadius ? "outerRadius" : "radius"
    }];

    if (innerRadius) {
      cHandles.push({ x: h.r2.x, y: h.r2.y, key: "innerRadius" });
    }
    handles = cHandles;
  }

  c.attrs["fill-opacity"] = 0;

  return { components: [c], handles: handles };
};
});

unwrapExports(circle$1);
var circle_1 = circle$1.circleHandles;

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var ReactPropTypesSecret$2 = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

var ReactPropTypesSecret_1$1 = ReactPropTypesSecret$2;

var printWarning$2 = function() {};

if (process.env.NODE_ENV !== 'production') {
  var ReactPropTypesSecret$3 = ReactPropTypesSecret_1$1;
  var loggedTypeFailures$1 = {};

  printWarning$2 = function(text) {
    var message = 'Warning: ' + text;
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };
}

/**
 * Assert that the values match with the type specs.
 * Error messages are memorized and will only be shown once.
 *
 * @param {object} typeSpecs Map of name to a ReactPropType
 * @param {object} values Runtime values that need to be type-checked
 * @param {string} location e.g. "prop", "context", "child context"
 * @param {string} componentName Name of the component for error messages.
 * @param {?Function} getStack Returns the component stack.
 * @private
 */
function checkPropTypes$1(typeSpecs, values, location, componentName, getStack) {
  if (process.env.NODE_ENV !== 'production') {
    for (var typeSpecName in typeSpecs) {
      if (typeSpecs.hasOwnProperty(typeSpecName)) {
        var error;
        // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.
        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          if (typeof typeSpecs[typeSpecName] !== 'function') {
            var err = Error(
              (componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' +
              'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.'
            );
            err.name = 'Invariant Violation';
            throw err;
          }
          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret$3);
        } catch (ex) {
          error = ex;
        }
        if (error && !(error instanceof Error)) {
          printWarning$2(
            (componentName || 'React class') + ': type specification of ' +
            location + ' `' + typeSpecName + '` is invalid; the type checker ' +
            'function must return `null` or an `Error` but returned a ' + typeof error + '. ' +
            'You may have forgotten to pass an argument to the type checker ' +
            'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' +
            'shape all require an argument).'
          );

        }
        if (error instanceof Error && !(error.message in loggedTypeFailures$1)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures$1[error.message] = true;

          var stack = getStack ? getStack() : '';

          printWarning$2(
            'Failed ' + location + ' type: ' + error.message + (stack != null ? stack : '')
          );
        }
      }
    }
  }
}

var checkPropTypes_1$1 = checkPropTypes$1;

var printWarning$3 = function() {};

if (process.env.NODE_ENV !== 'production') {
  printWarning$3 = function(text) {
    var message = 'Warning: ' + text;
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };
}

function emptyFunctionThatReturnsNull$1() {
  return null;
}

var factoryWithTypeCheckers$1 = function(isValidElement, throwOnDirectAccess) {
  /* global Symbol */
  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

  /**
   * Returns the iterator method function contained on the iterable object.
   *
   * Be sure to invoke the function with the iterable as context:
   *
   *     var iteratorFn = getIteratorFn(myIterable);
   *     if (iteratorFn) {
   *       var iterator = iteratorFn.call(myIterable);
   *       ...
   *     }
   *
   * @param {?object} maybeIterable
   * @return {?function}
   */
  function getIteratorFn(maybeIterable) {
    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
    if (typeof iteratorFn === 'function') {
      return iteratorFn;
    }
  }

  /**
   * Collection of methods that allow declaration and validation of props that are
   * supplied to React components. Example usage:
   *
   *   var Props = require('ReactPropTypes');
   *   var MyArticle = React.createClass({
   *     propTypes: {
   *       // An optional string prop named "description".
   *       description: Props.string,
   *
   *       // A required enum prop named "category".
   *       category: Props.oneOf(['News','Photos']).isRequired,
   *
   *       // A prop named "dialog" that requires an instance of Dialog.
   *       dialog: Props.instanceOf(Dialog).isRequired
   *     },
   *     render: function() { ... }
   *   });
   *
   * A more formal specification of how these methods are used:
   *
   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
   *   decl := ReactPropTypes.{type}(.isRequired)?
   *
   * Each and every declaration produces a function with the same signature. This
   * allows the creation of custom validation functions. For example:
   *
   *  var MyLink = React.createClass({
   *    propTypes: {
   *      // An optional string or URI prop named "href".
   *      href: function(props, propName, componentName) {
   *        var propValue = props[propName];
   *        if (propValue != null && typeof propValue !== 'string' &&
   *            !(propValue instanceof URI)) {
   *          return new Error(
   *            'Expected a string or an URI for ' + propName + ' in ' +
   *            componentName
   *          );
   *        }
   *      }
   *    },
   *    render: function() {...}
   *  });
   *
   * @internal
   */

  var ANONYMOUS = '<<anonymous>>';

  // Important!
  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.
  var ReactPropTypes = {
    array: createPrimitiveTypeChecker('array'),
    bool: createPrimitiveTypeChecker('boolean'),
    func: createPrimitiveTypeChecker('function'),
    number: createPrimitiveTypeChecker('number'),
    object: createPrimitiveTypeChecker('object'),
    string: createPrimitiveTypeChecker('string'),
    symbol: createPrimitiveTypeChecker('symbol'),

    any: createAnyTypeChecker(),
    arrayOf: createArrayOfTypeChecker,
    element: createElementTypeChecker(),
    instanceOf: createInstanceTypeChecker,
    node: createNodeChecker(),
    objectOf: createObjectOfTypeChecker,
    oneOf: createEnumTypeChecker,
    oneOfType: createUnionTypeChecker,
    shape: createShapeTypeChecker,
    exact: createStrictShapeTypeChecker,
  };

  /**
   * inlined Object.is polyfill to avoid requiring consumers ship their own
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
   */
  /*eslint-disable no-self-compare*/
  function is(x, y) {
    // SameValue algorithm
    if (x === y) {
      // Steps 1-5, 7-10
      // Steps 6.b-6.e: +0 != -0
      return x !== 0 || 1 / x === 1 / y;
    } else {
      // Step 6.a: NaN == NaN
      return x !== x && y !== y;
    }
  }
  /*eslint-enable no-self-compare*/

  /**
   * We use an Error-like object for backward compatibility as people may call
   * PropTypes directly and inspect their output. However, we don't use real
   * Errors anymore. We don't inspect their stack anyway, and creating them
   * is prohibitively expensive if they are created too often, such as what
   * happens in oneOfType() for any type before the one that matched.
   */
  function PropTypeError(message) {
    this.message = message;
    this.stack = '';
  }
  // Make `instanceof Error` still work for returned errors.
  PropTypeError.prototype = Error.prototype;

  function createChainableTypeChecker(validate) {
    if (process.env.NODE_ENV !== 'production') {
      var manualPropTypeCallCache = {};
      var manualPropTypeWarningCount = 0;
    }
    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
      componentName = componentName || ANONYMOUS;
      propFullName = propFullName || propName;

      if (secret !== ReactPropTypesSecret_1$1) {
        if (throwOnDirectAccess) {
          // New behavior only for users of `prop-types` package
          var err = new Error(
            'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
            'Use `PropTypes.checkPropTypes()` to call them. ' +
            'Read more at http://fb.me/use-check-prop-types'
          );
          err.name = 'Invariant Violation';
          throw err;
        } else if (process.env.NODE_ENV !== 'production' && typeof console !== 'undefined') {
          // Old behavior for people using React.PropTypes
          var cacheKey = componentName + ':' + propName;
          if (
            !manualPropTypeCallCache[cacheKey] &&
            // Avoid spamming the console because they are often not actionable except for lib authors
            manualPropTypeWarningCount < 3
          ) {
            printWarning$3(
              'You are manually calling a React.PropTypes validation ' +
              'function for the `' + propFullName + '` prop on `' + componentName  + '`. This is deprecated ' +
              'and will throw in the standalone `prop-types` package. ' +
              'You may be seeing this warning due to a third-party PropTypes ' +
              'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.'
            );
            manualPropTypeCallCache[cacheKey] = true;
            manualPropTypeWarningCount++;
          }
        }
      }
      if (props[propName] == null) {
        if (isRequired) {
          if (props[propName] === null) {
            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
          }
          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
        }
        return null;
      } else {
        return validate(props, propName, componentName, location, propFullName);
      }
    }

    var chainedCheckType = checkType.bind(null, false);
    chainedCheckType.isRequired = checkType.bind(null, true);

    return chainedCheckType;
  }

  function createPrimitiveTypeChecker(expectedType) {
    function validate(props, propName, componentName, location, propFullName, secret) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== expectedType) {
        // `propValue` being instance of, say, date/regexp, pass the 'object'
        // check, but we can offer a more precise error message here rather than
        // 'of type `object`'.
        var preciseType = getPreciseType(propValue);

        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createAnyTypeChecker() {
    return createChainableTypeChecker(emptyFunctionThatReturnsNull$1);
  }

  function createArrayOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
      }
      var propValue = props[propName];
      if (!Array.isArray(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
      }
      for (var i = 0; i < propValue.length; i++) {
        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret_1$1);
        if (error instanceof Error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createElementTypeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      if (!isValidElement(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createInstanceTypeChecker(expectedClass) {
    function validate(props, propName, componentName, location, propFullName) {
      if (!(props[propName] instanceof expectedClass)) {
        var expectedClassName = expectedClass.name || ANONYMOUS;
        var actualClassName = getClassName(props[propName]);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createEnumTypeChecker(expectedValues) {
    if (!Array.isArray(expectedValues)) {
      process.env.NODE_ENV !== 'production' ? printWarning$3('Invalid argument supplied to oneOf, expected an instance of array.') : void 0;
      return emptyFunctionThatReturnsNull$1;
    }

    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      for (var i = 0; i < expectedValues.length; i++) {
        if (is(propValue, expectedValues[i])) {
          return null;
        }
      }

      var valuesString = JSON.stringify(expectedValues);
      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createObjectOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
      }
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
      }
      for (var key in propValue) {
        if (propValue.hasOwnProperty(key)) {
          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret_1$1);
          if (error instanceof Error) {
            return error;
          }
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createUnionTypeChecker(arrayOfTypeCheckers) {
    if (!Array.isArray(arrayOfTypeCheckers)) {
      process.env.NODE_ENV !== 'production' ? printWarning$3('Invalid argument supplied to oneOfType, expected an instance of array.') : void 0;
      return emptyFunctionThatReturnsNull$1;
    }

    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
      var checker = arrayOfTypeCheckers[i];
      if (typeof checker !== 'function') {
        printWarning$3(
          'Invalid argument supplied to oneOfType. Expected an array of check functions, but ' +
          'received ' + getPostfixForTypeWarning(checker) + ' at index ' + i + '.'
        );
        return emptyFunctionThatReturnsNull$1;
      }
    }

    function validate(props, propName, componentName, location, propFullName) {
      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
        var checker = arrayOfTypeCheckers[i];
        if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret_1$1) == null) {
          return null;
        }
      }

      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createNodeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      if (!isNode(props[propName])) {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      for (var key in shapeTypes) {
        var checker = shapeTypes[key];
        if (!checker) {
          continue;
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret_1$1);
        if (error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createStrictShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      // We need to check all keys in case some are required but missing from
      // props.
      var allKeys = objectAssign({}, props[propName], shapeTypes);
      for (var key in allKeys) {
        var checker = shapeTypes[key];
        if (!checker) {
          return new PropTypeError(
            'Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' +
            '\nBad object: ' + JSON.stringify(props[propName], null, '  ') +
            '\nValid keys: ' +  JSON.stringify(Object.keys(shapeTypes), null, '  ')
          );
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret_1$1);
        if (error) {
          return error;
        }
      }
      return null;
    }

    return createChainableTypeChecker(validate);
  }

  function isNode(propValue) {
    switch (typeof propValue) {
      case 'number':
      case 'string':
      case 'undefined':
        return true;
      case 'boolean':
        return !propValue;
      case 'object':
        if (Array.isArray(propValue)) {
          return propValue.every(isNode);
        }
        if (propValue === null || isValidElement(propValue)) {
          return true;
        }

        var iteratorFn = getIteratorFn(propValue);
        if (iteratorFn) {
          var iterator = iteratorFn.call(propValue);
          var step;
          if (iteratorFn !== propValue.entries) {
            while (!(step = iterator.next()).done) {
              if (!isNode(step.value)) {
                return false;
              }
            }
          } else {
            // Iterator will provide entry [k,v] tuples rather than values.
            while (!(step = iterator.next()).done) {
              var entry = step.value;
              if (entry) {
                if (!isNode(entry[1])) {
                  return false;
                }
              }
            }
          }
        } else {
          return false;
        }

        return true;
      default:
        return false;
    }
  }

  function isSymbol(propType, propValue) {
    // Native Symbol.
    if (propType === 'symbol') {
      return true;
    }

    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
    if (propValue['@@toStringTag'] === 'Symbol') {
      return true;
    }

    // Fallback for non-spec compliant Symbols which are polyfilled.
    if (typeof Symbol === 'function' && propValue instanceof Symbol) {
      return true;
    }

    return false;
  }

  // Equivalent of `typeof` but with special handling for array and regexp.
  function getPropType(propValue) {
    var propType = typeof propValue;
    if (Array.isArray(propValue)) {
      return 'array';
    }
    if (propValue instanceof RegExp) {
      // Old webkits (at least until Android 4.0) return 'function' rather than
      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
      // passes PropTypes.object.
      return 'object';
    }
    if (isSymbol(propType, propValue)) {
      return 'symbol';
    }
    return propType;
  }

  // This handles more types than `getPropType`. Only used for error messages.
  // See `createPrimitiveTypeChecker`.
  function getPreciseType(propValue) {
    if (typeof propValue === 'undefined' || propValue === null) {
      return '' + propValue;
    }
    var propType = getPropType(propValue);
    if (propType === 'object') {
      if (propValue instanceof Date) {
        return 'date';
      } else if (propValue instanceof RegExp) {
        return 'regexp';
      }
    }
    return propType;
  }

  // Returns a string that is postfixed to a warning about an invalid type.
  // For example, "undefined" or "of type array"
  function getPostfixForTypeWarning(value) {
    var type = getPreciseType(value);
    switch (type) {
      case 'array':
      case 'object':
        return 'an ' + type;
      case 'boolean':
      case 'date':
      case 'regexp':
        return 'a ' + type;
      default:
        return type;
    }
  }

  // Returns class name of the object, if any.
  function getClassName(propValue) {
    if (!propValue.constructor || !propValue.constructor.name) {
      return ANONYMOUS;
    }
    return propValue.constructor.name;
  }

  ReactPropTypes.checkPropTypes = checkPropTypes_1$1;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};

function emptyFunction$1() {}

var factoryWithThrowingShims$1 = function() {
  function shim(props, propName, componentName, location, propFullName, secret) {
    if (secret === ReactPropTypesSecret_1$1) {
      // It is still safe when called from React.
      return;
    }
    var err = new Error(
      'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
      'Use PropTypes.checkPropTypes() to call them. ' +
      'Read more at http://fb.me/use-check-prop-types'
    );
    err.name = 'Invariant Violation';
    throw err;
  }  shim.isRequired = shim;
  function getShim() {
    return shim;
  }  // Important!
  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.
  var ReactPropTypes = {
    array: shim,
    bool: shim,
    func: shim,
    number: shim,
    object: shim,
    string: shim,
    symbol: shim,

    any: shim,
    arrayOf: getShim,
    element: shim,
    instanceOf: getShim,
    node: shim,
    objectOf: getShim,
    oneOf: getShim,
    oneOfType: getShim,
    shape: getShim,
    exact: getShim
  };

  ReactPropTypes.checkPropTypes = emptyFunction$1;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};

var propTypes$1 = createCommonjsModule(function (module) {
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

if (process.env.NODE_ENV !== 'production') {
  var REACT_ELEMENT_TYPE = (typeof Symbol === 'function' &&
    Symbol.for &&
    Symbol.for('react.element')) ||
    0xeac7;

  var isValidElement = function(object) {
    return typeof object === 'object' &&
      object !== null &&
      object.$$typeof === REACT_ELEMENT_TYPE;
  };

  // By explicitly using `prop-types` you are opting into new development behavior.
  // http://fb.me/prop-types-in-prod
  var throwOnDirectAccess = true;
  module.exports = factoryWithTypeCheckers$1(isValidElement, throwOnDirectAccess);
} else {
  // By explicitly using `prop-types` you are opting into new production behavior.
  // http://fb.me/prop-types-in-prod
  module.exports = factoryWithThrowingShims$1();
}
});

var Handle_1 = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = Handle;

var _react = _interopRequireDefault(React$1__default);

var _propTypes = _interopRequireDefault(propTypes$1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var events = {
  mouse: {
    start: "mousedown",
    move: "mousemove",
    stop: "mouseup"
  },
  touch: {
    start: "touchstart",
    move: "touchemove",
    stop: "touchend"
  }
};
var listenerOptions = {
  passive: false
};

var makeHandler = function makeHandler(type, handleStart, handleStop, handleDrag) {
  return function (e) {
    e.preventDefault();
    var xDim = "clientX";
    var yDim = "clientY";
    var oX = e.nativeEvent[xDim];
    var oY = e.nativeEvent[yDim];
    var x = oX;
    var y = oY;
    handleStart && handleStart();

    var move = function move(d) {
      d.preventDefault();
      handleDrag && handleDrag(d, {
        deltaX: d[xDim] - x,
        deltaY: d[yDim] - y,
        oDeltaX: d[xDim] - oX,
        oDeltaY: d[yDim] - oY
      });
      x = d[xDim];
      y = d[yDim];
    };

    var stop = function stop(e) {
      e.preventDefault();
      document.removeEventListener(events[type].move, move, listenerOptions);
      document.removeEventListener(events[type].stop, stop, listenerOptions);
      handleStop && handleStop();
    };

    document.addEventListener(events[type].move, move, listenerOptions);
    document.addEventListener(events[type].stop, stop, listenerOptions);
  };
};

function Handle(_ref) {
  var _ref$x = _ref.x,
      x = _ref$x === void 0 ? 0 : _ref$x,
      _ref$y = _ref.y,
      y = _ref$y === void 0 ? 0 : _ref$y,
      _ref$r = _ref.r,
      r = _ref$r === void 0 ? 10 : _ref$r,
      handleStart = _ref.handleStart,
      handleStop = _ref.handleStop,
      handleDrag = _ref.handleDrag;
  return _react.default.createElement("circle", {
    className: "handle",
    cx: x,
    cy: y,
    r: r,
    onMouseDown: makeHandler("mouse", handleStart, handleStop, handleDrag),
    onTouchStart: makeHandler("touch", handleStart, handleStop, handleDrag),
    strokeDasharray: "5",
    stroke: "grey",
    fill: "white",
    fillOpacity: 0
  });
}

Handle.propTypes = {
  x: _propTypes.default.number,
  y: _propTypes.default.number,
  r: _propTypes.default.number,
  handleStart: _propTypes.default.func,
  handleStop: _propTypes.default.func,
  handleDrag: _propTypes.default.func
};
});

unwrapExports(Handle_1);

var Subject_1 = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireDefault(React$1__default);

var _Handle = _interopRequireDefault(Handle_1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var FILLABLE = ["SubjectCircle", "SubjectRect"];

var Subject =
/*#__PURE__*/
function (_React$Component) {
  _inherits(Subject, _React$Component);

  function Subject() {
    _classCallCheck(this, Subject);

    return _possibleConstructorReturn(this, _getPrototypeOf(Subject).apply(this, arguments));
  }

  _createClass(Subject, [{
    key: "getComponents",
    value: function getComponents() {}
  }, {
    key: "render",
    value: function render() {
      var _this = this;

      var _this$props = this.props,
          editMode = _this$props.editMode,
          color = _this$props.color,
          _this$props$fill = _this$props.fill,
          fill = _this$props$fill === void 0 ? "none" : _this$props$fill,
          _this$props$fillOpaci = _this$props.fillOpacity,
          fillOpacity = _this$props$fillOpaci === void 0 ? 1 : _this$props$fillOpaci;
      var d = this.getComponents(this.props) || {};
      var handles;

      if (editMode) {
        handles = [_react.default.createElement(_Handle.default, {
          key: "subject-handle",
          handleStart: this.props.dragStart,
          handleStop: this.props.dragEnd,
          handleDrag: this.props.dragSubject
        })];

        if (d.handles) {
          handles = handles.concat(d.handles.map(function (h, i) {
            return _react.default.createElement(_Handle.default, {
              key: "subjecthandle-".concat(i),
              handleStart: _this.props.dragStart,
              handleStop: _this.props.dragEnd,
              x: h.x,
              y: h.y,
              offsetParent: h.offsetParent && _this.subject,
              handleDrag: function handleDrag(e, data) {
                _this.props.dragSubjectSettings(e, d.handleFunction(h, data));
              }
            });
          }));
        }
      }

      var honorFill = FILLABLE.indexOf(this.name) !== -1;
      return _react.default.createElement("g", _extends({
        className: "annotation-subject"
      }, this.props.gAttrs, {
        ref: function ref(subject) {
          _this.subject = subject;
        }
      }), d.components && d.components.map(function (c, i) {
        var attrs = {};
        if (!c) return null;
        Object.keys(c.attrs).forEach(function (k) {
          if (c.attrs[k] && k !== "text") {
            attrs[k.replace(/-([a-z])/g, function (g) {
              return g[1].toUpperCase();
            })] = c.attrs[k];
          }
        });
        return _react.default.createElement(c.type, _extends({
          key: i,
          className: c.className,
          fill: honorFill && fill || "none",
          fillOpacity: honorFill && fillOpacity,
          stroke: color
        }, attrs), c.attrs.text);
      }), handles);
    }
  }]);

  return Subject;
}(_react.default.Component);

exports.default = Subject;
});

unwrapExports(Subject_1);

var SubjectCircle_1 = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireDefault(React$1__default);

var _circle = _interopRequireDefault(circle$1);

var _Subject2 = _interopRequireDefault(Subject_1);

var _propTypes = _interopRequireDefault(propTypes$1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var SubjectCircle =
/*#__PURE__*/
function (_Subject) {
  _inherits(SubjectCircle, _Subject);

  function SubjectCircle() {
    var _getPrototypeOf2;

    var _this;

    _classCallCheck(this, SubjectCircle);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(SubjectCircle)).call.apply(_getPrototypeOf2, [this].concat(args)));

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "name", "SubjectCircle");

    return _this;
  }

  _createClass(SubjectCircle, [{
    key: "getComponents",
    value: function getComponents(_ref) {
      var _ref$radius = _ref.radius,
          radius = _ref$radius === void 0 ? 20 : _ref$radius,
          innerRadius = _ref.innerRadius,
          outerRadius = _ref.outerRadius,
          radiusPadding = _ref.radiusPadding,
          editMode = _ref.editMode;
      var components = (0, _circle.default)({
        radius: radius,
        radiusPadding: radiusPadding,
        innerRadius: innerRadius,
        outerRadius: outerRadius,
        editMode: editMode
      });
      components.handleKeys = {
        radius: radius,
        innerRadius: innerRadius,
        outerRadius: outerRadius
      };

      components.handleFunction = function (h, data) {
        return _defineProperty({}, h.key, components.handleKeys[h.key] + data.oDeltaX * Math.sqrt(2));
      };

      return components;
    }
  }]);

  return SubjectCircle;
}(_Subject2.default);

exports.default = SubjectCircle;
SubjectCircle.propTypes = {
  radius: _propTypes.default.number,
  innerRadius: _propTypes.default.number,
  outerRadius: _propTypes.default.number,
  radiusPadding: _propTypes.default.number,
  editMode: _propTypes.default.bool
};
});

unwrapExports(SubjectCircle_1);

var typeElbow = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});



exports.default = function (_ref) {
  var dx = _ref.dx,
      dy = _ref.dy,
      radius = _ref.radius,
      outerRadius = _ref.outerRadius,
      radiusPadding = _ref.radiusPadding,
      width = _ref.width,
      height = _ref.height;

  var x1 = 0,
      x2 = dx,
      y1 = 0,
      y2 = dy;

  if (width && height) {
    if (width > 0 && dx > 0 || width < 0 && dx < 0) {
      if (Math.abs(width) > Math.abs(dx)) x1 = width / 2;else x1 = width;
    }
    if (height > 0 && dy > 0 || height < 0 && dy < 0) {
      if (Math.abs(height) > Math.abs(dy)) y1 = height / 2;else y1 = height;
    }
    if (x1 === width / 2 && y1 === height / 2) {
      x1 = x2;
      y1 = y2;
    }
  }

  var data = [[x1, y1], [x2, y2]];

  var diffY = y2 - y1;
  var diffX = x2 - x1;
  var xe = x2;
  var ye = y2;
  var opposite = y2 < y1 && x2 > x1 || x2 < x1 && y2 > y1 ? -1 : 1;

  if (Math.abs(diffX) < Math.abs(diffY)) {
    xe = x2;
    ye = y1 + diffX * opposite;
  } else {
    ye = y2;
    xe = x1 + diffY * opposite;
  }

  if (outerRadius || radius) {
    var r = (outerRadius || radius) + (radiusPadding || 0);
    var length = r / Math.sqrt(2);

    if (Math.abs(diffX) > length && Math.abs(diffY) > length) {
      x1 = length * (x2 < 0 ? -1 : 1);
      y1 = length * (y2 < 0 ? -1 : 1);
      data = [[x1, y1], [xe, ye], [x2, y2]];
    } else if (Math.abs(diffX) > Math.abs(diffY)) {
      var angle = Math.asin(-y2 / r);
      x1 = Math.abs(Math.cos(angle) * r) * (x2 < 0 ? -1 : 1);
      data = [[x1, y2], [x2, y2]];
    } else {
      var _angle = Math.acos(x2 / r);
      y1 = Math.abs(Math.sin(_angle) * r) * (y2 < 0 ? -1 : 1);
      data = [[x2, y1], [x2, y2]];
    }
  } else {
    data = [[x1, y1], [xe, ye], [x2, y2]];
  }

  return { components: [(0, Builder.lineBuilder)({ data: data, className: "connector" })] };
};
});

unwrapExports(typeElbow);

var Connector_1 = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireDefault(React$1__default);

var _Handle = _interopRequireDefault(Handle_1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var Connector =
/*#__PURE__*/
function (_React$Component) {
  _inherits(Connector, _React$Component);

  function Connector() {
    _classCallCheck(this, Connector);

    return _possibleConstructorReturn(this, _getPrototypeOf(Connector).apply(this, arguments));
  }

  _createClass(Connector, [{
    key: "getComponents",
    value: function getComponents() {}
  }, {
    key: "render",
    value: function render() {
      var _this = this;

      var _this$props = this.props,
          color = _this$props.color,
          dx = _this$props.dx,
          dy = _this$props.dy,
          customID = _this$props.customID,
          editMode = _this$props.editMode;

      if (dx === 0 && dy === 0) {
        return _react.default.createElement("g", {
          className: "annotation-connector"
        });
      }

      var d = this.getComponents(this.props) || [];
      var cleanedProps = Object.assign({}, this.props);
      delete cleanedProps.children;

      var childrenWithProps = _react.default.Children.map(this.props.children, function (child) {
        return _react.default.cloneElement(child, _objectSpread({}, cleanedProps, child.props, {
          scale: cleanedProps.endScale || child.props.endScale,
          lineData: d.components[0].data
        }));
      });

      var handles;

      if (editMode && d.handles && d.handles.length > 0) {
        handles = d.handles.map(function (h, i) {
          return _react.default.createElement(_Handle.default, {
            key: "connectorhandle-".concat(i),
            handleStart: _this.props.dragStart,
            handleStop: _this.props.dragEnd,
            x: h.x,
            y: h.y,
            offsetParent: h.offsetParent && _this.connector,
            handleDrag: function handleDrag(e, data) {
              _this.props.dragConnectorSettings(e, d.handleFunction(h, data));
            }
          });
        });
      }

      return _react.default.createElement("g", _extends({
        className: "annotation-connector"
      }, this.props.gAttrs), d.components && d.components.map(function (c, i) {
        var attrs = {};
        if (!c) return null;
        Object.keys(c.attrs).forEach(function (k) {
          if (c.attrs[k] && k !== "text") {
            attrs[k.replace(/-([a-z])/g, function (g) {
              return g[1].toUpperCase();
            })] = c.attrs[k];
          }
        });
        return _react.default.createElement(c.type, _extends({
          mask: customID ? "url(#".concat(customID, ")") : undefined,
          key: i,
          className: c.className,
          fill: "none",
          stroke: color
        }, attrs), c.attrs.text);
      }), childrenWithProps, handles);
    }
  }]);

  return Connector;
}(_react.default.Component);

exports.default = Connector;
});

unwrapExports(Connector_1);

var ConnectorElbow_1 = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireDefault(React$1__default);

var _typeElbow = _interopRequireDefault(typeElbow);

var _Connector2 = _interopRequireDefault(Connector_1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var ConnectorElbow =
/*#__PURE__*/
function (_Connector) {
  _inherits(ConnectorElbow, _Connector);

  function ConnectorElbow() {
    _classCallCheck(this, ConnectorElbow);

    return _possibleConstructorReturn(this, _getPrototypeOf(ConnectorElbow).apply(this, arguments));
  }

  _createClass(ConnectorElbow, [{
    key: "getComponents",
    value: function getComponents(_ref) {
      var x = _ref.x,
          y = _ref.y,
          dy = _ref.dy,
          dx = _ref.dx,
          radius = _ref.radius,
          radiusPadding = _ref.radiusPadding,
          outerRadius = _ref.outerRadius,
          width = _ref.width,
          height = _ref.height;
      return (0, _typeElbow.default)({
        x: x,
        y: y,
        dx: dx,
        dy: dy,
        radius: radius,
        radiusPadding: radiusPadding,
        outerRadius: outerRadius,
        width: width,
        height: height
      });
    }
  }]);

  return ConnectorElbow;
}(_Connector2.default);

exports.default = ConnectorElbow;
});

unwrapExports(ConnectorElbow_1);

var classnames = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _default = function _default() {
  for (var _len = arguments.length, params = new Array(_len), _key = 0; _key < _len; _key++) {
    params[_key] = arguments[_key];
  }

  return params.filter(function (d) {
    return d;
  }).join(" ").trim();
};

exports.default = _default;
});

unwrapExports(classnames);

var Annotation_1 = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireDefault(React$1__default);

var _classnames = _interopRequireDefault(classnames);

var _propTypes = _interopRequireDefault(propTypes$1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var Annotation =
/*#__PURE__*/
function (_React$Component) {
  _inherits(Annotation, _React$Component);

  function Annotation() {
    _classCallCheck(this, Annotation);

    return _possibleConstructorReturn(this, _getPrototypeOf(Annotation).apply(this, arguments));
  }

  _createClass(Annotation, [{
    key: "render",
    value: function render() {
      var _this = this;

      var _this$props = this.props,
          x = _this$props.x,
          y = _this$props.y,
          nx = _this$props.nx,
          ny = _this$props.ny,
          events = _this$props.events;
      var cleanedProps = Object.assign({}, this.props);
      delete cleanedProps.children;
      var cleanedWithoutEvents = Object.assign({}, cleanedProps);
      delete cleanedWithoutEvents.events;
      if (nx !== undefined) cleanedProps.dx = nx - x;
      if (ny !== undefined) cleanedProps.dy = ny - y;

      var childrenWithProps = _react.default.Children.toArray(this.props.children).map(function (child) {
        return _react.default.cloneElement(child, _objectSpread({}, typeof child.type === "string" ? cleanedWithoutEvents : cleanedProps, child.props));
      });

      var wrappedEvents = {};
      Object.keys(events).forEach(function (k) {
        wrappedEvents[k] = function (e) {
          events[k](_this.props, _this.state, e);
        };
      });
      return _react.default.createElement("g", _extends({
        className: (0, _classnames.default)("annotation", this.props.className),
        transform: "translate(".concat(x, ", ").concat(y, ")")
      }, wrappedEvents), childrenWithProps);
    }
  }]);

  return Annotation;
}(_react.default.Component);

exports.default = Annotation;
Annotation.defaultProps = {
  x: 0,
  y: 0,
  dx: 0,
  dy: 0,
  color: "grey",
  events: {}
};
Annotation.propTypes = {
  x: _propTypes.default.number,
  y: _propTypes.default.number,
  dx: _propTypes.default.number,
  dy: _propTypes.default.number,
  color: _propTypes.default.string,
  editMode: _propTypes.default.bool,
  events: _propTypes.default.object
};
});

unwrapExports(Annotation_1);

var EditableAnnotation_1 = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireDefault(React$1__default);

var _Annotation = _interopRequireDefault(Annotation_1);

var _classnames = _interopRequireDefault(classnames);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var EditableAnnotation =
/*#__PURE__*/
function (_React$Component) {
  _inherits(EditableAnnotation, _React$Component);

  function EditableAnnotation() {
    var _getPrototypeOf2;

    var _this;

    _classCallCheck(this, EditableAnnotation);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(EditableAnnotation)).call.apply(_getPrototypeOf2, [this].concat(args)));

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "state", {
      x: 0,
      y: 0,
      dx: 0,
      dy: 0
    });

    return _this;
  }

  _createClass(EditableAnnotation, [{
    key: "componentWillMount",
    value: function componentWillMount() {
      this.setState({
        x: this.props.x,
        y: this.props.y,
        dx: this.props.dx,
        dy: this.props.dy
      });
    }
  }, {
    key: "componentWillReceiveProps",
    value: function componentWillReceiveProps(nextProps) {
      this.setState({
        x: nextProps.x,
        y: nextProps.y,
        dx: nextProps.dx,
        dy: nextProps.dy
      });
    }
  }, {
    key: "getData",
    value: function getData() {
      return Object.assign({}, this.props, this.state);
    }
  }, {
    key: "dragEnd",
    value: function dragEnd() {
      if (this.props.onDragEnd) {
        this.props.onDragEnd(this.getData());
      }
    }
  }, {
    key: "dragStart",
    value: function dragStart() {
      if (this.props.onDragStart) {
        this.props.onDragStart(this.getData());
      }
    }
  }, {
    key: "dragSubject",
    value: function dragSubject(event, data) {
      var _this2 = this;

      this.setState({
        x: this.state.x + data.deltaX,
        y: this.state.y + data.deltaY
      }, function () {
        if (_this2.props.onDrag) _this2.props.onDrag(_this2.getData());
      });
    }
  }, {
    key: "dragConnectorSettings",
    value: function dragConnectorSettings(event, data) {
      var _this3 = this;

      this.setState(data, function () {
        if (_this3.props.onDrag) _this3.props.onDrag(_this3.getData());
      });
    }
  }, {
    key: "dragSubjectSettings",
    value: function dragSubjectSettings(event, data) {
      var _this4 = this;

      this.setState(data, function () {
        if (_this4.props.onDrag) _this4.props.onDrag(_this4.getData());
      });
    }
  }, {
    key: "dragNote",
    value: function dragNote(event, data) {
      var _this5 = this;

      this.setState({
        dx: this.state.dx + data.deltaX,
        dy: this.state.dy + data.deltaY
      }, function () {
        if (_this5.props.onDrag) _this5.props.onDrag(_this5.getData());
      });
    }
  }, {
    key: "render",
    value: function render() {
      var cleanedProps = Object.assign({}, this.props, _objectSpread({}, this.state, {
        dragSubject: this.dragSubject.bind(this),
        dragNote: this.dragNote.bind(this),
        dragSubjectSettings: this.dragSubjectSettings.bind(this),
        dragConnectorSettings: this.dragConnectorSettings.bind(this),
        dragEnd: this.dragEnd.bind(this),
        dragStart: this.dragStart.bind(this),
        editMode: true,
        className: (0, _classnames.default)(this.props.className, "editable")
      }));
      return _react.default.createElement(_Annotation.default, cleanedProps);
    }
  }]);

  return EditableAnnotation;
}(_react.default.Component);

exports.default = EditableAnnotation;
});

unwrapExports(EditableAnnotation_1);

var typeLine = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.lineSetup = undefined;



var lineSetup = exports.lineSetup = function lineSetup(_ref) {
  var dx = _ref.dx,
      dy = _ref.dy,
      radius = _ref.radius,
      outerRadius = _ref.outerRadius,
      radiusPadding = _ref.radiusPadding,
      width = _ref.width,
      height = _ref.height;

  var x1 = 0,
      x2 = dx,
      y1 = 0,
      y2 = dy;

  if (outerRadius || radius) {
    var h = Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
    var angle = Math.asin(-y2 / h);
    var r = (outerRadius || radius) + (radiusPadding || 0);

    x1 = Math.abs(Math.cos(angle) * r) * (x2 < 0 ? -1 : 1);
    y1 = Math.abs(Math.sin(angle) * r) * (y2 < 0 ? -1 : 1);
  }

  if (width && height) {
    if (width > 0 && dx > 0 || width < 0 && dx < 0) {
      if (Math.abs(width) > Math.abs(dx)) x1 = width / 2;else x1 = width;
    }
    if (height > 0 && dy > 0 || height < 0 && dy < 0) {
      if (Math.abs(height) > Math.abs(dy)) y1 = height / 2;else y1 = height;
    }
    if (x1 === width / 2 && y1 === height / 2) {
      x1 = x2;
      y1 = y2;
    }
  }

  return [[x1, y1], [x2, y2]];
};

exports.default = function (connectorData) {
  var data = lineSetup(connectorData);
  return { components: [(0, Builder.lineBuilder)({ data: data, className: "connector" })] };
};
});

unwrapExports(typeLine);
var typeLine_1 = typeLine.lineSetup;

var ConnectorLine_1 = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireDefault(React$1__default);

var _typeLine = _interopRequireDefault(typeLine);

var _Connector2 = _interopRequireDefault(Connector_1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var ConnectorLine =
/*#__PURE__*/
function (_Connector) {
  _inherits(ConnectorLine, _Connector);

  function ConnectorLine() {
    _classCallCheck(this, ConnectorLine);

    return _possibleConstructorReturn(this, _getPrototypeOf(ConnectorLine).apply(this, arguments));
  }

  _createClass(ConnectorLine, [{
    key: "getComponents",
    value: function getComponents(_ref) {
      var x = _ref.x,
          y = _ref.y,
          dy = _ref.dy,
          dx = _ref.dx,
          radius = _ref.radius,
          outerRadius = _ref.outerRadius,
          width = _ref.width,
          height = _ref.height;
      return (0, _typeLine.default)({
        x: x,
        y: y,
        dx: dx,
        dy: dy,
        radius: radius,
        outerRadius: outerRadius,
        width: width,
        height: height
      });
    }
  }]);

  return ConnectorLine;
}(_Connector2.default);

exports.default = ConnectorLine;
});

unwrapExports(ConnectorLine_1);

var typeCurve = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});







function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var createPoints = function createPoints(offset) {
  var anchors = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;

  var diff = { x: offset.x / (anchors + 1), y: offset.y / (anchors + 1) };
  var p = [];

  var i = 1;
  for (; i <= anchors; i++) {
    p.push([diff.x * i + i % 2 * 20, diff.y * i - i % 2 * 20]);
  }
  return p;
};

exports.default = function (_ref) {
  var curve = _ref.curve,
      points = _ref.points,
      x = _ref.x,
      y = _ref.y,
      dx = _ref.dx,
      dy = _ref.dy,
      radius = _ref.radius,
      outerRadius = _ref.outerRadius,
      width = _ref.width,
      height = _ref.height,
      editMode = _ref.editMode;

  if (!points || typeof points === "number") {
    points = createPoints({ x: dx, y: dy }, points);
  }
  if (!curve) {
    curve = d3Shape.curveCatmullRom;
  }

  var handles = [];

  if (editMode) {
    handles = points.map(function (c, i) {
      return { index: i, x: c[0], y: c[1] };
    });
  }

  var data = (0, typeLine.lineSetup)({ x: x, y: y, dx: dx, dy: dy, radius: radius, outerRadius: outerRadius, width: width, height: height });
  data = [data[0]].concat(_toConsumableArray(points), [data[1]]);
  var components = [(0, Builder.lineBuilder)({ data: data, curve: curve, className: "connector" })];

  return { components: components, handles: handles, points: points };
};
});

unwrapExports(typeCurve);

var ConnectorCurve_1 = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _typeCurve = _interopRequireDefault(typeCurve);

var _Connector2 = _interopRequireDefault(Connector_1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var ConnectorCurve =
/*#__PURE__*/
function (_Connector) {
  _inherits(ConnectorCurve, _Connector);

  function ConnectorCurve() {
    _classCallCheck(this, ConnectorCurve);

    return _possibleConstructorReturn(this, _getPrototypeOf(ConnectorCurve).apply(this, arguments));
  }

  _createClass(ConnectorCurve, [{
    key: "getComponents",
    value: function getComponents(_ref) {
      var curve = _ref.curve,
          points = _ref.points,
          x = _ref.x,
          y = _ref.y,
          dx = _ref.dx,
          dy = _ref.dy,
          radius = _ref.radius,
          outerRadius = _ref.outerRadius,
          width = _ref.width,
          height = _ref.height,
          editMode = _ref.editMode;
      var components = (0, _typeCurve.default)({
        curve: curve,
        points: points,
        x: x,
        y: y,
        dx: dx,
        dy: dy,
        radius: radius,
        outerRadius: outerRadius,
        width: width,
        height: height,
        editMode: editMode
      });
      components.handleKeys = {
        points: components.handles
      };

      components.handleFunction = function (h, data) {
        var p = components.points.slice(0);
        p[h.HospitalFacilities] = [h.x + data.oDeltaX, h.y + data.oDeltaY];
        return {
          points: p
        };
      };

      return components;
    }
  }]);

  return ConnectorCurve;
}(_Connector2.default);

exports.default = ConnectorCurve;
});

unwrapExports(ConnectorCurve_1);

var endDot = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});



exports.default = function (_ref) {
  var lineData = _ref.lineData,
      _ref$scale = _ref.scale,
      scale = _ref$scale === undefined ? 1 : _ref$scale;

  var dot = (0, Builder.arcBuilder)({
    className: "connector-end connector-dot",
    classID: "connector-end",
    data: { radius: 3 * Math.sqrt(scale) }
  });
  dot.attrs.transform = "translate(" + lineData[0][0] + ", " + lineData[0][1] + ")";

  return { components: [dot] };
};
});

unwrapExports(endDot);

var ConnectorEnd_1 = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireDefault(React$1__default);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var ConnectorEnd =
/*#__PURE__*/
function (_React$Component) {
  _inherits(ConnectorEnd, _React$Component);

  function ConnectorEnd() {
    _classCallCheck(this, ConnectorEnd);

    return _possibleConstructorReturn(this, _getPrototypeOf(ConnectorEnd).apply(this, arguments));
  }

  _createClass(ConnectorEnd, [{
    key: "getComponents",
    value: function getComponents() {}
  }, {
    key: "render",
    value: function render() {
      var color = this.props.color;
      var d = this.getComponents(this.props) || [];
      var c = d.components[0];
      return _react.default.createElement(c.type, _extends({
        className: c.className
      }, c.attrs, {
        fill: color
      }));
    }
  }]);

  return ConnectorEnd;
}(_react.default.Component);

exports.default = ConnectorEnd;
});

unwrapExports(ConnectorEnd_1);

var ConnectorEndDot_1 = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireDefault(React$1__default);

var _endDot = _interopRequireDefault(endDot);

var _ConnectorEnd2 = _interopRequireDefault(ConnectorEnd_1);

var _propTypes = _interopRequireDefault(propTypes$1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var ConnectorEndDot =
/*#__PURE__*/
function (_ConnectorEnd) {
  _inherits(ConnectorEndDot, _ConnectorEnd);

  function ConnectorEndDot() {
    _classCallCheck(this, ConnectorEndDot);

    return _possibleConstructorReturn(this, _getPrototypeOf(ConnectorEndDot).apply(this, arguments));
  }

  _createClass(ConnectorEndDot, [{
    key: "getComponents",
    value: function getComponents(_ref) {
      var x = _ref.x,
          y = _ref.y,
          dy = _ref.dy,
          dx = _ref.dx,
          lineData = _ref.lineData,
          scale = _ref.scale;
      return (0, _endDot.default)({
        x: x,
        y: y,
        dx: dx,
        dy: dy,
        lineData: lineData,
        scale: scale
      });
    }
  }]);

  return ConnectorEndDot;
}(_ConnectorEnd2.default);

exports.default = ConnectorEndDot;
ConnectorEndDot.propTypes = {
  x: _propTypes.default.number,
  y: _propTypes.default.number,
  dx: _propTypes.default.number,
  dy: _propTypes.default.number,
  scale: _propTypes.default.number,
  lineData: _propTypes.default.array //array of arrays of x,y coordinates for the connector line

};
});

unwrapExports(ConnectorEndDot_1);

var endArrow = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});



exports.default = function (_ref) {
  var dx = _ref.dx,
      dy = _ref.dy,
      start = _ref.start,
      end = _ref.end,
      _ref$scale = _ref.scale,
      scale = _ref$scale === undefined ? 1 : _ref$scale;

  if (!start) {
    start = [dx, dy];
  } else {
    start = [-end[0] + start[0], -end[1] + start[1]];
  }
  if (!end) {
    end = [0, 0];
  }

  var x1 = end[0],
      y1 = end[1];

  var size = 10 * scale;
  var angleOffset = 16 / 180 * Math.PI;
  var angle = Math.atan(start[1] / start[0]);

  if (start[0] < 0) {
    angle += Math.PI;
  }

  var data = [[x1, y1], [Math.cos(angle + angleOffset) * size + x1, Math.sin(angle + angleOffset) * size + y1], [Math.cos(angle - angleOffset) * size + x1, Math.sin(angle - angleOffset) * size + y1], [x1, y1]];

  //TODO add in reverse
  // if (canvasContext.arrowReverse){
  //   data = [[x1, y1],
  //   [Math.cos(angle + angleOffset)*size, Math.sin(angle + angleOffset)*size],
  //   [Math.cos(angle - angleOffset)*size, Math.sin(angle - angleOffset)*size],
  //   [x1, y1]
  //   ]
  // } else {
  //   data = [[x1, y1],
  //   [Math.cos(angle + angleOffset)*size, Math.sin(angle + angleOffset)*size],
  //   [Math.cos(angle - angleOffset)*size, Math.sin(angle - angleOffset)*size],
  //   [x1, y1]
  //   ]
  // }

  return {
    components: [(0, Builder.lineBuilder)({
      data: data,
      className: "connector-end connector-arrow",
      classID: "connector-end"
    })]
  };
};
});

unwrapExports(endArrow);

var ConnectorEndArrow_1 = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireDefault(React$1__default);

var _endArrow = _interopRequireDefault(endArrow);

var _ConnectorEnd2 = _interopRequireDefault(ConnectorEnd_1);

var _propTypes = _interopRequireDefault(propTypes$1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var ConnectorEndArrow =
/*#__PURE__*/
function (_ConnectorEnd) {
  _inherits(ConnectorEndArrow, _ConnectorEnd);

  function ConnectorEndArrow() {
    _classCallCheck(this, ConnectorEndArrow);

    return _possibleConstructorReturn(this, _getPrototypeOf(ConnectorEndArrow).apply(this, arguments));
  }

  _createClass(ConnectorEndArrow, [{
    key: "getComponents",
    value: function getComponents(_ref) {
      var x = _ref.x,
          y = _ref.y,
          dy = _ref.dy,
          dx = _ref.dx,
          lineData = _ref.lineData,
          scale = _ref.scale;
      var start = lineData[1];
      var end = lineData[0];
      var distance = Math.sqrt(Math.pow(start[0] - end[0], 2) + Math.pow(start[1] - end[1], 2));

      if (distance < 5 && lineData[2]) {
        start = lineData[2];
      }

      return (0, _endArrow.default)({
        x: x,
        y: y,
        dx: dx,
        dy: dy,
        start: start,
        end: end,
        scale: scale
      });
    }
  }]);

  return ConnectorEndArrow;
}(_ConnectorEnd2.default);

exports.default = ConnectorEndArrow;
ConnectorEndArrow.propTypes = {
  x: _propTypes.default.number,
  y: _propTypes.default.number,
  dx: _propTypes.default.number,
  dy: _propTypes.default.number,
  scale: _propTypes.default.number,
  lineData: _propTypes.default.array
};
});

unwrapExports(ConnectorEndArrow_1);

var alignment = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
var leftRightDynamic = exports.leftRightDynamic = function leftRightDynamic(align, y) {
  if (!align || align === "dynamic" || align === "left" || align === "right") {
    if (y < 0) {
      align = "top";
    } else {
      align = "bottom";
    }
  }
  return align;
};

var topBottomDynamic = exports.topBottomDynamic = function topBottomDynamic(align, x) {
  if (!align || align === "dynamic" || align === "top" || align === "bottom") {
    if (x < 0) {
      align = "right";
    } else {
      align = "left";
    }
  }
  return align;
};

var orientationTopBottom = ["topBottom", "top", "bottom"];
var orientationLeftRight = ["leftRight", "left", "right"];

exports.default = function (_ref) {
  var _ref$padding = _ref.padding,
      padding = _ref$padding === undefined ? 0 : _ref$padding,
      _ref$bbox = _ref.bbox,
      bbox = _ref$bbox === undefined ? { x: 0, y: 0, width: 0, height: 0 } : _ref$bbox,
      align = _ref.align,
      orientation = _ref.orientation,
      _ref$offset = _ref.offset,
      offset = _ref$offset === undefined ? { x: 0, y: 0 } : _ref$offset;

  var x = -bbox.x;
  var y = -bbox.y;
  if (orientationTopBottom.indexOf(orientation) !== -1) {
    align = topBottomDynamic(align, offset.x);
    if (offset.y < 0 && orientation === "topBottom" || orientation === "top") {
      y -= bbox.height + padding;
    } else {
      y += padding;
    }

    if (align === "middle") {
      x -= bbox.width / 2;
    } else if (align === "right") {
      x -= bbox.width;
    }
  } else if (orientationLeftRight.indexOf(orientation) !== -1) {
    align = leftRightDynamic(align, offset.y);
    if (offset.x < 0 && orientation === "leftRight" || orientation === "left") {
      x -= bbox.width + padding;
    } else {
      x += padding;
    }

    if (align === "middle") {
      y -= bbox.height / 2;
    } else if (align === "top") {
      y -= bbox.height;
    }
  }

  return { x: x, y: y };
};
});

unwrapExports(alignment);
var alignment_1 = alignment.leftRightDynamic;
var alignment_2 = alignment.topBottomDynamic;

var lineTypeVertical = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});





exports.default = function (_ref) {
  var align = _ref.align,
      _ref$x = _ref.x,
      x = _ref$x === undefined ? 0 : _ref$x,
      _ref$y = _ref.y,
      y = _ref$y === undefined ? 0 : _ref$y,
      bbox = _ref.bbox,
      offset = _ref.offset;

  align = (0, alignment.leftRightDynamic)(align, offset.y);

  if (align === "top") {
    y -= bbox.height;
  } else if (align === "middle") {
    y -= bbox.height / 2;
  }

  var data = [[x, y], [x, y + bbox.height]];
  return { components: [(0, Builder.lineBuilder)({ data: data, className: "note-line" })] };
};
});

unwrapExports(lineTypeVertical);

var lineTypeHorizontal = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});





exports.default = function (_ref) {
  var align = _ref.align,
      _ref$x = _ref.x,
      x = _ref$x === undefined ? 0 : _ref$x,
      _ref$y = _ref.y,
      y = _ref$y === undefined ? 0 : _ref$y,
      offset = _ref.offset,
      bbox = _ref.bbox;

  align = (0, alignment.topBottomDynamic)(align, offset.x);

  if (align === "right") {
    x -= bbox.width;
  } else if (align === "middle") {
    x -= bbox.width / 2;
  }

  var data = [[x, y], [x + bbox.width, y]];
  return { components: [(0, Builder.lineBuilder)({ data: data, className: "note-line" })] };
};
});

unwrapExports(lineTypeHorizontal);

var Note_1 = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireDefault(React$1__default);

var _alignment4 = _interopRequireDefault(alignment);

var _Handle = _interopRequireDefault(Handle_1);

var _lineTypeVertical = _interopRequireDefault(lineTypeVertical);

var _lineTypeHorizontal = _interopRequireDefault(lineTypeHorizontal);

var _propTypes = _interopRequireDefault(propTypes$1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var getOuterBBox = function getOuterBBox() {
  for (var _len = arguments.length, domNodes = new Array(_len), _key = 0; _key < _len; _key++) {
    domNodes[_key] = arguments[_key];
  }

  return domNodes.concat().reduce(function (p, c) {
    if (c) {
      var bbox = c.getBBox();
      p.x = Math.min(p.x, bbox.x);
      p.y = Math.min(p.y, bbox.y);
      p.width = Math.max(p.width, bbox.width);
      var yOffset = c && c.attributes && c.attributes.y;
      p.height = Math.max(p.height, (yOffset && parseFloat(yOffset.value) || 0) + bbox.height);
    }

    return p;
  }, {
    x: 0,
    y: 0,
    width: 0,
    height: 0
  });
};

var Note =
/*#__PURE__*/
function (_React$Component) {
  _inherits(Note, _React$Component);

  function Note(props) {
    var _this;

    _classCallCheck(this, Note);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Note).call(this, props));

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "state", {
      translateX: 0,
      translateY: 0,
      labelOffset: 0,
      changed: 0,
      bbox: {
        width: 0,
        height: 0,
        x: 0,
        y: 0
      }
    });

    _this.updateText = _this.updateText.bind(_assertThisInitialized(_assertThisInitialized(_this))); // this.note = React.createRef()
    // this.title = React.createRef()
    // this.label = React.createRef()

    return _this;
  }

  _createClass(Note, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this.updateText(this.props);
    }
  }, {
    key: "componentWillReceiveProps",
    value: function componentWillReceiveProps(nextProps) {
      if (nextProps.title !== this.props.title || nextProps.label !== this.props.label || nextProps.wrap !== this.props.wrap) {
        this.updateText(nextProps);
      }

      if (nextProps.editMode && (nextProps.align === "dynamic" || !nextProps.align)) {
        this.updateText(nextProps);
      }
    }
  }, {
    key: "updateText",
    value: function updateText(_ref) {
      var _this2 = this;

      var orientation = _ref.orientation,
          padding = _ref.padding,
          align = _ref.align,
          lineType = _ref.lineType,
          label = _ref.label,
          title = _ref.title,
          wrap = _ref.wrap,
          wrapSplitter = _ref.wrapSplitter,
          dx = _ref.dx,
          dy = _ref.dy;
      var newState = {
        titleWrapped: null,
        labelWrapped: null
      };
      newState.changed = this.state.changed + 1;

      if (title) {
        newState.titleWrapped = this.title && this.wrapText(this.title, newState.changed, title, wrap, wrapSplitter);
      }

      if (label) newState.labelWrapped = this.label && this.wrapText(this.label, newState.changed, label, wrap, wrapSplitter);
      this.setState(newState, function () {
        var setLabel = function setLabel() {
          var bbox = getOuterBBox(_this2.title, _this2.label);
          var noteParams = {
            padding: padding,
            bbox: bbox,
            offset: {
              x: dx,
              y: dy
            },
            orientation: orientation,
            align: align
          };
          if (lineType === "vertical") noteParams.orientation = "leftRight";else if (lineType === "horizontal") noteParams.orientation = "topBottom";

          var _alignment = (0, _alignment4.default)(noteParams),
              x = _alignment.x,
              y = _alignment.y;

          _this2.setState({
            translateX: x,
            translateY: y,
            bbox: bbox
          });
        };

        _this2.setState({
          labelOffset: title && _this2.title.getBBox().height || 0
        }, setLabel);
      });
    }
  }, {
    key: "wrapText",
    value: function wrapText(textRef, key, text, width, wrapSplitter) {
      var initialAttrs = {
        x: 0,
        dy: "1.2em"
      };
      var words = text.split(wrapSplitter || /[ \t\r\n]+/).reverse().filter(function (w) {
        return w !== "";
      });
      var word,
          line = [];
      var tspans = [];

      while (word = words.pop()) {
        line.push(word);
        textRef.lastChild.textContent = line.join(" ");
        var length = textRef.lastChild.getComputedTextLength();
        textRef.lastChild.textContent = "";

        if (length > width && line.length > 1) {
          line.pop();
          tspans.push(_react.default.createElement("tspan", _extends({
            key: tspans.length + text
          }, initialAttrs), line.join(" ")));
          line = [word];
        }
      }

      if (line.length !== 0) {
        tspans.push(_react.default.createElement("tspan", _extends({
          key: tspans.length + text
        }, initialAttrs), line.join(" ")));
      }

      return _react.default.createElement("tspan", _extends({}, initialAttrs, {
        key: key + text
      }), tspans);
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      var _this$props = this.props,
          orientation = _this$props.orientation,
          padding = _this$props.padding,
          align = _this$props.align,
          dx = _this$props.dx,
          dy = _this$props.dy,
          lineType = _this$props.lineType;

      if (this.state.bbox.width && (prevProps.dx !== this.props.dx || prevProps.dy !== this.props.dy) && (this.title || this.label)) {
        var bbox = getOuterBBox(this.title, this.label);
        var noteParams = {
          padding: padding,
          bbox: bbox,
          offset: {
            x: dx,
            y: dy
          },
          orientation: orientation,
          align: align
        };
        if (lineType === "vertical") noteParams.orientation = "leftRight";else if (lineType === "horizontal") noteParams.orientation = "topBottom";

        var _alignment2 = (0, _alignment4.default)(noteParams),
            x = _alignment2.x,
            y = _alignment2.y;

        var updates = {
          bbox: bbox
        };
        if (this.state.translateX !== x) updates.translateX = x;
        if (this.state.translateY !== y) updates.translateY = y;

        if (updates.translateX !== undefined || updates.translateY !== undefined) {
          this.setState(updates);
        }
      } else if (this.state.align !== prevProps.align || this.props.orientation !== prevProps.orientation || this.props.padding !== prevProps.padding) {
        var _noteParams = {
          padding: padding,
          bbox: this.state.bbox,
          offset: {
            x: dx,
            y: dy
          },
          orientation: orientation,
          align: align
        };
        if (lineType === "vertical") _noteParams.orientation = "leftRight";else if (lineType === "horizontal") _noteParams.orientation = "topBottom";

        var _alignment3 = (0, _alignment4.default)(_noteParams),
            _x = _alignment3.x,
            _y = _alignment3.y;

        var _updates = {};
        if (this.state.translateX !== _x) _updates.translateX = _x;
        if (this.state.translateY !== _y) _updates.translateY = _y;

        if (_updates.translateX !== undefined || _updates.translateY !== undefined) {
          this.setState(_updates);
        }
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _this3 = this;

      var _this$props2 = this.props,
          dx = _this$props2.dx,
          dy = _this$props2.dy,
          title = _this$props2.title,
          label = _this$props2.label,
          align = _this$props2.align,
          editMode = _this$props2.editMode,
          lineType = _this$props2.lineType,
          color = _this$props2.color,
          titleColor = _this$props2.titleColor,
          labelColor = _this$props2.labelColor,
          bgPadding = _this$props2.bgPadding;
      var bgPaddingFinal = {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0
      };

      if (typeof bgPadding === "number") {
        bgPaddingFinal = {
          top: bgPadding,
          bottom: bgPadding,
          left: bgPadding,
          right: bgPadding
        };
      } else if (bgPadding && _typeof(bgPadding) === "object") {
        bgPaddingFinal = Object.assign(bgPaddingFinal, bgPadding);
      }

      var noteTitle, noteText, noteLineType;

      if (title) {
        noteTitle = _react.default.createElement("text", {
          ref: function ref(el) {
            return _this3.title = el;
          },
          className: "annotation-note-title",
          fontWeight: "bold",
          key: "title",
          fill: titleColor || color
        }, this.state.titleWrapped || _react.default.createElement("tspan", {
          x: 0,
          dy: ".8em"
        }, title));
      }

      if (label) {
        noteText = _react.default.createElement("text", {
          ref: function ref(el) {
            return _this3.label = el;
          },
          className: "annotation-note-label",
          y: this.state.labelOffset * 1.1,
          key: "label",
          fill: labelColor || color
        }, this.state.labelWrapped || _react.default.createElement("tspan", {
          x: 0,
          dy: ".8em"
        }, label));
      }

      if (lineType && this.state.bbox.width) {
        var noteParams = {
          bbox: this.state.bbox,
          align: align,
          offset: {
            x: dx,
            y: dy
          }
        };
        var noteComponent = (lineType === "vertical" && (0, _lineTypeVertical.default)(noteParams) || lineType === "horizontal" && (0, _lineTypeHorizontal.default)(noteParams)).components[0];
        noteLineType = _react.default.createElement(noteComponent.type, _extends({
          className: noteComponent.className
        }, noteComponent.attrs, {
          stroke: color
        }));
      }

      var handle;

      if (editMode) {
        handle = _react.default.createElement(_Handle.default, {
          handleStart: this.props.dragStart,
          handleStop: this.props.dragEnd,
          handleDrag: this.props.dragNote
        });
      }

      return _react.default.createElement("g", _extends({
        transform: "translate(".concat(dx, ", ").concat(dy, ")"),
        className: "annotation-note"
      }, this.props.gProps), _react.default.createElement("g", {
        className: "annotation-note-content",
        transform: "translate(".concat(this.state.translateX, ",\n          ").concat(this.state.translateY, ")"),
        ref: function ref(el) {
          return _this3.note = el;
        }
      }, _react.default.createElement("rect", {
        className: "annotation-note-bg",
        width: this.state.bbox.width + bgPaddingFinal.left + bgPaddingFinal.right,
        x: -bgPaddingFinal.left,
        y: -bgPaddingFinal.top,
        height: this.state.bbox.height + bgPaddingFinal.top + bgPaddingFinal.bottom,
        stroke: "none",
        fill: "white",
        fillOpacity: "0"
      }), noteTitle, noteText), noteLineType, handle);
    }
  }]);

  return Note;
}(_react.default.Component);

exports.default = Note;
Note.defaultProps = {
  wrap: 120,
  align: "dynamic",
  orientation: "topBottom",
  padding: 3
};
Note.propTypes = {
  dx: _propTypes.default.number,
  dy: _propTypes.default.number,
  title: _propTypes.default.string,
  label: _propTypes.default.string,
  orientation: _propTypes.default.oneOf(["leftRight", "topBottom"]),
  padding: _propTypes.default.number,
  bgPadding: _propTypes.default.oneOfType([_propTypes.default.number, _propTypes.default.object]),
  align: _propTypes.default.oneOf(["left", "right", "middle", "top", "bottom", "dynamic"]),
  editMode: _propTypes.default.bool,
  lineType: _propTypes.default.oneOf(["vertical", "horizontal"]),
  color: _propTypes.default.string,
  titleColor: _propTypes.default.string,
  labelColor: _propTypes.default.string
};
});

unwrapExports(Note_1);

var JSXNote_1 = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = JSXNote;

var _react = _interopRequireDefault(React$1__default);

var _Handle = _interopRequireDefault(Handle_1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint-disable no-unused-vars */

/* eslint-enable no-unused-vars */
function JSXNote(props) {
  var note = props.note,
      dx = props.dx,
      dy = props.dy,
      editMode = props.editMode,
      dragStart = props.dragStart,
      dragEnd = props.dragEnd,
      dragNote = props.dragNote;
  var handle;

  if (editMode) {
    handle = _react.default.createElement(_Handle.default, {
      handleStart: dragStart,
      handleStop: dragEnd,
      handleDrag: dragNote
    });
  }

  return _react.default.createElement("g", {
    className: "annotation-note",
    transform: "translate(".concat(dx, ", ").concat(dy, ")")
  }, typeof note === "function" ? note(props) : note, handle);
}
});

unwrapExports(JSXNote_1);

var Type = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _react = _interopRequireDefault(React$1__default);

var _Annotation = _interopRequireDefault(Annotation_1);

var _EditableAnnotation = _interopRequireDefault(EditableAnnotation_1);

var _ConnectorLine = _interopRequireDefault(ConnectorLine_1);

var _ConnectorElbow = _interopRequireDefault(ConnectorElbow_1);

var _ConnectorCurve = _interopRequireDefault(ConnectorCurve_1);

var _ConnectorEndDot = _interopRequireDefault(ConnectorEndDot_1);

var _ConnectorEndArrow = _interopRequireDefault(ConnectorEndArrow_1);

var _Subject = _interopRequireDefault(Subject_1);

var _Note = _interopRequireDefault(Note_1);

var _JSXNote = _interopRequireDefault(JSXNote_1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var getAnnotationType = function getAnnotationType(editMode) {
  return editMode ? _EditableAnnotation.default : _Annotation.default;
};

function _default(props, Connector) {
  var NoteDefaultProps = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var Subject = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : _Subject.default;
  var SubjectDefaultProps = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};
  var NoteType = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : _Note.default;
  var _props$disable = props.disable,
      disable = _props$disable === void 0 ? [] : _props$disable,
      connector = props.connector,
      note = props.note,
      subject = props.subject,
      x = props.x,
      y = props.y,
      dx = props.dx,
      dy = props.dy,
      nx = props.nx,
      ny = props.ny,
      color = props.color,
      className = props.className,
      onDrag = props.onDrag,
      onDragStart = props.onDragStart,
      onDragEnd = props.onDragEnd,
      editMode = props.editMode,
      events = props.events;
  var CONNECTORS = {
    type: {
      curve: _ConnectorCurve.default,
      line: _ConnectorLine.default,
      elbow: _ConnectorElbow.default
    },
    end: {
      dot: _ConnectorEndDot.default,
      arrow: _ConnectorEndArrow.default
    }
  };
  var ConnectorType, ConnectorEndType;

  if (disable.indexOf("connector") === -1) {
    ConnectorType = connector && CONNECTORS.type[connector.type] || Connector;
    ConnectorEndType = connector && CONNECTORS.end[connector.end];
  }

  var AnnotationType = getAnnotationType(props.editMode);
  return _react.default.createElement(AnnotationType, _extends({
    x: x,
    y: y,
    dx: dx,
    dy: dy,
    nx: nx,
    ny: ny,
    color: color,
    className: className,
    onDrag: onDrag,
    onDragStart: onDragStart,
    onDragEnd: onDragEnd,
    editMode: editMode
  }, SubjectDefaultProps, subject, {
    events: events
  }), ConnectorType && _react.default.createElement(ConnectorType, connector, ConnectorEndType && _react.default.createElement(ConnectorEndType, null)), Subject && disable.indexOf("subject") === -1 && _react.default.createElement(Subject, null), note && disable.indexOf("note") === -1 && (_react.default.isValidElement(note) || typeof note === "function" ? _react.default.createElement(_JSXNote.default, {
    noteDefaultProps: NoteDefaultProps,
    note: note
  }) : _react.default.createElement(NoteType, _extends({}, NoteDefaultProps, note))));
}
});

unwrapExports(Type);

var AnnotationCalloutCircle_1 = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = AnnotationCalloutCircle;

var _SubjectCircle = _interopRequireDefault(SubjectCircle_1);

var _ConnectorElbow = _interopRequireDefault(ConnectorElbow_1);

var _classnames = _interopRequireDefault(classnames);

var _Type = _interopRequireDefault(Type);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function AnnotationCalloutCircle(props) {
  var className = (0, _classnames.default)("callout circle", props.className);
  return (0, _Type.default)(_objectSpread({}, props, {
    className: className
  }), _ConnectorElbow.default, {
    lineType: "horizontal"
  }, _SubjectCircle.default, {
    radius: 20
  });
}
});

var AnnotationCalloutCircle = unwrapExports(AnnotationCalloutCircle_1);

function defaultSeparation(a, b) {
  return a.parent === b.parent ? 1 : 2;
}

function meanX(children) {
  return children.reduce(meanXReduce, 0) / children.length;
}

function meanXReduce(x, c) {
  return x + c.x;
}

function maxY(children) {
  return 1 + children.reduce(maxYReduce, 0);
}

function maxYReduce(y, c) {
  return Math.max(y, c.y);
}

function leafLeft(node) {
  var children;
  while (children = node.children) node = children[0];
  return node;
}

function leafRight(node) {
  var children;
  while (children = node.children) node = children[children.length - 1];
  return node;
}

function cluster() {
  var separation = defaultSeparation,
      dx = 1,
      dy = 1,
      nodeSize = false;

  function cluster(root) {
    var previousNode,
        x = 0;

    // First walk, computing the initial x & y values.
    root.eachAfter(function(node) {
      var children = node.children;
      if (children) {
        node.x = meanX(children);
        node.y = maxY(children);
      } else {
        node.x = previousNode ? x += separation(node, previousNode) : 0;
        node.y = 0;
        previousNode = node;
      }
    });

    var left = leafLeft(root),
        right = leafRight(root),
        x0 = left.x - separation(left, right) / 2,
        x1 = right.x + separation(right, left) / 2;

    // Second walk, normalizing x & y to the desired size.
    return root.eachAfter(nodeSize ? function(node) {
      node.x = (node.x - root.x) * dx;
      node.y = (root.y - node.y) * dy;
    } : function(node) {
      node.x = (node.x - x0) / (x1 - x0) * dx;
      node.y = (1 - (root.y ? node.y / root.y : 1)) * dy;
    });
  }

  cluster.separation = function(x) {
    return arguments.length ? (separation = x, cluster) : separation;
  };

  cluster.size = function(x) {
    return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], cluster) : (nodeSize ? null : [dx, dy]);
  };

  cluster.nodeSize = function(x) {
    return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], cluster) : (nodeSize ? [dx, dy] : null);
  };

  return cluster;
}

function count$1(node) {
  var sum = 0,
      children = node.children,
      i = children && children.length;
  if (!i) sum = 1;
  else while (--i >= 0) sum += children[i].value;
  node.value = sum;
}

function node_count() {
  return this.eachAfter(count$1);
}

function node_each(callback) {
  var node = this, current, next = [node], children, i, n;
  do {
    current = next.reverse(), next = [];
    while (node = current.pop()) {
      callback(node), children = node.children;
      if (children) for (i = 0, n = children.length; i < n; ++i) {
        next.push(children[i]);
      }
    }
  } while (next.length);
  return this;
}

function node_eachBefore(callback) {
  var node = this, nodes = [node], children, i;
  while (node = nodes.pop()) {
    callback(node), children = node.children;
    if (children) for (i = children.length - 1; i >= 0; --i) {
      nodes.push(children[i]);
    }
  }
  return this;
}

function node_eachAfter(callback) {
  var node = this, nodes = [node], next = [], children, i, n;
  while (node = nodes.pop()) {
    next.push(node), children = node.children;
    if (children) for (i = 0, n = children.length; i < n; ++i) {
      nodes.push(children[i]);
    }
  }
  while (node = next.pop()) {
    callback(node);
  }
  return this;
}

function node_sum(value) {
  return this.eachAfter(function(node) {
    var sum = +value(node.data) || 0,
        children = node.children,
        i = children && children.length;
    while (--i >= 0) sum += children[i].value;
    node.value = sum;
  });
}

function node_sort(compare) {
  return this.eachBefore(function(node) {
    if (node.children) {
      node.children.sort(compare);
    }
  });
}

function node_path(end) {
  var start = this,
      ancestor = leastCommonAncestor(start, end),
      nodes = [start];
  while (start !== ancestor) {
    start = start.parent;
    nodes.push(start);
  }
  var k = nodes.length;
  while (end !== ancestor) {
    nodes.splice(k, 0, end);
    end = end.parent;
  }
  return nodes;
}

function leastCommonAncestor(a, b) {
  if (a === b) return a;
  var aNodes = a.ancestors(),
      bNodes = b.ancestors(),
      c = null;
  a = aNodes.pop();
  b = bNodes.pop();
  while (a === b) {
    c = a;
    a = aNodes.pop();
    b = bNodes.pop();
  }
  return c;
}

function node_ancestors() {
  var node = this, nodes = [node];
  while (node = node.parent) {
    nodes.push(node);
  }
  return nodes;
}

function node_descendants() {
  var nodes = [];
  this.each(function(node) {
    nodes.push(node);
  });
  return nodes;
}

function node_leaves() {
  var leaves = [];
  this.eachBefore(function(node) {
    if (!node.children) {
      leaves.push(node);
    }
  });
  return leaves;
}

function node_links() {
  var root = this, links = [];
  root.each(function(node) {
    if (node !== root) { // Don’t include the root’s parent, if any.
      links.push({source: node.parent, target: node});
    }
  });
  return links;
}

function hierarchy(data, children) {
  var root = new Node(data),
      valued = +data.value && (root.value = data.value),
      node,
      nodes = [root],
      child,
      childs,
      i,
      n;

  if (children == null) children = defaultChildren;

  while (node = nodes.pop()) {
    if (valued) node.value = +node.data.value;
    if ((childs = children(node.data)) && (n = childs.length)) {
      node.children = new Array(n);
      for (i = n - 1; i >= 0; --i) {
        nodes.push(child = node.children[i] = new Node(childs[i]));
        child.parent = node;
        child.depth = node.depth + 1;
      }
    }
  }

  return root.eachBefore(computeHeight);
}

function node_copy() {
  return hierarchy(this).eachBefore(copyData);
}

function defaultChildren(d) {
  return d.children;
}

function copyData(node) {
  node.data = node.data.data;
}

function computeHeight(node) {
  var height = 0;
  do node.height = height;
  while ((node = node.parent) && (node.height < ++height));
}

function Node(data) {
  this.data = data;
  this.depth =
  this.height = 0;
  this.parent = null;
}

Node.prototype = hierarchy.prototype = {
  constructor: Node,
  count: node_count,
  each: node_each,
  eachAfter: node_eachAfter,
  eachBefore: node_eachBefore,
  sum: node_sum,
  sort: node_sort,
  path: node_path,
  ancestors: node_ancestors,
  descendants: node_descendants,
  leaves: node_leaves,
  links: node_links,
  copy: node_copy
};

var slice$2 = Array.prototype.slice;

function shuffle(array) {
  var m = array.length,
      t,
      i;

  while (m) {
    i = Math.random() * m-- | 0;
    t = array[m];
    array[m] = array[i];
    array[i] = t;
  }

  return array;
}

function packEnclose(circles) {
  var i = 0, n = (circles = shuffle(slice$2.call(circles))).length, B = [], p, e;

  while (i < n) {
    p = circles[i];
    if (e && enclosesWeak(e, p)) ++i;
    else e = encloseBasis(B = extendBasis(B, p)), i = 0;
  }

  return e;
}

function extendBasis(B, p) {
  var i, j;

  if (enclosesWeakAll(p, B)) return [p];

  // If we get here then B must have at least one element.
  for (i = 0; i < B.length; ++i) {
    if (enclosesNot(p, B[i])
        && enclosesWeakAll(encloseBasis2(B[i], p), B)) {
      return [B[i], p];
    }
  }

  // If we get here then B must have at least two elements.
  for (i = 0; i < B.length - 1; ++i) {
    for (j = i + 1; j < B.length; ++j) {
      if (enclosesNot(encloseBasis2(B[i], B[j]), p)
          && enclosesNot(encloseBasis2(B[i], p), B[j])
          && enclosesNot(encloseBasis2(B[j], p), B[i])
          && enclosesWeakAll(encloseBasis3(B[i], B[j], p), B)) {
        return [B[i], B[j], p];
      }
    }
  }

  // If we get here then something is very wrong.
  throw new Error;
}

function enclosesNot(a, b) {
  var dr = a.r - b.r, dx = b.x - a.x, dy = b.y - a.y;
  return dr < 0 || dr * dr < dx * dx + dy * dy;
}

function enclosesWeak(a, b) {
  var dr = a.r - b.r + 1e-6, dx = b.x - a.x, dy = b.y - a.y;
  return dr > 0 && dr * dr > dx * dx + dy * dy;
}

function enclosesWeakAll(a, B) {
  for (var i = 0; i < B.length; ++i) {
    if (!enclosesWeak(a, B[i])) {
      return false;
    }
  }
  return true;
}

function encloseBasis(B) {
  switch (B.length) {
    case 1: return encloseBasis1(B[0]);
    case 2: return encloseBasis2(B[0], B[1]);
    case 3: return encloseBasis3(B[0], B[1], B[2]);
  }
}

function encloseBasis1(a) {
  return {
    x: a.x,
    y: a.y,
    r: a.r
  };
}

function encloseBasis2(a, b) {
  var x1 = a.x, y1 = a.y, r1 = a.r,
      x2 = b.x, y2 = b.y, r2 = b.r,
      x21 = x2 - x1, y21 = y2 - y1, r21 = r2 - r1,
      l = Math.sqrt(x21 * x21 + y21 * y21);
  return {
    x: (x1 + x2 + x21 / l * r21) / 2,
    y: (y1 + y2 + y21 / l * r21) / 2,
    r: (l + r1 + r2) / 2
  };
}

function encloseBasis3(a, b, c) {
  var x1 = a.x, y1 = a.y, r1 = a.r,
      x2 = b.x, y2 = b.y, r2 = b.r,
      x3 = c.x, y3 = c.y, r3 = c.r,
      a2 = x1 - x2,
      a3 = x1 - x3,
      b2 = y1 - y2,
      b3 = y1 - y3,
      c2 = r2 - r1,
      c3 = r3 - r1,
      d1 = x1 * x1 + y1 * y1 - r1 * r1,
      d2 = d1 - x2 * x2 - y2 * y2 + r2 * r2,
      d3 = d1 - x3 * x3 - y3 * y3 + r3 * r3,
      ab = a3 * b2 - a2 * b3,
      xa = (b2 * d3 - b3 * d2) / (ab * 2) - x1,
      xb = (b3 * c2 - b2 * c3) / ab,
      ya = (a3 * d2 - a2 * d3) / (ab * 2) - y1,
      yb = (a2 * c3 - a3 * c2) / ab,
      A = xb * xb + yb * yb - 1,
      B = 2 * (r1 + xa * xb + ya * yb),
      C = xa * xa + ya * ya - r1 * r1,
      r = -(A ? (B + Math.sqrt(B * B - 4 * A * C)) / (2 * A) : C / B);
  return {
    x: x1 + xa + xb * r,
    y: y1 + ya + yb * r,
    r: r
  };
}

function place(b, a, c) {
  var dx = b.x - a.x, x, a2,
      dy = b.y - a.y, y, b2,
      d2 = dx * dx + dy * dy;
  if (d2) {
    a2 = a.r + c.r, a2 *= a2;
    b2 = b.r + c.r, b2 *= b2;
    if (a2 > b2) {
      x = (d2 + b2 - a2) / (2 * d2);
      y = Math.sqrt(Math.max(0, b2 / d2 - x * x));
      c.x = b.x - x * dx - y * dy;
      c.y = b.y - x * dy + y * dx;
    } else {
      x = (d2 + a2 - b2) / (2 * d2);
      y = Math.sqrt(Math.max(0, a2 / d2 - x * x));
      c.x = a.x + x * dx - y * dy;
      c.y = a.y + x * dy + y * dx;
    }
  } else {
    c.x = a.x + c.r;
    c.y = a.y;
  }
}

function intersects(a, b) {
  var dr = a.r + b.r - 1e-6, dx = b.x - a.x, dy = b.y - a.y;
  return dr > 0 && dr * dr > dx * dx + dy * dy;
}

function score(node) {
  var a = node._,
      b = node.next._,
      ab = a.r + b.r,
      dx = (a.x * b.r + b.x * a.r) / ab,
      dy = (a.y * b.r + b.y * a.r) / ab;
  return dx * dx + dy * dy;
}

function Node$1(circle) {
  this._ = circle;
  this.next = null;
  this.previous = null;
}

function packEnclose$1(circles) {
  if (!(n = circles.length)) return 0;

  var a, b, c, n, aa, ca, i, j, k, sj, sk;

  // Place the first circle.
  a = circles[0], a.x = 0, a.y = 0;
  if (!(n > 1)) return a.r;

  // Place the second circle.
  b = circles[1], a.x = -b.r, b.x = a.r, b.y = 0;
  if (!(n > 2)) return a.r + b.r;

  // Place the third circle.
  place(b, a, c = circles[2]);

  // Initialize the front-chain using the first three circles a, b and c.
  a = new Node$1(a), b = new Node$1(b), c = new Node$1(c);
  a.next = c.previous = b;
  b.next = a.previous = c;
  c.next = b.previous = a;

  // Attempt to place each remaining circle…
  pack: for (i = 3; i < n; ++i) {
    place(a._, b._, c = circles[i]), c = new Node$1(c);

    // Find the closest intersecting circle on the front-chain, if any.
    // “Closeness” is determined by linear distance along the front-chain.
    // “Ahead” or “behind” is likewise determined by linear distance.
    j = b.next, k = a.previous, sj = b._.r, sk = a._.r;
    do {
      if (sj <= sk) {
        if (intersects(j._, c._)) {
          b = j, a.next = b, b.previous = a, --i;
          continue pack;
        }
        sj += j._.r, j = j.next;
      } else {
        if (intersects(k._, c._)) {
          a = k, a.next = b, b.previous = a, --i;
          continue pack;
        }
        sk += k._.r, k = k.previous;
      }
    } while (j !== k.next);

    // Success! Insert the new circle c between a and b.
    c.previous = a, c.next = b, a.next = b.previous = b = c;

    // Compute the new closest circle pair to the centroid.
    aa = score(a);
    while ((c = c.next) !== b) {
      if ((ca = score(c)) < aa) {
        a = c, aa = ca;
      }
    }
    b = a.next;
  }

  // Compute the enclosing circle of the front chain.
  a = [b._], c = b; while ((c = c.next) !== b) a.push(c._); c = packEnclose(a);

  // Translate the circles to put the enclosing circle around the origin.
  for (i = 0; i < n; ++i) a = circles[i], a.x -= c.x, a.y -= c.y;

  return c.r;
}

function optional(f) {
  return f == null ? null : required(f);
}

function required(f) {
  if (typeof f !== "function") throw new Error;
  return f;
}

function constantZero() {
  return 0;
}

function constant$4(x) {
  return function() {
    return x;
  };
}

function defaultRadius(d) {
  return Math.sqrt(d.value);
}

function pack() {
  var radius = null,
      dx = 1,
      dy = 1,
      padding = constantZero;

  function pack(root) {
    root.x = dx / 2, root.y = dy / 2;
    if (radius) {
      root.eachBefore(radiusLeaf(radius))
          .eachAfter(packChildren(padding, 0.5))
          .eachBefore(translateChild(1));
    } else {
      root.eachBefore(radiusLeaf(defaultRadius))
          .eachAfter(packChildren(constantZero, 1))
          .eachAfter(packChildren(padding, root.r / Math.min(dx, dy)))
          .eachBefore(translateChild(Math.min(dx, dy) / (2 * root.r)));
    }
    return root;
  }

  pack.radius = function(x) {
    return arguments.length ? (radius = optional(x), pack) : radius;
  };

  pack.size = function(x) {
    return arguments.length ? (dx = +x[0], dy = +x[1], pack) : [dx, dy];
  };

  pack.padding = function(x) {
    return arguments.length ? (padding = typeof x === "function" ? x : constant$4(+x), pack) : padding;
  };

  return pack;
}

function radiusLeaf(radius) {
  return function(node) {
    if (!node.children) {
      node.r = Math.max(0, +radius(node) || 0);
    }
  };
}

function packChildren(padding, k) {
  return function(node) {
    if (children = node.children) {
      var children,
          i,
          n = children.length,
          r = padding(node) * k || 0,
          e;

      if (r) for (i = 0; i < n; ++i) children[i].r += r;
      e = packEnclose$1(children);
      if (r) for (i = 0; i < n; ++i) children[i].r -= r;
      node.r = e + r;
    }
  };
}

function translateChild(k) {
  return function(node) {
    var parent = node.parent;
    node.r *= k;
    if (parent) {
      node.x = parent.x + k * node.x;
      node.y = parent.y + k * node.y;
    }
  };
}

function roundNode(node) {
  node.x0 = Math.round(node.x0);
  node.y0 = Math.round(node.y0);
  node.x1 = Math.round(node.x1);
  node.y1 = Math.round(node.y1);
}

function treemapDice(parent, x0, y0, x1, y1) {
  var nodes = parent.children,
      node,
      i = -1,
      n = nodes.length,
      k = parent.value && (x1 - x0) / parent.value;

  while (++i < n) {
    node = nodes[i], node.y0 = y0, node.y1 = y1;
    node.x0 = x0, node.x1 = x0 += node.value * k;
  }
}

function partition() {
  var dx = 1,
      dy = 1,
      padding = 0,
      round = false;

  function partition(root) {
    var n = root.height + 1;
    root.x0 =
    root.y0 = padding;
    root.x1 = dx;
    root.y1 = dy / n;
    root.eachBefore(positionNode(dy, n));
    if (round) root.eachBefore(roundNode);
    return root;
  }

  function positionNode(dy, n) {
    return function(node) {
      if (node.children) {
        treemapDice(node, node.x0, dy * (node.depth + 1) / n, node.x1, dy * (node.depth + 2) / n);
      }
      var x0 = node.x0,
          y0 = node.y0,
          x1 = node.x1 - padding,
          y1 = node.y1 - padding;
      if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
      if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
      node.x0 = x0;
      node.y0 = y0;
      node.x1 = x1;
      node.y1 = y1;
    };
  }

  partition.round = function(x) {
    return arguments.length ? (round = !!x, partition) : round;
  };

  partition.size = function(x) {
    return arguments.length ? (dx = +x[0], dy = +x[1], partition) : [dx, dy];
  };

  partition.padding = function(x) {
    return arguments.length ? (padding = +x, partition) : padding;
  };

  return partition;
}

function defaultSeparation$1(a, b) {
  return a.parent === b.parent ? 1 : 2;
}

// function radialSeparation(a, b) {
//   return (a.parent === b.parent ? 1 : 2) / a.depth;
// }

// This function is used to traverse the left contour of a subtree (or
// subforest). It returns the successor of v on this contour. This successor is
// either given by the leftmost child of v or by the thread of v. The function
// returns null if and only if v is on the highest level of its subtree.
function nextLeft(v) {
  var children = v.children;
  return children ? children[0] : v.t;
}

// This function works analogously to nextLeft.
function nextRight(v) {
  var children = v.children;
  return children ? children[children.length - 1] : v.t;
}

// Shifts the current subtree rooted at w+. This is done by increasing
// prelim(w+) and mod(w+) by shift.
function moveSubtree(wm, wp, shift) {
  var change = shift / (wp.i - wm.i);
  wp.c -= change;
  wp.s += shift;
  wm.c += change;
  wp.z += shift;
  wp.m += shift;
}

// All other shifts, applied to the smaller subtrees between w- and w+, are
// performed by this function. To prepare the shifts, we have to adjust
// change(w+), shift(w+), and change(w-).
function executeShifts(v) {
  var shift = 0,
      change = 0,
      children = v.children,
      i = children.length,
      w;
  while (--i >= 0) {
    w = children[i];
    w.z += shift;
    w.m += shift;
    shift += w.s + (change += w.c);
  }
}

// If vi-’s ancestor is a sibling of v, returns vi-’s ancestor. Otherwise,
// returns the specified (default) ancestor.
function nextAncestor(vim, v, ancestor) {
  return vim.a.parent === v.parent ? vim.a : ancestor;
}

function TreeNode(node, i) {
  this._ = node;
  this.parent = null;
  this.children = null;
  this.A = null; // default ancestor
  this.a = this; // ancestor
  this.z = 0; // prelim
  this.m = 0; // mod
  this.c = 0; // change
  this.s = 0; // shift
  this.t = null; // thread
  this.i = i; // number
}

TreeNode.prototype = Object.create(Node.prototype);

function treeRoot(root) {
  var tree = new TreeNode(root, 0),
      node,
      nodes = [tree],
      child,
      children,
      i,
      n;

  while (node = nodes.pop()) {
    if (children = node._.children) {
      node.children = new Array(n = children.length);
      for (i = n - 1; i >= 0; --i) {
        nodes.push(child = node.children[i] = new TreeNode(children[i], i));
        child.parent = node;
      }
    }
  }

  (tree.parent = new TreeNode(null, 0)).children = [tree];
  return tree;
}

// Node-link tree diagram using the Reingold-Tilford "tidy" algorithm
function tree() {
  var separation = defaultSeparation$1,
      dx = 1,
      dy = 1,
      nodeSize = null;

  function tree(root) {
    var t = treeRoot(root);

    // Compute the layout using Buchheim et al.’s algorithm.
    t.eachAfter(firstWalk), t.parent.m = -t.z;
    t.eachBefore(secondWalk);

    // If a fixed node size is specified, scale x and y.
    if (nodeSize) root.eachBefore(sizeNode);

    // If a fixed tree size is specified, scale x and y based on the extent.
    // Compute the left-most, right-most, and depth-most nodes for extents.
    else {
      var left = root,
          right = root,
          bottom = root;
      root.eachBefore(function(node) {
        if (node.x < left.x) left = node;
        if (node.x > right.x) right = node;
        if (node.depth > bottom.depth) bottom = node;
      });
      var s = left === right ? 1 : separation(left, right) / 2,
          tx = s - left.x,
          kx = dx / (right.x + s + tx),
          ky = dy / (bottom.depth || 1);
      root.eachBefore(function(node) {
        node.x = (node.x + tx) * kx;
        node.y = node.depth * ky;
      });
    }

    return root;
  }

  // Computes a preliminary x-coordinate for v. Before that, FIRST WALK is
  // applied recursively to the children of v, as well as the function
  // APPORTION. After spacing out the children by calling EXECUTE SHIFTS, the
  // node v is placed to the midpoint of its outermost children.
  function firstWalk(v) {
    var children = v.children,
        siblings = v.parent.children,
        w = v.i ? siblings[v.i - 1] : null;
    if (children) {
      executeShifts(v);
      var midpoint = (children[0].z + children[children.length - 1].z) / 2;
      if (w) {
        v.z = w.z + separation(v._, w._);
        v.m = v.z - midpoint;
      } else {
        v.z = midpoint;
      }
    } else if (w) {
      v.z = w.z + separation(v._, w._);
    }
    v.parent.A = apportion(v, w, v.parent.A || siblings[0]);
  }

  // Computes all real x-coordinates by summing up the modifiers recursively.
  function secondWalk(v) {
    v._.x = v.z + v.parent.m;
    v.m += v.parent.m;
  }

  // The core of the algorithm. Here, a new subtree is combined with the
  // previous subtrees. Threads are used to traverse the inside and outside
  // contours of the left and right subtree up to the highest common level. The
  // vertices used for the traversals are vi+, vi-, vo-, and vo+, where the
  // superscript o means outside and i means inside, the subscript - means left
  // subtree and + means right subtree. For summing up the modifiers along the
  // contour, we use respective variables si+, si-, so-, and so+. Whenever two
  // nodes of the inside contours conflict, we compute the left one of the
  // greatest uncommon ancestors using the function ANCESTOR and call MOVE
  // SUBTREE to shift the subtree and prepare the shifts of smaller subtrees.
  // Finally, we add a new thread (if necessary).
  function apportion(v, w, ancestor) {
    if (w) {
      var vip = v,
          vop = v,
          vim = w,
          vom = vip.parent.children[0],
          sip = vip.m,
          sop = vop.m,
          sim = vim.m,
          som = vom.m,
          shift;
      while (vim = nextRight(vim), vip = nextLeft(vip), vim && vip) {
        vom = nextLeft(vom);
        vop = nextRight(vop);
        vop.a = v;
        shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);
        if (shift > 0) {
          moveSubtree(nextAncestor(vim, v, ancestor), v, shift);
          sip += shift;
          sop += shift;
        }
        sim += vim.m;
        sip += vip.m;
        som += vom.m;
        sop += vop.m;
      }
      if (vim && !nextRight(vop)) {
        vop.t = vim;
        vop.m += sim - sop;
      }
      if (vip && !nextLeft(vom)) {
        vom.t = vip;
        vom.m += sip - som;
        ancestor = v;
      }
    }
    return ancestor;
  }

  function sizeNode(node) {
    node.x *= dx;
    node.y = node.depth * dy;
  }

  tree.separation = function(x) {
    return arguments.length ? (separation = x, tree) : separation;
  };

  tree.size = function(x) {
    return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], tree) : (nodeSize ? null : [dx, dy]);
  };

  tree.nodeSize = function(x) {
    return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], tree) : (nodeSize ? [dx, dy] : null);
  };

  return tree;
}

function treemapSlice(parent, x0, y0, x1, y1) {
  var nodes = parent.children,
      node,
      i = -1,
      n = nodes.length,
      k = parent.value && (y1 - y0) / parent.value;

  while (++i < n) {
    node = nodes[i], node.x0 = x0, node.x1 = x1;
    node.y0 = y0, node.y1 = y0 += node.value * k;
  }
}

var phi = (1 + Math.sqrt(5)) / 2;

function squarifyRatio(ratio, parent, x0, y0, x1, y1) {
  var rows = [],
      nodes = parent.children,
      row,
      nodeValue,
      i0 = 0,
      i1 = 0,
      n = nodes.length,
      dx, dy,
      value = parent.value,
      sumValue,
      minValue,
      maxValue,
      newRatio,
      minRatio,
      alpha,
      beta;

  while (i0 < n) {
    dx = x1 - x0, dy = y1 - y0;

    // Find the next non-empty node.
    do sumValue = nodes[i1++].value; while (!sumValue && i1 < n);
    minValue = maxValue = sumValue;
    alpha = Math.max(dy / dx, dx / dy) / (value * ratio);
    beta = sumValue * sumValue * alpha;
    minRatio = Math.max(maxValue / beta, beta / minValue);

    // Keep adding nodes while the aspect ratio maintains or improves.
    for (; i1 < n; ++i1) {
      sumValue += nodeValue = nodes[i1].value;
      if (nodeValue < minValue) minValue = nodeValue;
      if (nodeValue > maxValue) maxValue = nodeValue;
      beta = sumValue * sumValue * alpha;
      newRatio = Math.max(maxValue / beta, beta / minValue);
      if (newRatio > minRatio) { sumValue -= nodeValue; break; }
      minRatio = newRatio;
    }

    // Position and record the row orientation.
    rows.push(row = {value: sumValue, dice: dx < dy, children: nodes.slice(i0, i1)});
    if (row.dice) treemapDice(row, x0, y0, x1, value ? y0 += dy * sumValue / value : y1);
    else treemapSlice(row, x0, y0, value ? x0 += dx * sumValue / value : x1, y1);
    value -= sumValue, i0 = i1;
  }

  return rows;
}

var squarify = (function custom(ratio) {

  function squarify(parent, x0, y0, x1, y1) {
    squarifyRatio(ratio, parent, x0, y0, x1, y1);
  }

  squarify.ratio = function(x) {
    return custom((x = +x) > 1 ? x : 1);
  };

  return squarify;
})(phi);

function treemap() {
  var tile = squarify,
      round = false,
      dx = 1,
      dy = 1,
      paddingStack = [0],
      paddingInner = constantZero,
      paddingTop = constantZero,
      paddingRight = constantZero,
      paddingBottom = constantZero,
      paddingLeft = constantZero;

  function treemap(root) {
    root.x0 =
    root.y0 = 0;
    root.x1 = dx;
    root.y1 = dy;
    root.eachBefore(positionNode);
    paddingStack = [0];
    if (round) root.eachBefore(roundNode);
    return root;
  }

  function positionNode(node) {
    var p = paddingStack[node.depth],
        x0 = node.x0 + p,
        y0 = node.y0 + p,
        x1 = node.x1 - p,
        y1 = node.y1 - p;
    if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
    if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
    node.x0 = x0;
    node.y0 = y0;
    node.x1 = x1;
    node.y1 = y1;
    if (node.children) {
      p = paddingStack[node.depth + 1] = paddingInner(node) / 2;
      x0 += paddingLeft(node) - p;
      y0 += paddingTop(node) - p;
      x1 -= paddingRight(node) - p;
      y1 -= paddingBottom(node) - p;
      if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
      if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
      tile(node, x0, y0, x1, y1);
    }
  }

  treemap.round = function(x) {
    return arguments.length ? (round = !!x, treemap) : round;
  };

  treemap.size = function(x) {
    return arguments.length ? (dx = +x[0], dy = +x[1], treemap) : [dx, dy];
  };

  treemap.tile = function(x) {
    return arguments.length ? (tile = required(x), treemap) : tile;
  };

  treemap.padding = function(x) {
    return arguments.length ? treemap.paddingInner(x).paddingOuter(x) : treemap.paddingInner();
  };

  treemap.paddingInner = function(x) {
    return arguments.length ? (paddingInner = typeof x === "function" ? x : constant$4(+x), treemap) : paddingInner;
  };

  treemap.paddingOuter = function(x) {
    return arguments.length ? treemap.paddingTop(x).paddingRight(x).paddingBottom(x).paddingLeft(x) : treemap.paddingTop();
  };

  treemap.paddingTop = function(x) {
    return arguments.length ? (paddingTop = typeof x === "function" ? x : constant$4(+x), treemap) : paddingTop;
  };

  treemap.paddingRight = function(x) {
    return arguments.length ? (paddingRight = typeof x === "function" ? x : constant$4(+x), treemap) : paddingRight;
  };

  treemap.paddingBottom = function(x) {
    return arguments.length ? (paddingBottom = typeof x === "function" ? x : constant$4(+x), treemap) : paddingBottom;
  };

  treemap.paddingLeft = function(x) {
    return arguments.length ? (paddingLeft = typeof x === "function" ? x : constant$4(+x), treemap) : paddingLeft;
  };

  return treemap;
}

// Returns the 2D cross product of AB and AC vectors, i.e., the z-component of
// the 3D cross product in a quadrant I Cartesian coordinate system (+x is
// right, +y is up). Returns a positive value if ABC is counter-clockwise,
// negative if clockwise, and zero if the points are collinear.
function cross$1(a, b, c) {
  return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]);
}

function lexicographicOrder(a, b) {
  return a[0] - b[0] || a[1] - b[1];
}

// Computes the upper convex hull per the monotone chain algorithm.
// Assumes points.length >= 3, is sorted by x, unique in y.
// Returns an array of indices into points in left-to-right order.
function computeUpperHullIndexes(points) {
  var n = points.length,
      indexes = [0, 1],
      size = 2;

  for (var i = 2; i < n; ++i) {
    while (size > 1 && cross$1(points[indexes[size - 2]], points[indexes[size - 1]], points[i]) <= 0) --size;
    indexes[size++] = i;
  }

  return indexes.slice(0, size); // remove popped points
}

function polygonHull(points) {
  if ((n = points.length) < 3) return null;

  var i,
      n,
      sortedPoints = new Array(n),
      flippedPoints = new Array(n);

  for (i = 0; i < n; ++i) sortedPoints[i] = [+points[i][0], +points[i][1], i];
  sortedPoints.sort(lexicographicOrder);
  for (i = 0; i < n; ++i) flippedPoints[i] = [sortedPoints[i][0], -sortedPoints[i][1]];

  var upperIndexes = computeUpperHullIndexes(sortedPoints),
      lowerIndexes = computeUpperHullIndexes(flippedPoints);

  // Construct the hull polygon, removing possible duplicate endpoints.
  var skipLeft = lowerIndexes[0] === upperIndexes[0],
      skipRight = lowerIndexes[lowerIndexes.length - 1] === upperIndexes[upperIndexes.length - 1],
      hull = [];

  // Add upper hull in right-to-l order.
  // Then add lower hull in left-to-right order.
  for (i = upperIndexes.length - 1; i >= 0; --i) hull.push(points[sortedPoints[upperIndexes[i]][2]]);
  for (i = +skipLeft; i < lowerIndexes.length - skipRight; ++i) hull.push(points[sortedPoints[lowerIndexes[i]][2]]);

  return hull;
}

/**
 * Offset edge of the polygon
 *
 * @param  {Object} current
 * @param  {Object} next
 * @constructor
 */
function Edge(current, next) {

  /**
   * @type {Object}
   */
  this.current = current;

  /**
   * @type {Object}
   */
  this.next = next;

  /**
   * @type {Object}
   */
  this._inNormal  = this.inwardsNormal();

  /**
   * @type {Object}
   */
  this._outNormal = this.outwardsNormal();
}

/**
 * Creates outwards normal
 * @return {Object}
 */
Edge.prototype.outwardsNormal = function() {
  var inwards = this.inwardsNormal();
  return [
    -inwards[0],
    -inwards[1]
  ];
};

/**
 * Creates inwards normal
 * @return {Object}
 */
Edge.prototype.inwardsNormal = function() {
  var dx = this.next[0] - this.current[0],
      dy = this.next[1] - this.current[1],
      edgeLength = Math.sqrt(dx * dx + dy * dy);

  if (edgeLength === 0) throw new Error('Vertices overlap');

  return [
    -dy / edgeLength,
     dx / edgeLength
  ];
};

/**
 * Offsets the edge by dx, dy
 * @param  {Number} dx
 * @param  {Number} dy
 * @return {Edge}
 */
Edge.prototype.offset = function(dx, dy) {
  return Edge.offsetEdge(this.current, this.next, dx, dy);
};


/**
 * @param  {Number} dx
 * @param  {Number} dy
 * @return {Edge}
 */
Edge.prototype.inverseOffset = function(dx, dy) {
  return Edge.offsetEdge(this.next, this.current, dx, dy);
};


/**
 * @static
 * @param  {Array.<Number>} current
 * @param  {Array.<Number>} next
 * @param  {Number}         dx
 * @param  {Number}         dy
 * @return {Edge}
 */
Edge.offsetEdge = function(current, next, dx, dy) {
  return new Edge([
    current[0] + dx,
    current[1] + dy
  ], [
    next[0] + dx,
    next[1] + dy
  ]);
};


/**
 *
 * @return {Edge}
 */
Edge.prototype.inverse = function () {
  return new Edge(this.next, this.current);
};


var edge = Edge;

var edge_type = { 
  NORMAL:               0, 
  NON_CONTRIBUTING:     1, 
  SAME_TRANSITION:      2, 
  DIFFERENT_TRANSITION: 3
};

var tinyqueue = TinyQueue;
var default_1 = TinyQueue;

function TinyQueue(data, compare) {
    if (!(this instanceof TinyQueue)) return new TinyQueue(data, compare);

    this.data = data || [];
    this.length = this.data.length;
    this.compare = compare || defaultCompare;

    if (this.length > 0) {
        for (var i = (this.length >> 1) - 1; i >= 0; i--) this._down(i);
    }
}

function defaultCompare(a, b) {
    return a < b ? -1 : a > b ? 1 : 0;
}

TinyQueue.prototype = {

    push: function (item) {
        this.data.push(item);
        this.length++;
        this._up(this.length - 1);
    },

    pop: function () {
        if (this.length === 0) return undefined;

        var top = this.data[0];
        this.length--;

        if (this.length > 0) {
            this.data[0] = this.data[this.length];
            this._down(0);
        }
        this.data.pop();

        return top;
    },

    peek: function () {
        return this.data[0];
    },

    _up: function (pos) {
        var data = this.data;
        var compare = this.compare;
        var item = data[pos];

        while (pos > 0) {
            var parent = (pos - 1) >> 1;
            var current = data[parent];
            if (compare(item, current) >= 0) break;
            data[pos] = current;
            pos = parent;
        }

        data[pos] = item;
    },

    _down: function (pos) {
        var data = this.data;
        var compare = this.compare;
        var halfLength = this.length >> 1;
        var item = data[pos];

        while (pos < halfLength) {
            var left = (pos << 1) + 1;
            var right = left + 1;
            var best = data[left];

            if (right < this.length && compare(data[right], best) < 0) {
                left = right;
                best = data[right];
            }
            if (compare(best, item) >= 0) break;

            data[pos] = best;
            pos = left;
        }

        data[pos] = item;
    }
};
tinyqueue.default = default_1;

function TreeBase() {}

// removes all nodes from the tree
TreeBase.prototype.clear = function() {
    this._root = null;
    this.size = 0;
};

// returns node data if found, null otherwise
TreeBase.prototype.find = function(data) {
    var res = this._root;

    while(res !== null) {
        var c = this._comparator(data, res.data);
        if(c === 0) {
            return res.data;
        }
        else {
            res = res.get_child(c > 0);
        }
    }

    return null;
};

// returns iterator to node if found, null otherwise
TreeBase.prototype.findIter = function(data) {
    var res = this._root;
    var iter = this.iterator();

    while(res !== null) {
        var c = this._comparator(data, res.data);
        if(c === 0) {
            iter._cursor = res;
            return iter;
        }
        else {
            iter._ancestors.push(res);
            res = res.get_child(c > 0);
        }
    }

    return null;
};

// Returns an iterator to the tree node at or immediately after the item
TreeBase.prototype.lowerBound = function(item) {
    var cur = this._root;
    var iter = this.iterator();
    var cmp = this._comparator;

    while(cur !== null) {
        var c = cmp(item, cur.data);
        if(c === 0) {
            iter._cursor = cur;
            return iter;
        }
        iter._ancestors.push(cur);
        cur = cur.get_child(c > 0);
    }

    for(var i=iter._ancestors.length - 1; i >= 0; --i) {
        cur = iter._ancestors[i];
        if(cmp(item, cur.data) < 0) {
            iter._cursor = cur;
            iter._ancestors.length = i;
            return iter;
        }
    }

    iter._ancestors.length = 0;
    return iter;
};

// Returns an iterator to the tree node immediately after the item
TreeBase.prototype.upperBound = function(item) {
    var iter = this.lowerBound(item);
    var cmp = this._comparator;

    while(iter.data() !== null && cmp(iter.data(), item) === 0) {
        iter.next();
    }

    return iter;
};

// returns null if tree is empty
TreeBase.prototype.min = function() {
    var res = this._root;
    if(res === null) {
        return null;
    }

    while(res.left !== null) {
        res = res.left;
    }

    return res.data;
};

// returns null if tree is empty
TreeBase.prototype.max = function() {
    var res = this._root;
    if(res === null) {
        return null;
    }

    while(res.right !== null) {
        res = res.right;
    }

    return res.data;
};

// returns a null iterator
// call next() or prev() to point to an element
TreeBase.prototype.iterator = function() {
    return new Iterator(this);
};

// calls cb on each node's data, in order
TreeBase.prototype.each = function(cb) {
    var it=this.iterator(), data;
    while((data = it.next()) !== null) {
        if(cb(data) === false) {
            return;
        }
    }
};

// calls cb on each node's data, in reverse order
TreeBase.prototype.reach = function(cb) {
    var it=this.iterator(), data;
    while((data = it.prev()) !== null) {
        if(cb(data) === false) {
            return;
        }
    }
};


function Iterator(tree) {
    this._tree = tree;
    this._ancestors = [];
    this._cursor = null;
}

Iterator.prototype.data = function() {
    return this._cursor !== null ? this._cursor.data : null;
};

// if null-iterator, returns first node
// otherwise, returns next node
Iterator.prototype.next = function() {
    if(this._cursor === null) {
        var root = this._tree._root;
        if(root !== null) {
            this._minNode(root);
        }
    }
    else {
        if(this._cursor.right === null) {
            // no greater node in subtree, go up to parent
            // if coming from a right child, continue up the stack
            var save;
            do {
                save = this._cursor;
                if(this._ancestors.length) {
                    this._cursor = this._ancestors.pop();
                }
                else {
                    this._cursor = null;
                    break;
                }
            } while(this._cursor.right === save);
        }
        else {
            // get the next node from the subtree
            this._ancestors.push(this._cursor);
            this._minNode(this._cursor.right);
        }
    }
    return this._cursor !== null ? this._cursor.data : null;
};

// if null-iterator, returns last node
// otherwise, returns previous node
Iterator.prototype.prev = function() {
    if(this._cursor === null) {
        var root = this._tree._root;
        if(root !== null) {
            this._maxNode(root);
        }
    }
    else {
        if(this._cursor.left === null) {
            var save;
            do {
                save = this._cursor;
                if(this._ancestors.length) {
                    this._cursor = this._ancestors.pop();
                }
                else {
                    this._cursor = null;
                    break;
                }
            } while(this._cursor.left === save);
        }
        else {
            this._ancestors.push(this._cursor);
            this._maxNode(this._cursor.left);
        }
    }
    return this._cursor !== null ? this._cursor.data : null;
};

Iterator.prototype._minNode = function(start) {
    while(start.left !== null) {
        this._ancestors.push(start);
        start = start.left;
    }
    this._cursor = start;
};

Iterator.prototype._maxNode = function(start) {
    while(start.right !== null) {
        this._ancestors.push(start);
        start = start.right;
    }
    this._cursor = start;
};

var treebase = TreeBase;

function Node$2(data) {
    this.data = data;
    this.left = null;
    this.right = null;
    this.red = true;
}

Node$2.prototype.get_child = function(dir) {
    return dir ? this.right : this.left;
};

Node$2.prototype.set_child = function(dir, val) {
    if(dir) {
        this.right = val;
    }
    else {
        this.left = val;
    }
};

function RBTree(comparator) {
    this._root = null;
    this._comparator = comparator;
    this.size = 0;
}

RBTree.prototype = new treebase();

// returns true if inserted, false if duplicate
RBTree.prototype.insert = function(data) {
    var ret = false;

    if(this._root === null) {
        // empty tree
        this._root = new Node$2(data);
        ret = true;
        this.size++;
    }
    else {
        var head = new Node$2(undefined); // fake tree root

        var dir = 0;
        var last = 0;

        // setup
        var gp = null; // grandparent
        var ggp = head; // grand-grand-parent
        var p = null; // parent
        var node = this._root;
        ggp.right = this._root;

        // search down
        while(true) {
            if(node === null) {
                // insert new node at the bottom
                node = new Node$2(data);
                p.set_child(dir, node);
                ret = true;
                this.size++;
            }
            else if(is_red(node.left) && is_red(node.right)) {
                // color flip
                node.red = true;
                node.left.red = false;
                node.right.red = false;
            }

            // fix red violation
            if(is_red(node) && is_red(p)) {
                var dir2 = ggp.right === gp;

                if(node === p.get_child(last)) {
                    ggp.set_child(dir2, single_rotate(gp, !last));
                }
                else {
                    ggp.set_child(dir2, double_rotate(gp, !last));
                }
            }

            var cmp = this._comparator(node.data, data);

            // stop if found
            if(cmp === 0) {
                break;
            }

            last = dir;
            dir = cmp < 0;

            // update helpers
            if(gp !== null) {
                ggp = gp;
            }
            gp = p;
            p = node;
            node = node.get_child(dir);
        }

        // update root
        this._root = head.right;
    }

    // make root black
    this._root.red = false;

    return ret;
};

// returns true if removed, false if not found
RBTree.prototype.remove = function(data) {
    if(this._root === null) {
        return false;
    }

    var head = new Node$2(undefined); // fake tree root
    var node = head;
    node.right = this._root;
    var p = null; // parent
    var gp = null; // grand parent
    var found = null; // found item
    var dir = 1;

    while(node.get_child(dir) !== null) {
        var last = dir;

        // update helpers
        gp = p;
        p = node;
        node = node.get_child(dir);

        var cmp = this._comparator(data, node.data);

        dir = cmp > 0;

        // save found node
        if(cmp === 0) {
            found = node;
        }

        // push the red node down
        if(!is_red(node) && !is_red(node.get_child(dir))) {
            if(is_red(node.get_child(!dir))) {
                var sr = single_rotate(node, dir);
                p.set_child(last, sr);
                p = sr;
            }
            else if(!is_red(node.get_child(!dir))) {
                var sibling = p.get_child(!last);
                if(sibling !== null) {
                    if(!is_red(sibling.get_child(!last)) && !is_red(sibling.get_child(last))) {
                        // color flip
                        p.red = false;
                        sibling.red = true;
                        node.red = true;
                    }
                    else {
                        var dir2 = gp.right === p;

                        if(is_red(sibling.get_child(last))) {
                            gp.set_child(dir2, double_rotate(p, last));
                        }
                        else if(is_red(sibling.get_child(!last))) {
                            gp.set_child(dir2, single_rotate(p, last));
                        }

                        // ensure correct coloring
                        var gpc = gp.get_child(dir2);
                        gpc.red = true;
                        node.red = true;
                        gpc.left.red = false;
                        gpc.right.red = false;
                    }
                }
            }
        }
    }

    // replace and remove if found
    if(found !== null) {
        found.data = node.data;
        p.set_child(p.right === node, node.get_child(node.left === null));
        this.size--;
    }

    // update root and make it black
    this._root = head.right;
    if(this._root !== null) {
        this._root.red = false;
    }

    return found !== null;
};

function is_red(node) {
    return node !== null && node.red;
}

function single_rotate(root, dir) {
    var save = root.get_child(!dir);

    root.set_child(!dir, save.get_child(dir));
    save.set_child(dir, root);

    root.red = true;
    save.red = false;

    return save;
}

function double_rotate(root, dir) {
    root.set_child(!dir, single_rotate(root.get_child(!dir), !dir));
    return single_rotate(root, dir);
}

var rbtree = RBTree;

function Node$3(data) {
    this.data = data;
    this.left = null;
    this.right = null;
}

Node$3.prototype.get_child = function(dir) {
    return dir ? this.right : this.left;
};

Node$3.prototype.set_child = function(dir, val) {
    if(dir) {
        this.right = val;
    }
    else {
        this.left = val;
    }
};

function BinTree(comparator) {
    this._root = null;
    this._comparator = comparator;
    this.size = 0;
}

BinTree.prototype = new treebase();

// returns true if inserted, false if duplicate
BinTree.prototype.insert = function(data) {
    if(this._root === null) {
        // empty tree
        this._root = new Node$3(data);
        this.size++;
        return true;
    }

    var dir = 0;

    // setup
    var p = null; // parent
    var node = this._root;

    // search down
    while(true) {
        if(node === null) {
            // insert new node at the bottom
            node = new Node$3(data);
            p.set_child(dir, node);
            ret = true;
            this.size++;
            return true;
        }

        // stop if found
        if(this._comparator(node.data, data) === 0) {
            return false;
        }

        dir = this._comparator(node.data, data) < 0;

        // update helpers
        p = node;
        node = node.get_child(dir);
    }
};

// returns true if removed, false if not found
BinTree.prototype.remove = function(data) {
    if(this._root === null) {
        return false;
    }

    var head = new Node$3(undefined); // fake tree root
    var node = head;
    node.right = this._root;
    var p = null; // parent
    var found = null; // found item
    var dir = 1;

    while(node.get_child(dir) !== null) {
        p = node;
        node = node.get_child(dir);
        var cmp = this._comparator(data, node.data);
        dir = cmp > 0;

        if(cmp === 0) {
            found = node;
        }
    }

    if(found !== null) {
        found.data = node.data;
        p.set_child(p.right === node, node.get_child(node.left === null));

        this._root = head.right;
        this.size--;
        return true;
    }
    else {
        return false;
    }
};

var bintree = BinTree;

var bintrees = {
    RBTree: rbtree,
    BinTree: bintree
};

/**
 * Signed area of the triangle (p0, p1, p2)
 * @param  {Array.<Number>} p0
 * @param  {Array.<Number>} p1
 * @param  {Array.<Number>} p2
 * @return {Number}
 */
var signed_area = function signedArea(p0, p1, p2) {
  return (p0[0] - p2[0]) * (p1[1] - p2[1]) - (p1[0] - p2[0]) * (p0[1] - p2[1]);
};

/**
 * Sweepline event
 *
 * @param {Array.<Number>}  point
 * @param {Boolean}         left
 * @param {SweepEvent=}     otherEvent
 * @param {Boolean}         isSubject
 * @param {Number}          edgeType
 */
function SweepEvent(point, left, otherEvent, isSubject, edgeType) {

  /**
   * Is left endpoint?
   * @type {Boolean}
   */
  this.left = left;

  /**
   * @type {Array.<Number>}
   */
  this.point = point;

  /**
   * Other edge reference
   * @type {SweepEvent}
   */
  this.otherEvent = otherEvent;

  /**
   * Belongs to source or clipping polygon
   * @type {Boolean}
   */
  this.isSubject = isSubject;

  /**
   * Edge contribution type
   * @type {Number}
   */
  this.type = edgeType || edge_type.NORMAL;


  /**
   * In-out transition for the sweepline crossing polygon
   * @type {Boolean}
   */
  this.inOut = false;


  /**
   * @type {Boolean}
   */
  this.otherInOut = false;

  /**
   * Previous event in result?
   * @type {SweepEvent}
   */
  this.prevInResult = null;

  /**
   * Does event belong to result?
   * @type {Boolean}
   */
  this.inResult = false;


  // connection step

  /**
   * @type {Boolean}
   */
  this.resultInOut = false;
}


SweepEvent.prototype = {

  /**
   * @param  {Array.<Number>}  p
   * @return {Boolean}
   */
  isBelow: function(p) {
    return this.left ?
      signed_area (this.point, this.otherEvent.point, p) > 0 :
      signed_area (this.otherEvent.point, this.point, p) > 0;
  },


  /**
   * @param  {Array.<Number>}  p
   * @return {Boolean}
   */
  isAbove: function(p) {
    return !this.isBelow(p);
  },


  /**
   * @return {Boolean}
   */
  isVertical: function() {
    return this.point[0] === this.otherEvent.point[0];
  }
};

var sweep_event = SweepEvent;

// var equals = require('./equals');

/**
 * @param  {SweepEvent} e1
 * @param  {SweepEvent} e2
 * @return {Number}
 */
var compare_events = function sweepEventsComp(e1, e2) {
  var p1 = e1.point;
  var p2 = e2.point;

  // Different x-coordinate
  if (p1[0] > p2[0]) return 1;
  if (p1[0] < p2[0]) return -1;

  // Different points, but same x-coordinate
  // Event with lower y-coordinate is processed first
  if (p1[1] !== p2[1]) return p1[1] > p2[1] ? 1 : -1;

  return specialCases(e1, e2, p1);
};


function specialCases(e1, e2, p1, p2) {
  // Same coordinates, but one is a left endpoint and the other is
  // a right endpoint. The right endpoint is processed first
  if (e1.left !== e2.left)
    return e1.left ? 1 : -1;

  // Same coordinates, both events
  // are left endpoints or right endpoints.
  // not collinear
  if (signed_area (p1, e1.otherEvent.point, e2.otherEvent.point) !== 0) {
    // the event associate to the bottom segment is processed first
    return (!e1.isBelow(e2.otherEvent.point)) ? 1 : -1;
  }

  // uncomment this if you want to play with multipolygons
  // if (e1.isSubject === e2.isSubject) {
  //   if(equals(e1.point, e2.point) && e1.contourId === e2.contourId) {
  //     return 0;
  //   } else {
  //     return e1.contourId > e2.contourId ? 1 : -1;
  //   }
  // }

  return (!e1.isSubject && e2.isSubject) ? 1 : -1;
}

var equals = function equals(p1, p2) {
  return p1[0] === p2[0] && p1[1] === p2[1];
};

/**
 * @param  {SweepEvent} le1
 * @param  {SweepEvent} le2
 * @return {Number}
 */
var compare_segments = function compareSegments(le1, le2) {
  if (le1 === le2) return 0;

  // Segments are not collinear
  if (signed_area(le1.point, le1.otherEvent.point, le2.point) !== 0 ||
    signed_area(le1.point, le1.otherEvent.point, le2.otherEvent.point) !== 0) {

    // If they share their left endpoint use the right endpoint to sort
    if (equals(le1.point, le2.point)) return le1.isBelow(le2.otherEvent.point) ? -1 : 1;

    // Different left endpoint: use the left endpoint to sort
    if (le1.point[0] === le2.point[0]) return le1.point[1] < le2.point[1] ? -1 : 1;

    // has the line segment associated to e1 been inserted
    // into S after the line segment associated to e2 ?
    if (compare_events(le1, le2) === 1) return le2.isAbove(le1.point) ? -1 : 1;

    // The line segment associated to e2 has been inserted
    // into S after the line segment associated to e1
    return le1.isBelow(le2.point) ? -1 : 1;
  }

  if (le1.isSubject === le2.isSubject) { // same polygon
    if (equals(le1.point, le2.point)) {
      if (equals(le1.otherEvent.point, le2.otherEvent.point)) {
        return 0;
      } else {
        return le1.contourId > le2.contourId ? 1 : -1;
      }
    }
  } else { // Segments are collinear, but belong to separate polygons
    return le1.isSubject ? -1 : 1;
  }

  return compare_events(le1, le2) === 1 ? 1 : -1;
};

var EPSILON = 1e-9;

/**
 * Finds the magnitude of the cross product of two vectors (if we pretend
 * they're in three dimensions)
 *
 * @param {Object} a First vector
 * @param {Object} b Second vector
 * @private
 * @returns {Number} The magnitude of the cross product
 */
function krossProduct(a, b) {
  return a[0] * b[1] - a[1] * b[0];
}

/**
 * Finds the dot product of two vectors.
 *
 * @param {Object} a First vector
 * @param {Object} b Second vector
 * @private
 * @returns {Number} The dot product
 */
function dotProduct(a, b) {
  return a[0] * b[0] + a[1] * b[1];
}

/**
 * Finds the intersection (if any) between two line segments a and b, given the
 * line segments' end points a1, a2 and b1, b2.
 *
 * This algorithm is based on Schneider and Eberly.
 * http://www.cimec.org.ar/~ncalvo/Schneider_Eberly.pdf
 * Page 244.
 *
 * @param {Array.<Number>} a1 point of first line
 * @param {Array.<Number>} a2 point of first line
 * @param {Array.<Number>} b1 point of second line
 * @param {Array.<Number>} b2 point of second line
 * @param {Boolean=}       noEndpointTouch whether to skip single touchpoints
 *                                         (meaning connected segments) as
 *                                         intersections
 * @returns {Array.<Array.<Number>>|Null} If the lines intersect, the point of
 * intersection. If they overlap, the two end points of the overlapping segment.
 * Otherwise, null.
 */
var segment_intersection = function(a1, a2, b1, b2, noEndpointTouch) {
  // The algorithm expects our lines in the form P + sd, where P is a point,
  // s is on the interval [0, 1], and d is a vector.
  // We are passed two points. P can be the first point of each pair. The
  // vector, then, could be thought of as the distance (in x and y components)
  // from the first point to the second point.
  // So first, let's make our vectors:
  var va = [a2[0] - a1[0], a2[1] - a1[1]];
  var vb = [b2[0] - b1[0], b2[1] - b1[1]];
  // We also define a function to convert back to regular point form:

  /* eslint-disable arrow-body-style */

  function toPoint(p, s, d) {
    return [
      p[0] + s * d[0],
      p[1] + s * d[1]
    ];
  }

  /* eslint-enable arrow-body-style */

  // The rest is pretty much a straight port of the algorithm.
  var e = [b1[0] - a1[0], b1[1] - a1[1]];
  var kross = krossProduct(va, vb);
  var sqrKross = kross * kross;
  var sqrLenA = dotProduct(va, va);
  var sqrLenB = dotProduct(vb, vb);

  // Check for line intersection. This works because of the properties of the
  // cross product -- specifically, two vectors are parallel if and only if the
  // cross product is the 0 vector. The full calculation involves relative error
  // to account for possible very small line segments. See Schneider & Eberly
  // for details.
  if (sqrKross > EPSILON * sqrLenA * sqrLenB) {
    // If they're not parallel, then (because these are line segments) they
    // still might not actually intersect. This code checks that the
    // intersection point of the lines is actually on both line segments.
    var s = krossProduct(e, vb) / kross;
    if (s < 0 || s > 1) {
      // not on line segment a
      return null;
    }
    var t = krossProduct(e, va) / kross;
    if (t < 0 || t > 1) {
      // not on line segment b
      return null;
    }
    return noEndpointTouch ? null : [toPoint(a1, s, va)];
  }

  // If we've reached this point, then the lines are either parallel or the
  // same, but the segments could overlap partially or fully, or not at all.
  // So we need to find the overlap, if any. To do that, we can use e, which is
  // the (vector) difference between the two initial points. If this is parallel
  // with the line itself, then the two lines are the same line, and there will
  // be overlap.
  var sqrLenE = dotProduct(e, e);
  kross = krossProduct(e, va);
  sqrKross = kross * kross;

  if (sqrKross > EPSILON * sqrLenA * sqrLenE) {
    // Lines are just parallel, not the same. No overlap.
    return null;
  }

  var sa = dotProduct(va, e) / sqrLenA;
  var sb = sa + dotProduct(va, vb) / sqrLenA;
  var smin = Math.min(sa, sb);
  var smax = Math.max(sa, sb);

  // this is, essentially, the FindIntersection acting on floats from
  // Schneider & Eberly, just inlined into this function.
  if (smin <= 1 && smax >= 0) {

    // overlap on an end point
    if (smin === 1) {
      return noEndpointTouch ? null : [toPoint(a1, smin > 0 ? smin : 0, va)];
    }

    if (smax === 0) {
      return noEndpointTouch ? null : [toPoint(a1, smax < 1 ? smax : 1, va)];
    }

    if (noEndpointTouch && smin === 0 && smax === 1) return null;

    // There's overlap on a segment -- two points of intersection. Return both.
    return [
      toPoint(a1, smin > 0 ? smin : 0, va),
      toPoint(a1, smax < 1 ? smax : 1, va),
    ];
  }

  return null;
};

var INTERSECTION    = 0;
var UNION           = 1;
var DIFFERENCE      = 2;
var XOR             = 3;

var EMPTY           = [];




var Tree            = bintrees.RBTree;







var max$2 = Math.max;
var min$2 = Math.min;

// global.Tree = Tree;
// global.compareSegments = compareSegments;
// global.SweepEvent = SweepEvent;
// global.signedArea = require('./signed_area');

/**
 * @param  {<Array.<Number>} s1
 * @param  {<Array.<Number>} s2
 * @param  {Boolean}         isSubject
 * @param  {Queue}           eventQueue
 * @param  {Array.<Number>}  bbox
 */
function processSegment(s1, s2, isSubject, depth, eventQueue, bbox) {
  // Possible degenerate condition.
  // if (equals(s1, s2)) return;

  var e1 = new sweep_event(s1, false, undefined, isSubject);
  var e2 = new sweep_event(s2, false, e1,        isSubject);
  e1.otherEvent = e2;

  e1.contourId = e2.contourId = depth;

  if (compare_events(e1, e2) > 0) {
    e2.left = true;
  } else {
    e1.left = true;
  }

  bbox[0] = min$2(bbox[0], s1[0]);
  bbox[1] = min$2(bbox[1], s1[1]);
  bbox[2] = max$2(bbox[2], s1[0]);
  bbox[3] = max$2(bbox[3], s1[1]);

  // Pushing it so the queue is sorted from left to right,
  // with object on the left having the highest priority.
  eventQueue.push(e1);
  eventQueue.push(e2);
}

var contourId = 0;

function processPolygon(polygon, isSubject, depth, queue, bbox) {
  var i, len;
  if (typeof polygon[0][0] === 'number') {
    for (i = 0, len = polygon.length - 1; i < len; i++) {
      processSegment(polygon[i], polygon[i + 1], isSubject, depth + 1, queue, bbox);
    }
  } else {
    for (i = 0, len = polygon.length; i < len; i++) {
      contourId++;
      processPolygon(polygon[i], isSubject, contourId, queue, bbox);
    }
  }
}


function fillQueue(subject, clipping, sbbox, cbbox) {
  var eventQueue = new tinyqueue(null, compare_events);
  contourId = 0;

  processPolygon(subject,  true,  0, eventQueue, sbbox);
  processPolygon(clipping, false, 0, eventQueue, cbbox);

  return eventQueue;
}


function computeFields(event, prev, sweepLine, operation) {
  // compute inOut and otherInOut fields
  if (prev === null) {
    event.inOut      = false;
    event.otherInOut = true;

  // previous line segment in sweepline belongs to the same polygon
  } else if (event.isSubject === prev.isSubject) {
    event.inOut      = !prev.inOut;
    event.otherInOut = prev.otherInOut;

  // previous line segment in sweepline belongs to the clipping polygon
  } else {
    event.inOut      = !prev.otherInOut;
    event.otherInOut = prev.isVertical() ? !prev.inOut : prev.inOut;
  }

  // compute prevInResult field
  if (prev) {
    event.prevInResult = (!inResult(prev, operation) || prev.isVertical()) ?
       prev.prevInResult : prev;
  }
  // check if the line segment belongs to the Boolean operation
  event.inResult = inResult(event, operation);
}


function inResult(event, operation) {
  switch (event.type) {
    case edge_type.NORMAL:
      switch (operation) {
        case INTERSECTION:
          return !event.otherInOut;
        case UNION:
          return event.otherInOut;
        case DIFFERENCE:
          return (event.isSubject && event.otherInOut) ||
                 (!event.isSubject && !event.otherInOut);
        case XOR:
          return true;
      }
    case edge_type.SAME_TRANSITION:
      return operation === INTERSECTION || operation === UNION;
    case edge_type.DIFFERENT_TRANSITION:
      return operation === DIFFERENCE;
    case edge_type.NON_CONTRIBUTING:
      return false;
  }
  return false;
}


/**
 * @param  {SweepEvent} se1
 * @param  {SweepEvent} se2
 * @param  {Queue}      queue
 * @return {Number}
 */
function possibleIntersection(se1, se2, queue) {
  // that disallows self-intersecting polygons,
  // did cost us half a day, so I'll leave it
  // out of respect
  // if (se1.isSubject === se2.isSubject) return;

  var inter = segment_intersection(
    se1.point, se1.otherEvent.point,
    se2.point, se2.otherEvent.point
  );

  var nintersections = inter ? inter.length : 0;
  if (nintersections === 0) return 0; // no intersection

  // the line segments intersect at an endpoint of both line segments
  if ((nintersections === 1) &&
      (equals(se1.point, se2.point) ||
       equals(se1.otherEvent.point, se2.otherEvent.point))) {
    return 0;
  }

  if (nintersections === 2 && se1.isSubject === se2.isSubject){
    if(se1.contourId === se2.contourId){
    console.warn('Edges of the same polygon overlap',
      se1.point, se1.otherEvent.point, se2.point, se2.otherEvent.point);
    }
    //throw new Error('Edges of the same polygon overlap');
    return 0;
  }

  // The line segments associated to se1 and se2 intersect
  if (nintersections === 1) {

    // if the intersection point is not an endpoint of se1
    if (!equals(se1.point, inter[0]) && !equals(se1.otherEvent.point, inter[0])) {
      divideSegment(se1, inter[0], queue);
    }

    // if the intersection point is not an endpoint of se2
    if (!equals(se2.point, inter[0]) && !equals(se2.otherEvent.point, inter[0])) {
      divideSegment(se2, inter[0], queue);
    }
    return 1;
  }

  // The line segments associated to se1 and se2 overlap
  var events        = [];
  var leftCoincide  = false;
  var rightCoincide = false;

  if (equals(se1.point, se2.point)) {
    leftCoincide = true; // linked
  } else if (compare_events(se1, se2) === 1) {
    events.push(se2, se1);
  } else {
    events.push(se1, se2);
  }

  if (equals(se1.otherEvent.point, se2.otherEvent.point)) {
    rightCoincide = true;
  } else if (compare_events(se1.otherEvent, se2.otherEvent) === 1) {
    events.push(se2.otherEvent, se1.otherEvent);
  } else {
    events.push(se1.otherEvent, se2.otherEvent);
  }

  if ((leftCoincide && rightCoincide) || leftCoincide) {
    // both line segments are equal or share the left endpoint
    se1.type = edge_type.NON_CONTRIBUTING;
    se2.type = (se1.inOut === se2.inOut) ?
      edge_type.SAME_TRANSITION :
      edge_type.DIFFERENT_TRANSITION;

    if (leftCoincide && !rightCoincide) {
      // honestly no idea, but changing events selection from [2, 1]
      // to [0, 1] fixes the overlapping self-intersecting polygons issue
      divideSegment(events[0].otherEvent, events[1].point, queue);
    }
    return 2;
  }

  // the line segments share the right endpoint
  if (rightCoincide) {
    divideSegment(events[0], events[1].point, queue);
    return 3;
  }

  // no line segment includes totally the other one
  if (events[0] !== events[3].otherEvent) {
    divideSegment(events[0], events[1].point, queue);
    divideSegment(events[1], events[2].point, queue);
    return 3;
  }

  // one line segment includes the other one
  divideSegment(events[0], events[1].point, queue);
  divideSegment(events[3].otherEvent, events[2].point, queue);

  return 3;
}


/**
 * @param  {SweepEvent} se
 * @param  {Array.<Number>} p
 * @param  {Queue} queue
 * @return {Queue}
 */
function divideSegment(se, p, queue)  {
  var r = new sweep_event(p, false, se,            se.isSubject);
  var l = new sweep_event(p, true,  se.otherEvent, se.isSubject);

  if (equals(se.point, se.otherEvent.point)) {
    console.warn('what is that?', se);
  }

  r.contourId = l.contourId = se.contourId;

  // avoid a rounding error. The left event would be processed after the right event
  if (compare_events(l, se.otherEvent) > 0) {
    se.otherEvent.left = true;
    l.left = false;
  }

  // avoid a rounding error. The left event would be processed after the right event
  // if (compareEvents(se, r) > 0) {}

  se.otherEvent.otherEvent = l;
  se.otherEvent = r;

  queue.push(l);
  queue.push(r);

  return queue;
}
/* eslint-enable no-unused-vars, no-debugger */


function subdivideSegments(eventQueue, subject, clipping, sbbox, cbbox, operation) {
  var sortedEvents = [];
  var prev, next;

  var sweepLine = new Tree(compare_segments);
  var sortedEvents = [];

  var rightbound = min$2(sbbox[2], cbbox[2]);

  var prev, next;

  while (eventQueue.length) {
    var event = eventQueue.pop();
    sortedEvents.push(event);

    // optimization by bboxes for intersection and difference goes here
    if ((operation === INTERSECTION && event.point[0] > rightbound) ||
        (operation === DIFFERENCE   && event.point[0] > sbbox[2])) {
      break;
    }

    if (event.left) {
      sweepLine.insert(event);
      // _renderSweepLine(sweepLine, event.point, event);

      next = sweepLine.findIter(event);
      prev = sweepLine.findIter(event);
      event.iterator = sweepLine.findIter(event);

      // Cannot get out of the tree what we just put there
      if (!prev || !next) {
        console.log('brute');
        var iterators = findIterBrute(sweepLine);
        prev = iterators[0];
        next = iterators[1];
      }

      if (prev.data() !== sweepLine.min()) {
        prev.prev();
      } else {
        prev = sweepLine.iterator(); //findIter(sweepLine.max());
        prev.prev();
        prev.next();
      }
      next.next();

      computeFields(event, prev.data(), sweepLine, operation);

      if (next.data()) {
        if (possibleIntersection(event, next.data(), eventQueue) === 2) {
          computeFields(event, prev.data(), sweepLine, operation);
          computeFields(event, next.data(), sweepLine, operation);
        }
      }

      if (prev.data()) {
        if (possibleIntersection(prev.data(), event, eventQueue) === 2) {
          var prevprev = sweepLine.findIter(prev.data());
          if (prevprev.data() !== sweepLine.min()) {
            prevprev.prev();
          } else {
            prevprev = sweepLine.findIter(sweepLine.max());
            prevprev.next();
          }
          computeFields(prev.data(), prevprev.data(), sweepLine, operation);
          computeFields(event, prev.data(), sweepLine, operation);
        }
      }
    } else {
      event = event.otherEvent;
      next = sweepLine.findIter(event);
      prev = sweepLine.findIter(event);

      // _renderSweepLine(sweepLine, event.otherEvent.point, event);

      if (!(prev && next)) continue;

      if (prev.data() !== sweepLine.min()) {
        prev.prev();
      } else {
        prev = sweepLine.iterator();
        prev.prev(); // sweepLine.findIter(sweepLine.max());
        prev.next();
      }
      next.next();
      sweepLine.remove(event);

      //_renderSweepLine(sweepLine, event.otherEvent.point, event);

      if (next.data() && prev.data()) {
        possibleIntersection(prev.data(), next.data(), eventQueue);
      }
    }
  }
  return sortedEvents;
}

function findIterBrute(sweepLine, q) {
  var prev = sweepLine.iterator();
  var next = sweepLine.iterator();
  var it   = sweepLine.iterator(), data;
  while((data = it.next()) !== null) {
    prev.next();
    next.next();
    if (data === event) {
      break;
    }
  }
  return [prev, next];
}


function swap$1 (arr, i, n) {
  var temp = arr[i];
  arr[i] = arr[n];
  arr[n] = temp;
}


function changeOrientation(contour) {
  return contour.reverse();
}


function isArray (arr) {
  return Object.prototype.toString.call(arr) === '[object Array]';
}


function addHole(contour, idx) {
  if (isArray(contour[0]) && !isArray(contour[0][0])) {
    contour = [contour];
  }
  contour[idx] = [];
  return contour;
}


/**
 * @param  {Array.<SweepEvent>} sortedEvents
 * @return {Array.<SweepEvent>}
 */
function orderEvents(sortedEvents) {
  var event, i, len;
  var resultEvents = [];
  for (i = 0, len = sortedEvents.length; i < len; i++) {
    event = sortedEvents[i];
    if ((event.left && event.inResult) ||
      (!event.left && event.otherEvent.inResult)) {
      resultEvents.push(event);
    }
  }

  // Due to overlapping edges the resultEvents array can be not wholly sorted
  var sorted = false;
  while (!sorted) {
    sorted = true;
    for (i = 0, len = resultEvents.length; i < len; i++) {
      if ((i + 1) < len &&
        compare_events(resultEvents[i], resultEvents[i + 1]) === 1) {
        swap$1(resultEvents, i, i + 1);
        sorted = false;
      }
    }
  }

  for (i = 0, len = resultEvents.length; i < len; i++) {
    resultEvents[i].pos = i;
  }

  for (i = 0, len = resultEvents.length; i < len; i++) {
    if (!resultEvents[i].left) {
      var temp = resultEvents[i].pos;
      resultEvents[i].pos = resultEvents[i].otherEvent.pos;
      resultEvents[i].otherEvent.pos = temp;
    }
  }

  return resultEvents;
}


/**
 * @param  {Array.<SweepEvent>} sortedEvents
 * @return {Array.<*>} polygons
 */
function connectEdges(sortedEvents) {
  var i, len;
  var resultEvents = orderEvents(sortedEvents);


  // "false"-filled array
  var processed = Array(resultEvents.length);
  var result = [];

  var depth  = [];
  var holeOf = [];
  var isHole = {};

  for (i = 0, len = resultEvents.length; i < len; i++) {
    if (processed[i]) continue;

    var contour = [];
    result.push(contour);

    var ringId = result.length - 1;
    depth.push(0);
    holeOf.push(-1);


    if (resultEvents[i].prevInResult) {
      var lowerContourId = resultEvents[i].prevInResult.contourId;
      if (!resultEvents[i].prevInResult.resultInOut) {
        addHole(result[lowerContourId], ringId);
        holeOf[ringId] = lowerContourId;
        depth[ringId]  = depth[lowerContourId] + 1;
        isHole[ringId] = true;
      } else if (isHole[lowerContourId]) {
        addHole(result[holeOf[lowerContourId]], ringId);
        holeOf[ringId] = holeOf[lowerContourId];
        depth[ringId]  = depth[lowerContourId];
        isHole[ringId] = true;
      }
    }

    var pos = i;
    var initial = resultEvents[i].point;
    contour.push(initial);

    while (pos >= i) {
      processed[pos] = true;

      if (resultEvents[pos].left) {
        resultEvents[pos].resultInOut = false;
        resultEvents[pos].contourId   = ringId;
      } else {
        resultEvents[pos].otherEvent.resultInOut = true;
        resultEvents[pos].otherEvent.contourId   = ringId;
      }

      pos = resultEvents[pos].pos;
      processed[pos] = true;

      contour.push(resultEvents[pos].point);
      pos = nextPos(pos, resultEvents, processed);
    }

    pos = pos === -1 ? i : pos;

    processed[pos] = processed[resultEvents[pos].pos] = true;
    resultEvents[pos].otherEvent.resultInOut = true;
    resultEvents[pos].otherEvent.contourId   = ringId;


    // depth is even
    /* eslint-disable no-bitwise */
    if (depth[ringId] & 1) {
      changeOrientation(contour);
    }
    /* eslint-enable no-bitwise */
  }

  return result;
}


/**
 * @param  {Number} pos
 * @param  {Array.<SweepEvent>} resultEvents
 * @param  {Array.<Boolean>}    processed
 * @return {Number}
 */
function nextPos(pos, resultEvents, processed) {
  var newPos = pos + 1;
  var length = resultEvents.length;
  while (newPos < length &&
         equals(resultEvents[newPos].point, resultEvents[pos].point)) {
    if (!processed[newPos]) {
      return newPos;
    } else {
      newPos = newPos + 1;
    }
  }

  newPos = pos - 1;

  while (processed[newPos]) {
    newPos = newPos - 1;
  }
  return newPos;
}


function trivialOperation(subject, clipping, operation) {
  var result = null;
  if (subject.length * clipping.length === 0) {
    if (operation === INTERSECTION) {
      result = EMPTY;
    } else if (operation === DIFFERENCE) {
      result = subject;
    } else if (operation === UNION || operation === XOR) {
      result = (subject.length === 0) ? clipping : subject;
    }
  }
  return result;
}


function compareBBoxes(subject, clipping, sbbox, cbbox, operation) {
  var result = null;
  if (sbbox[0] > cbbox[2] ||
      cbbox[0] > sbbox[2] ||
      sbbox[1] > cbbox[3] ||
      cbbox[1] > sbbox[3]) {
    if (operation === INTERSECTION) {
      result = EMPTY;
    } else if (operation === DIFFERENCE) {
      result = subject;
    } else if (operation === UNION || operation === XOR) {
      result = subject.concat(clipping);
    }
  }
  return result;
}


function boolean(subject, clipping, operation) {
  var trivial = trivialOperation(subject, clipping, operation);
  if (trivial) {
    return trivial === EMPTY ? null : trivial;
  }
  var sbbox = [Infinity, Infinity, -Infinity, -Infinity];
  var cbbox = [Infinity, Infinity, -Infinity, -Infinity];

  var eventQueue = fillQueue(subject, clipping, sbbox, cbbox);

  trivial = compareBBoxes(subject, clipping, sbbox, cbbox, operation);
  if (trivial) {
    return trivial === EMPTY ? null : trivial;
  }
  var sortedEvents = subdivideSegments(eventQueue, subject, clipping, sbbox, cbbox, operation);
  return connectEdges(sortedEvents);
}


var src$1 = boolean;


var union = function(subject, clipping) {
  return boolean(subject, clipping, UNION);
};


var diff = function(subject, clipping) {
  return boolean(subject, clipping, DIFFERENCE);
};


var xor = function(subject, clipping) {
  return boolean(subject, clipping, XOR);
};


var intersection_1 = function(subject, clipping) {
  return boolean(subject, clipping, INTERSECTION);
};


/**
 * @enum {Number}
 */
var operations = {
  INTERSECTION: INTERSECTION,
  DIFFERENCE:   DIFFERENCE,
  UNION:        UNION,
  XOR:          XOR
};


// for testing
var fillQueue_1            = fillQueue;
var computeFields_1        = computeFields;
var subdivideSegments_1    = subdivideSegments;
var divideSegment_1        = divideSegment;
var possibleIntersection_1 = possibleIntersection;
src$1.union = union;
src$1.diff = diff;
src$1.xor = xor;
src$1.intersection = intersection_1;
src$1.operations = operations;
src$1.fillQueue = fillQueue_1;
src$1.computeFields = computeFields_1;
src$1.subdivideSegments = subdivideSegments_1;
src$1.divideSegment = divideSegment_1;
src$1.possibleIntersection = possibleIntersection_1;

var martinezPolygonClipping = src$1;

var utils = createCommonjsModule(function (module) {
/**
 * @param  {*} arr
 * @return {Boolean}
 */
var isArray = module.exports.isArray = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) === '[object Array]';
};


/**
 * @param  {Array.<Number>} p1
 * @param  {Array.<Number>} p2
 * @return {Boolean}
 */
module.exports.equals = function equals(p1, p2) {
  return p1[0] === p2[0] && p1[1] === p2[1];
};


/**
 * @param  {*}       coordinates
 * @param  {Number=} depth
 * @return {*}
 */
module.exports.orientRings = function orientRings(coordinates, depth, isHole) {
  depth = depth || 0;
  var i, len;
  if (isArray(coordinates) && typeof coordinates[0][0] === 'number') {
    var area = 0;
    var ring = coordinates;

    for (i = 0, len = ring.length; i < len; i++) {
      var pt1 = ring[i];
      var pt2 = ring[(i + 1) % len];
      area += pt1[0] * pt2[1];
      area -= pt2[0] * pt1[1];
    }
    if ((!isHole && area > 0) || (isHole && area < 0)) {
      ring.reverse();
    }
  } else {
    for (i = 0, len = coordinates.length; i < len; i++) {
      orientRings(coordinates[i], depth + 1, i > 0);
    }
  }

  return coordinates;
};
});
var utils_1 = utils.isArray;
var utils_2 = utils.equals;
var utils_3 = utils.orientRings;

var isArray$1     = utils.isArray;
var equals$1      = utils.equals;
var orientRings = utils.orientRings;


/**
 * Offset builder
 *
 * @param {Array.<Object>=} vertices
 * @param {Number=}        arcSegments
 * @constructor
 */
function Offset(vertices, arcSegments) {

  /**
   * @type {Array.<Object>}
   */
  this.vertices = null;

  /**
   * @type {Array.<Edge>}
   */
  this.edges = null;

  /**
   * @type {Boolean}
   */
  this._closed = false;


  /**
   * @type {Number}
   */
  this._distance = 0;

  if (vertices) {
    this.data(vertices);
  }

  /**
   * Segments in edge bounding arches
   * @type {Number}
   */
  this._arcSegments = arcSegments !== undefined ? arcSegments : 5;
}

/**
 * Change data set
 * @param  {Array.<Array>} vertices
 * @return {Offset}
 */
Offset.prototype.data = function(vertices) {
  this._edges = [];
  if (!isArray$1 (vertices)) {
    throw new Error('Offset requires at least one coodinate to work with');
  }

  if (isArray$1(vertices) && typeof vertices[0] === 'number') {
    this.vertices = vertices;
  } else {
    this.vertices = orientRings(vertices);
    this._processContour(this.vertices, this._edges);
  }

  return this;
};


/**
 * Recursively process contour to create normals
 * @param  {*} contour
 * @param  {Array} edges
 */
Offset.prototype._processContour = function(contour, edges) {
  var i, len;
  if (isArray$1(contour[0]) && typeof contour[0][0] === 'number') {
    len = contour.length;
    if (equals$1(contour[0], contour[len - 1])) {
      len -= 1; // otherwise we get division by zero in normals
    }
    for (i = 0; i < len; i++) {
      edges.push(new edge(contour[i], contour[(i + 1) % len]));
    }
  } else {
    for (i = 0, len = contour.length; i < len; i++) {
      edges.push([]);
      this._processContour(contour[i], edges[edges.length - 1]);
    }
  }
};


/**
 * @param  {Number} arcSegments
 * @return {Offset}
 */
Offset.prototype.arcSegments = function(arcSegments) {
  this._arcSegments = arcSegments;
  return this;
};


/**
 * Validates if the first and last points repeat
 * TODO: check CCW
 *
 * @param  {Array.<Object>} vertices
 */
Offset.prototype.validate = function(vertices) {
  var len = vertices.length;
  if (typeof vertices[0] === 'number') return [vertices];
  if (vertices[0][0] === vertices[len - 1][0] &&
    vertices[0][1] === vertices[len - 1][1]) {
    if (len > 1) {
      vertices = vertices.slice(0, len - 1);
      this._closed = true;
    }
  }
  return vertices;
};


/**
 * Creates arch between two edges
 *
 * @param  {Array.<Object>} vertices
 * @param  {Object}         center
 * @param  {Number}         radius
 * @param  {Object}         startVertex
 * @param  {Object}         endVertex
 * @param  {Number}         segments
 * @param  {Boolean}        outwards
 */
Offset.prototype.createArc = function(vertices, center, radius, startVertex,
    endVertex, segments, outwards) {

  var PI2 = Math.PI * 2,
      startAngle = Math.atan2(startVertex[1] - center[1], startVertex[0] - center[0]),
      endAngle   = Math.atan2(endVertex[1] - center[1], endVertex[0] - center[0]);

  // odd number please
  if (segments % 2 === 0) {
    segments -= 1;
  }

  if (startAngle < 0) {
    startAngle += PI2;
  }

  if (endAngle < 0) {
    endAngle += PI2;
  }

  var angle = ((startAngle > endAngle) ?
               (startAngle - endAngle) :
               (startAngle + PI2 - endAngle)),
      segmentAngle = ((outwards) ? -angle : PI2 - angle) / segments;

  vertices.push(startVertex);
  for (var i = 1; i < segments; ++i) {
    angle = startAngle + segmentAngle * i;
    vertices.push([
      center[0] + Math.cos(angle) * radius,
      center[1] + Math.sin(angle) * radius
    ]);
  }
  vertices.push(endVertex);
  return vertices;
};


/**
 * @param  {Number}  dist
 * @param  {String=} units
 * @return {Offset}
 */
Offset.prototype.distance = function(dist, units) {
  this._distance = dist || 0;
  return this;
};


/**
 * @static
 * @param  {Number}  degrees
 * @param  {String=} units
 * @return {Number}
 */
Offset.degreesToUnits = function(degrees, units) {
  switch (units) {
    case 'miles':
      degrees = degrees / 69.047;
    break;
    case 'feet':
      degrees = degrees / 364568.0;
      break;
    case 'kilometers':
      degrees = degrees / 111.12;
      break;
    case 'meters':
    case 'metres':
      degrees = degrees / 111120.0;
      break;
  }
  return degrees;
};


/**
 * @param  {Array.<Object>} vertices
 * @return {Array.<Object>}
 */
Offset.prototype.ensureLastPoint = function(vertices) {
  if (!equals$1(vertices[0], vertices[vertices.length - 1])) {
    vertices.push([
      vertices[0][0],
      vertices[0][1]
    ]);
  }
  return vertices;
};


/**
 * Decides by the sign if it's a padding or a margin
 *
 * @param  {Number} dist
 * @return {Array.<Object>}
 */
Offset.prototype.offset = function(dist) {
  this.distance(dist);
  return this._distance === 0 ? this.vertices :
      (this._distance > 0 ? this.margin(this._distance) :
        this.padding(-this._distance));
};


/**
 * @param  {Array.<Array.<Number>>} vertices
 * @param  {Array.<Number>}         pt1
 * @param  {Array.<Number>}         pt2
 * @param  {Number}                 dist
 * @return {Array.<Array.<Number>>}
 */
Offset.prototype._offsetSegment = function(v1, v2, e1, dist) {
  var vertices = [];
  var offsets = [
    e1.offset(e1._inNormal[0] * dist, e1._inNormal[1] * dist),
    e1.inverseOffset(e1._outNormal[0] * dist, e1._outNormal[1] * dist)
  ];

  for (var i = 0, len = 2; i < len; i++) {
    var thisEdge = offsets[i],
        prevEdge = offsets[(i + len - 1) % len];
    this.createArc(
              vertices,
              i === 0 ? v1 : v2, // edges[i].current, // p1 or p2
              dist,
              prevEdge.next,
              thisEdge.current,
              this._arcSegments,
              true
            );
  }

  return vertices;
};


/**
 * @param  {Number} dist
 * @return {Array.<Number>}
 */
Offset.prototype.margin = function(dist) {
  this.distance(dist);

  if (typeof this.vertices[0] === 'number') { // point
    return this.offsetPoint(this._distance);
  }

  if (dist === 0) return this.vertices;

  var union = this.offsetLines(this._distance);
  //return union;
  union = martinezPolygonClipping.union(this.vertices, union);
  return orientRings(union);
};


/**
 * @param  {Number} dist
 * @return {Array.<Number>}
 */
Offset.prototype.padding = function(dist) {
  this.distance(dist);

  if (this._distance === 0) return this.ensureLastPoint(this.vertices);
  if (this.vertices.length === 2 && typeof this.vertices[0] === 'number') {
    return this.vertices;
  }

  var union = this.offsetLines(this._distance);
  var diff = martinezPolygonClipping.diff(this.vertices, union);
  return orientRings(diff);
};


/**
 * Creates margin polygon
 * @param  {Number} dist
 * @return {Array.<Object>}
 */
Offset.prototype.offsetLine = function(dist) {
  if (dist === 0) return this.vertices;
  return orientRings(this.offsetLines(dist));
};


/**
 * Just offsets lines, no fill
 * @param  {Number} dist
 * @return {Array.<Array.<Array.<Number>>>}
 */
Offset.prototype.offsetLines = function(dist) {
  if (dist < 0) throw new Error('Cannot apply negative margin to the line');
  var union;
  this.distance(dist);
  if (isArray$1(this.vertices[0]) && typeof this.vertices[0][0] !== 'number') {
    for (var i = 0, len = this._edges.length; i < len; i++) {
      union = (i === 0) ?
        this.offsetContour(this.vertices[i], this._edges[i]):
        martinezPolygonClipping.union(union, this.offsetContour(this.vertices[i], this._edges[i]));
    }
  } else {
    union = (this.vertices.length === 1) ?
      this.offsetPoint() :
      this.offsetContour(this.vertices, this._edges);
  }

  return union;
};


/**
 * @param  {Array.<Array.<Number>>|Array.<Array.<...>>} curve
 * @param  {Array.<Edge>|Array.<Array.<...>>} edges
 * @return {Polygon}
 */
Offset.prototype.offsetContour = function(curve, edges) {
  var union, i, len;
  if (isArray$1(curve[0]) && typeof curve[0][0] === 'number') {
    // we have 1 less edge than vertices
    for (i = 0, len = curve.length - 1; i < len; i++) {
      var segment = this.ensureLastPoint(
        this._offsetSegment(curve[i], curve[i + 1], edges[i], this._distance)
      );
      union = (i === 0) ?
                [this.ensureLastPoint(segment)] :
                martinezPolygonClipping.union(union, this.ensureLastPoint(segment));
    }
  } else {
    for (i = 0, len = edges.length; i < len; i++) {
      union = (i === 0) ?
        this.offsetContour(curve[i], edges[i]) :
        martinezPolygonClipping.union(union, this.offsetContour(curve[i], edges[i]));
    }
  }
  return union;
};


/**
 * @param  {Number} distance
 * @return {Array.<Array.<Number>}
 */
Offset.prototype.offsetPoint = function(distance) {
  this.distance(distance);
  var vertices = this._arcSegments * 2;
  var points   = [];
  var center   = this.vertices;
  var radius   = this._distance;
  var angle    = 0;

  if (vertices % 2 === 0) vertices++;

  for (var i = 0; i < vertices; i++) {
    angle += (2 * Math.PI / vertices); // counter-clockwise
    points.push([
      center[0] + (radius * Math.cos(angle)),
      center[1] + (radius * Math.sin(angle))
    ]);
  }

  return orientRings([this.ensureLastPoint(points)]);
};


Offset.orientRings = orientRings;

var offset = Offset;

var SubjectCustom_1 = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireDefault(React$1__default);

var _Subject2 = _interopRequireDefault(Subject_1);

var _propTypes = _interopRequireDefault(propTypes$1);

var _Handle = _interopRequireDefault(Handle_1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var SubjectCustom =
/*#__PURE__*/
function (_Subject) {
  _inherits(SubjectCustom, _Subject);

  function SubjectCustom() {
    _classCallCheck(this, SubjectCustom);

    return _possibleConstructorReturn(this, _getPrototypeOf(SubjectCustom).apply(this, arguments));
  }

  _createClass(SubjectCustom, [{
    key: "render",
    value: function render() {
      var _this$props = this.props,
          _this$props$custom = _this$props.custom,
          custom = _this$props$custom === void 0 ? "M0,0" : _this$props$custom,
          editMode = _this$props.editMode,
          transform = _this$props.transform;
      var handles;

      if (editMode) {
        handles = _react.default.createElement(_Handle.default, {
          handleStart: this.props.dragStart,
          handleStop: this.props.dragEnd,
          handleDrag: this.props.dragSubject
        });
      }

      return _react.default.createElement("g", {
        className: "annotation-subject"
      }, _react.default.createElement("g", {
        transform: transform
      }, typeof custom === "string" ? _react.default.createElement("path", {
        d: custom,
        pointerEvents: "none"
      }) : _react.default.createElement("g", {
        pointerEvents: "none"
      }, custom)), handles);
    }
  }]);

  return SubjectCustom;
}(_Subject2.default);

exports.default = SubjectCustom;
SubjectCustom.propTypes = {
  editMode: _propTypes.default.bool
};
});

unwrapExports(SubjectCustom_1);

var AnnotationCalloutCustom_1 = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = AnnotationCalloutCustom;

var _SubjectCustom = _interopRequireDefault(SubjectCustom_1);

var _ConnectorElbow = _interopRequireDefault(ConnectorElbow_1);

var _classnames = _interopRequireDefault(classnames);

var _Type = _interopRequireDefault(Type);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function AnnotationCalloutCustom(props) {
  var className = (0, _classnames.default)("callout custom", props.className);
  return (0, _Type.default)(_objectSpread({}, props, {
    className: className
  }), _ConnectorElbow.default, {
    lineType: "horizontal"
  }, _SubjectCustom.default);
}
});

var AnnotationCalloutCustom = unwrapExports(AnnotationCalloutCustom_1);

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

var AnnotationLabel_1 = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = AnnotationLabel;

var _classnames = _interopRequireDefault(classnames);

var _Type = _interopRequireDefault(Type);

var _ConnectorLine = _interopRequireDefault(ConnectorLine_1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function AnnotationLabel(props) {
  var className = (0, _classnames.default)("label", props.className);
  return (0, _Type.default)(_objectSpread({}, props, {
    className: className
  }), _ConnectorLine.default, {
    align: "middle"
  });
}
});

var AnnotationLabel = unwrapExports(AnnotationLabel_1);

const interactivityFns = ['onDragEnd', 'onDragStart', 'onDrag'];

const InternalAnnotation = props => {
  const {
    noteData: baseNoteData
  } = props;
  const {
    screenCoordinates
  } = baseNoteData;
  const noteData = { ...baseNoteData
  };
  interactivityFns.forEach(d => {
    if (baseNoteData[d]) {
      delete noteData[d];
      const originalFn = baseNoteData[d];

      noteData[d] = updatedSettingsFromRA => {
        originalFn({
          originalSettings: baseNoteData,
          updatedSettings: updatedSettingsFromRA,
          noteIndex: baseNoteData.i
        });
      };
    }
  });
  const AnnotationType = typeof noteData.type === 'function' ? noteData.type : AnnotationLabel;
  const eventListeners = noteData.eventListeners || noteData.events || {};
  const finalStyle = {};

  if (noteData.events || noteData.eventListeners || noteData.editMode) {
    finalStyle.pointerEvents = 'all';
  }

  if (noteData.coordinates && screenCoordinates) {
    //Multisubject annotation
    const setNX = noteData.nx || screenCoordinates[0][0] + noteData.dx;
    const setNY = noteData.ny || screenCoordinates[0][1] + noteData.dy;
    const notes = screenCoordinates.map((d, i) => {
      const subjectNote = Object.assign({}, noteData, {
        note: i === 0 ? noteData.note : {
          label: ''
        },
        x: d[0],
        y: d[1],
        nx: setNX,
        ny: setNY
      });
      return React$1.createElement(AnnotationType, _extends({
        key: `multi-annotation-${i}`
      }, subjectNote));
    });
    return React$1.createElement("g", _extends({}, eventListeners, {
      style: finalStyle
    }), notes);
  }

  const finalAnnotation = React$1.createElement(AnnotationType, _extends({
    events: eventListeners
  }, noteData));

  if (finalStyle.pointerEvents) {
    return React$1.createElement("g", {
      style: finalStyle
    }, finalAnnotation);
  }

  return finalAnnotation;
};

const HullEnclosure = ({
  points,
  d,
  i
}) => {
  const {
    color = 'black',
    dx = -25,
    dy = -25,
    label,
    padding = 10,
    buffer = padding,
    strokeWidth = 10
  } = d;
  const hullPoints = polygonHull(points);
  const offset$1 = new offset();
  const bufferedHull = offset$1.data([...hullPoints, hullPoints[0]]).margin(buffer)[0];
  const hullD = `M${bufferedHull.map(d => d.join(',')).join('L')}Z`;
  const firstCoord = bufferedHull[0];
  const {
    nx = firstCoord[0] + dx,
    ny = firstCoord[1] + dy
  } = d;
  const closestCoordinates = bufferedHull.reduce((p, c) => {
    if (Math.hypot(nx - p[0], ny - p[1]) > Math.hypot(nx - c[0], ny - c[1])) {
      p = c;
    }

    return p;
  }, firstCoord);
  const noteData = Object.assign({
    dx: dx,
    dy: dy,
    note: {
      label
    },
    connector: {
      end: 'arrow'
    }
  }, d, {
    type: AnnotationCalloutCustom,
    x: closestCoordinates[0],
    y: closestCoordinates[1],
    subject: {
      custom: [React$1.createElement("path", {
        key: "hull-drawing",
        d: hullD,
        strokeWidth: strokeWidth,
        strokeMiterlimit: "10",
        strokeLinejoin: "miter",
        strokeLinecap: "butt",
        fill: "none",
        stroke: color,
        transform: `translate(${-closestCoordinates[0]},${-closestCoordinates[1]})`
      })],
      customID: 'hull-annotation'
    }
  });
  return React$1.createElement(InternalAnnotation, {
    key: d.key || `annotation-${i}`,
    noteData: noteData
  });
};

var rect = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});



exports.default = function (_ref) {
  var _ref$width = _ref.width,
      width = _ref$width === undefined ? 100 : _ref$width,
      _ref$height = _ref.height,
      height = _ref$height === undefined ? 100 : _ref$height,
      editMode = _ref.editMode;

  var handles = [];

  var data = [[0, 0], [width, 0], [width, height], [0, height], [0, 0]];
  var rect = (0, Builder.lineBuilder)({ data: data, className: "subject" });

  if (editMode) {
    handles = [{ x: width, y: height / 2, key: "width" }, { x: width / 2, y: height, key: "height" }];
  }
  rect.attrs["fill-opacity"] = 0.1;
  return { components: [rect], handles: handles };
};
});

unwrapExports(rect);

var SubjectRect_1 = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireDefault(React$1__default);

var _rect = _interopRequireDefault(rect);

var _Subject2 = _interopRequireDefault(Subject_1);

var _propTypes = _interopRequireDefault(propTypes$1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var SubjectRect =
/*#__PURE__*/
function (_Subject) {
  _inherits(SubjectRect, _Subject);

  function SubjectRect() {
    var _getPrototypeOf2;

    var _this;

    _classCallCheck(this, SubjectRect);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(SubjectRect)).call.apply(_getPrototypeOf2, [this].concat(args)));

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "name", "SubjectRect");

    return _this;
  }

  _createClass(SubjectRect, [{
    key: "getComponents",
    value: function getComponents(_ref) {
      var _ref$width = _ref.width,
          width = _ref$width === void 0 ? 100 : _ref$width,
          _ref$height = _ref.height,
          height = _ref$height === void 0 ? 100 : _ref$height,
          editMode = _ref.editMode;
      var components = (0, _rect.default)({
        width: width,
        height: height,
        editMode: editMode
      });
      components.handleKeys = {
        width: width,
        height: height
      };

      components.handleFunction = function (h, data) {
        return _defineProperty({}, h.key, h.key === "width" ? width + data.oDeltaX : height + data.oDeltaY);
      };

      return components;
    }
  }]);

  return SubjectRect;
}(_Subject2.default);

exports.default = SubjectRect;
SubjectRect.propTypes = {
  width: _propTypes.default.number,
  height: _propTypes.default.number,
  editMode: _propTypes.default.bool
};
});

unwrapExports(SubjectRect_1);

var AnnotationCalloutRect_1 = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = AnnotationCalloutRect;

var _SubjectRect = _interopRequireDefault(SubjectRect_1);

var _ConnectorElbow = _interopRequireDefault(ConnectorElbow_1);

var _classnames = _interopRequireDefault(classnames);

var _Type = _interopRequireDefault(Type);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function AnnotationCalloutRect(props) {
  var className = (0, _classnames.default)("callout rect", props.className);
  return (0, _Type.default)(_objectSpread({}, props, {
    className: className
  }), _ConnectorElbow.default, {
    lineType: "horizontal"
  }, _SubjectRect.default, {
    width: 100,
    height: 100
  });
}
});

var AnnotationCalloutRect = unwrapExports(AnnotationCalloutRect_1);

const RectangleEnclosure = ({
  bboxNodes,
  d,
  i
}) => {
  const {
    padding = 0,
    dx = -25,
    dy = -25,
    label
  } = d;
  const bbox = [[Math.min(...bboxNodes.map(p => p.x0)) - padding, Math.min(...bboxNodes.map(p => p.y0)) - padding], [Math.max(...bboxNodes.map(p => p.x1)) + padding, Math.max(...bboxNodes.map(p => p.y1)) + padding]];
  const noteData = Object.assign({
    dx: dx,
    dy: dy,
    note: {
      label
    },
    connector: {
      end: 'arrow'
    }
  }, d, {
    type: AnnotationCalloutRect,
    x: bbox[0][0],
    y: bbox[0][1],
    subject: {
      width: bbox[1][0] - bbox[0][0],
      height: bbox[1][1] - bbox[0][1]
    }
  });
  return React$1.createElement(InternalAnnotation, {
    key: d.key || `annotation-${i}`,
    noteData: noteData
  });
};

const CircleEnclosure = ({
  d,
  i,
  circle
}) => {
  const {
    padding = 2,
    radiusPadding = padding,
    label
  } = d;
  const noteData = Object.assign({
    dx: 0,
    dy: 0,
    note: {
      label
    },
    connector: {
      end: 'arrow'
    }
  }, d, {
    coordinates: undefined,
    x: circle.x,
    y: circle.y,
    type: AnnotationCalloutCircle,
    subject: {
      radius: circle.r,
      radiusPadding
    },
    i
  });

  if (noteData.rp) {
    switch (noteData.rp) {
      case 'top':
        noteData.dx = 0;
        noteData.dy = -circle.r - noteData.rd;
        break;

      case 'bottom':
        noteData.dx = 0;
        noteData.dy = circle.r + noteData.rd;
        break;

      case 'left':
        noteData.dx = -circle.r - noteData.rd;
        noteData.dy = 0;
        break;

      default:
        noteData.dx = circle.r + noteData.rd;
        noteData.dy = 0;
    }
  } //TODO: Support .ra (setting angle)


  return React$1.createElement(InternalAnnotation, {
    key: d.key || `annotation-${i}`,
    noteData: noteData
  });
};

const SpanOrDiv = props => {
  const {
    style,
    className,
    children,
    span
  } = props;
  return span === true ? React$1__default.createElement("span", {
    className: className,
    style: {
      display: 'block',
      ...style
    }
  }, children) : React$1__default.createElement("div", {
    className: className,
    style: style
  }, children);
};

SpanOrDiv.propTypes = {
  style: propTypes.object,
  className: propTypes.string,
  span: propTypes.bool
};

const htmlFrameHoverRule = ({
  d: baseD,
  i,
  tooltipContent,
  useSpans,
  nodes,
  edges,
  nodeIDAccessor
}) => {
  const d = baseD.x && baseD.y ? baseD : baseD.edge ? { ...(edges.find(p => nodeIDAccessor(p.source) === nodeIDAccessor(baseD.source) && nodeIDAccessor(p.target) === nodeIDAccessor(baseD.target)) || {}),
    ...baseD
  } : nodes.find(p => nodeIDAccessor(p) === baseD.id);
  if (!d) return null;
  let content = d.edge ? React$1.createElement(SpanOrDiv, {
    span: useSpans,
    className: "tooltip-content"
  }, React$1.createElement("p", {
    key: "html-annotation-content-1"
  }, (d.source || d.edge.source).id, " to ", (d.target || d.edge.target).id)) : React$1.createElement(SpanOrDiv, {
    span: useSpans,
    className: "tooltip-content"
  }, React$1.createElement("p", {
    key: "html-annotation-content-1"
  }, d.id), React$1.createElement("p", {
    key: "html-annotation-content-2"
  }, "Degree: ", d.degree));

  if (d.type === 'frame-hover' && tooltipContent) {
    content = tooltipContent(d);
  }

  return React$1.createElement(SpanOrDiv, {
    span: useSpans,
    key: `network-annotation-label-${i}`,
    className: `annotation annotation-network-label ${d.className || ''}`,
    style: {
      position: 'absolute',
      top: `${d.y}px`,
      left: `${d.x}px`
    }
  }, content);
};
const svgNodeRule = ({
  d,
  i,
  nodeSizeAccessor
}) => {
  if (!d) {
    return null;
  }

  const noteData = Object.assign({
    dx: d.dx || -25,
    dy: d.dy || -25,
    x: d.x,
    y: d.y,
    note: {
      label: d.label,
      orientation: d.orientation,
      align: d.align
    },
    connector: {
      end: 'arrow'
    }
  }, d, {
    type: AnnotationCalloutCircle,
    subject: {
      radius: d.radius || d.radius || nodeSizeAccessor(d)
    }
  });
  return React$1.createElement(Annotation, {
    key: d.key || `annotation-${i}`,
    noteData: noteData
  });
};
const svgReactAnnotationRule = ({
  d,
  i,
  projectedNodes,
  nodeIDAccessor
}) => {
  const selectedNode = d.x && d.y ? d : projectedNodes.find(p => nodeIDAccessor(p) === d.id);

  if (!selectedNode) {
    return null;
  }

  const noteData = Object.assign({
    dx: 0,
    dy: 0,
    x: selectedNode.x,
    y: selectedNode.y,
    note: {
      label: d.label
    },
    connector: {
      end: 'arrow'
    }
  }, d, {
    type: typeof d.type === 'function' ? d.type : undefined
  });
  return React$1.createElement(Annotation, {
    key: d.key || `annotation-${i}`,
    noteData: noteData
  });
};
const svgEncloseRule = ({
  d,
  i,
  projectedNodes,
  nodeIDAccessor,
  nodeSizeAccessor
}) => {
  const selectedNodes = projectedNodes.filter(p => d.ids.indexOf(nodeIDAccessor(p)) !== -1);

  if (selectedNodes.length === 0) {
    return null;
  }

  const circle = packEnclose(selectedNodes.map(p => ({
    x: p.x,
    y: p.y,
    r: nodeSizeAccessor(p)
  })));
  return CircleEnclosure({
    circle,
    d,
    i
  });
};
const svgRectEncloseRule = ({
  d,
  i,
  projectedNodes,
  nodeIDAccessor,
  nodeSizeAccessor
}) => {
  const selectedNodes = projectedNodes.filter(p => d.ids.indexOf(nodeIDAccessor(p)) !== -1);

  if (selectedNodes.length === 0) {
    return null;
  }

  const bboxNodes = selectedNodes.map(p => {
    if (p.shapeNode) {
      return {
        x0: p.x0,
        x1: p.x1,
        y0: p.y0,
        y1: p.y1
      };
    }

    const nodeSize = nodeSizeAccessor(p);
    return {
      x0: p.x - nodeSize,
      x1: p.x + nodeSize,
      y0: p.y - nodeSize,
      y1: p.y + nodeSize
    };
  });
  return RectangleEnclosure({
    bboxNodes,
    d,
    i
  });
};
const svgHullEncloseRule = ({
  d,
  i,
  projectedNodes,
  nodeIDAccessor,
  nodeSizeAccessor
}) => {
  const selectedNodes = projectedNodes.filter(p => d.ids.indexOf(nodeIDAccessor(p)) !== -1);

  if (selectedNodes.length === 0) {
    return null;
  }

  const projectedPoints = [];
  selectedNodes.forEach(p => {
    if (p.shapeNode) {
      projectedPoints.push({
        x: p.x0,
        y: p.y0
      });
      projectedPoints.push({
        x: p.x0,
        y: p.y1
      });
      projectedPoints.push({
        x: p.x1,
        y: p.y0
      });
      projectedPoints.push({
        x: p.x1,
        y: p.y1
      });
    } else {
      const nodeSize = nodeSizeAccessor(p);
      projectedPoints.push({
        x: p.x - nodeSize,
        y: p.y - nodeSize
      });
      projectedPoints.push({
        x: p.x + nodeSize,
        y: p.y - nodeSize
      });
      projectedPoints.push({
        x: p.x - nodeSize,
        y: p.y + nodeSize
      });
      projectedPoints.push({
        x: p.x + nodeSize,
        y: p.y + nodeSize
      });
    }
  });
  return HullEnclosure({
    points: projectedPoints.map(d => [d.x, d.y]),
    d,
    i
  });
};
const svgHighlightRule = ({
  d,
  customMark,
  nodeStyle: baseStyle
}) => {
  let styleFn = baseStyle;

  if (d.style && typeof d.style === 'function') {
    styleFn = d => ({ ...baseStyle(d),
      ...d.style(d)
    });
  } else if (d.style) {
    styleFn = d => ({ ...baseStyle(d),
      ...d.style
    });
  }

  const transform = `translate(${d.x},${d.y})`;
  const baseMarkProps = {
    forceUpdate: true
  };
  const HighlightMark = customMark({
    d,
    styleFn,
    transform,
    baseMarkProps
  });
  return HighlightMark;
};

const DesaturationLayer = ({
  style = {
    fill: 'white',
    fillOpacity: 0.5
  },
  size,
  i,
  key
}) => React$1.createElement("rect", {
  key: key || `desaturation-${i}`,
  x: -5,
  y: -5,
  width: size[0] + 10,
  height: size[1] + 10,
  style: style
});

const defaultNetworkSVGRule = ({
  frameData,
  frameProps
}) => ({
  d: baseD,
  i
}) => {
  const {
    projectedNodes,
    projectedEdges,
    nodeIDAccessor,
    nodeSizeAccessor,
    adjustedSize
  } = frameData;
  const {
    customMark,
    nodeStyle
  } = frameProps;
  const d = baseD.ids ? baseD : baseD.edge ? { ...(projectedEdges.find(p => nodeIDAccessor(p.source) === nodeIDAccessor(baseD.source) && nodeIDAccessor(p.target) === nodeIDAccessor(baseD.target)) || {}),
    ...baseD
  } : { ...(projectedNodes.find(p => nodeIDAccessor(p) === baseD.id) || {}),
    ...baseD
  };

  if (d.type === 'node') {
    return svgNodeRule({
      d,
      i,
      nodeSizeAccessor
    });
  } else if (d.type === 'desaturation-layer') {
    return DesaturationLayer({
      style: d.style instanceof Function ? d.style(d, i) : d.style,
      size: adjustedSize,
      i,
      key: d.key
    });
  } else if (d.type === 'basic-node-label') {
    return React$1__default.createElement("g", {
      key: d.key || `basic-${i}`,
      transform: `translate(${d.x},${d.y})`
    }, baseD.element || baseD.label);
  } else if (d.type === 'react-annotation' || typeof d.type === 'function') {
    return svgReactAnnotationRule({
      d,
      i,
      projectedNodes,
      nodeIDAccessor
    });
  } else if (d.type === 'enclose') {
    return svgEncloseRule({
      d,
      i,
      projectedNodes,
      nodeIDAccessor,
      nodeSizeAccessor
    });
  } else if (d.type === 'enclose-rect') {
    return svgRectEncloseRule({
      d,
      i,
      projectedNodes,
      nodeIDAccessor,
      nodeSizeAccessor
    });
  } else if (d.type === 'enclose-hull') {
    return svgHullEncloseRule({
      d,
      i,
      projectedNodes,
      nodeIDAccessor,
      nodeSizeAccessor
    });
  } else if (d.type === 'highlight') {
    return svgHighlightRule({
      d,
      customMark,
      nodeStyle
    });
  }

  return null;
};

const defaultNetworkHTMLRule = ({
  frameProps,
  frameData
}) => ({
  d: baseD,
  i
}) => {
  const {
    tooltipContent,
    useSpans
  } = frameProps;
  const {
    projectedNodes,
    projectedEdges,
    nodeIDAccessor
  } = frameData;
  const d = baseD.ids ? baseD : baseD.edge ? { ...(projectedEdges.find(p => nodeIDAccessor(p.source) === nodeIDAccessor(baseD.source) && nodeIDAccessor(p.target) === nodeIDAccessor(baseD.target)) || {}),
    ...baseD
  } : { ...(projectedNodes.find(p => nodeIDAccessor(p) === baseD.id) || {}),
    ...baseD
  };

  if (d.type === 'frame-hover') {
    return htmlFrameHoverRule({
      d,
      i,
      tooltipContent,
      useSpans,
      nodes: projectedNodes,
      edges: projectedEdges,
      nodeIDAccessor
    });
  }

  return null;
};

var xhtml = "http://www.w3.org/1999/xhtml";

var namespaces = {
  svg: "http://www.w3.org/2000/svg",
  xhtml: xhtml,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};

function namespace(name) {
  var prefix = name += "", i = prefix.indexOf(":");
  if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
  return namespaces.hasOwnProperty(prefix) ? {space: namespaces[prefix], local: name} : name;
}

function creatorInherit(name) {
  return function() {
    var document = this.ownerDocument,
        uri = this.namespaceURI;
    return uri === xhtml && document.documentElement.namespaceURI === xhtml
        ? document.createElement(name)
        : document.createElementNS(uri, name);
  };
}

function creatorFixed(fullname) {
  return function() {
    return this.ownerDocument.createElementNS(fullname.space, fullname.local);
  };
}

function creator(name) {
  var fullname = namespace(name);
  return (fullname.local
      ? creatorFixed
      : creatorInherit)(fullname);
}

function none$2() {}

function selector(selector) {
  return selector == null ? none$2 : function() {
    return this.querySelector(selector);
  };
}

function selection_select(select) {
  if (typeof select !== "function") select = selector(select);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
        if ("__data__" in node) subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
      }
    }
  }

  return new Selection(subgroups, this._parents);
}

function empty() {
  return [];
}

function selectorAll(selector) {
  return selector == null ? empty : function() {
    return this.querySelectorAll(selector);
  };
}

function selection_selectAll(select) {
  if (typeof select !== "function") select = selectorAll(select);

  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        subgroups.push(select.call(node, node.__data__, i, group));
        parents.push(node);
      }
    }
  }

  return new Selection(subgroups, parents);
}

function matcher(selector) {
  return function() {
    return this.matches(selector);
  };
}

function selection_filter(match) {
  if (typeof match !== "function") match = matcher(match);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }

  return new Selection(subgroups, this._parents);
}

function sparse(update) {
  return new Array(update.length);
}

function selection_enter() {
  return new Selection(this._enter || this._groups.map(sparse), this._parents);
}

function EnterNode(parent, datum) {
  this.ownerDocument = parent.ownerDocument;
  this.namespaceURI = parent.namespaceURI;
  this._next = null;
  this._parent = parent;
  this.__data__ = datum;
}

EnterNode.prototype = {
  constructor: EnterNode,
  appendChild: function(child) { return this._parent.insertBefore(child, this._next); },
  insertBefore: function(child, next) { return this._parent.insertBefore(child, next); },
  querySelector: function(selector) { return this._parent.querySelector(selector); },
  querySelectorAll: function(selector) { return this._parent.querySelectorAll(selector); }
};

function constant$5(x) {
  return function() {
    return x;
  };
}

var keyPrefix = "$"; // Protect against keys like “__proto__”.

function bindIndex(parent, group, enter, update, exit, data) {
  var i = 0,
      node,
      groupLength = group.length,
      dataLength = data.length;

  // Put any non-null nodes that fit into update.
  // Put any null nodes into enter.
  // Put any remaining data into enter.
  for (; i < dataLength; ++i) {
    if (node = group[i]) {
      node.__data__ = data[i];
      update[i] = node;
    } else {
      enter[i] = new EnterNode(parent, data[i]);
    }
  }

  // Put any non-null nodes that don’t fit into exit.
  for (; i < groupLength; ++i) {
    if (node = group[i]) {
      exit[i] = node;
    }
  }
}

function bindKey(parent, group, enter, update, exit, data, key) {
  var i,
      node,
      nodeByKeyValue = {},
      groupLength = group.length,
      dataLength = data.length,
      keyValues = new Array(groupLength),
      keyValue;

  // Compute the key for each node.
  // If multiple nodes have the same key, the duplicates are added to exit.
  for (i = 0; i < groupLength; ++i) {
    if (node = group[i]) {
      keyValues[i] = keyValue = keyPrefix + key.call(node, node.__data__, i, group);
      if (keyValue in nodeByKeyValue) {
        exit[i] = node;
      } else {
        nodeByKeyValue[keyValue] = node;
      }
    }
  }

  // Compute the key for each datum.
  // If there a node associated with this key, join and add it to update.
  // If there is not (or the key is a duplicate), add it to enter.
  for (i = 0; i < dataLength; ++i) {
    keyValue = keyPrefix + key.call(parent, data[i], i, data);
    if (node = nodeByKeyValue[keyValue]) {
      update[i] = node;
      node.__data__ = data[i];
      nodeByKeyValue[keyValue] = null;
    } else {
      enter[i] = new EnterNode(parent, data[i]);
    }
  }

  // Add any remaining nodes that were not bound to data to exit.
  for (i = 0; i < groupLength; ++i) {
    if ((node = group[i]) && (nodeByKeyValue[keyValues[i]] === node)) {
      exit[i] = node;
    }
  }
}

function selection_data(value, key) {
  if (!value) {
    data = new Array(this.size()), j = -1;
    this.each(function(d) { data[++j] = d; });
    return data;
  }

  var bind = key ? bindKey : bindIndex,
      parents = this._parents,
      groups = this._groups;

  if (typeof value !== "function") value = constant$5(value);

  for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
    var parent = parents[j],
        group = groups[j],
        groupLength = group.length,
        data = value.call(parent, parent && parent.__data__, j, parents),
        dataLength = data.length,
        enterGroup = enter[j] = new Array(dataLength),
        updateGroup = update[j] = new Array(dataLength),
        exitGroup = exit[j] = new Array(groupLength);

    bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);

    // Now connect the enter nodes to their following update node, such that
    // appendChild can insert the materialized enter node before this node,
    // rather than at the end of the parent node.
    for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
      if (previous = enterGroup[i0]) {
        if (i0 >= i1) i1 = i0 + 1;
        while (!(next = updateGroup[i1]) && ++i1 < dataLength);
        previous._next = next || null;
      }
    }
  }

  update = new Selection(update, parents);
  update._enter = enter;
  update._exit = exit;
  return update;
}

function selection_exit() {
  return new Selection(this._exit || this._groups.map(sparse), this._parents);
}

function selection_join(onenter, onupdate, onexit) {
  var enter = this.enter(), update = this, exit = this.exit();
  enter = typeof onenter === "function" ? onenter(enter) : enter.append(onenter + "");
  if (onupdate != null) update = onupdate(update);
  if (onexit == null) exit.remove(); else onexit(exit);
  return enter && update ? enter.merge(update).order() : update;
}

function selection_merge(selection) {

  for (var groups0 = this._groups, groups1 = selection._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }

  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }

  return new Selection(merges, this._parents);
}

function selection_order() {

  for (var groups = this._groups, j = -1, m = groups.length; ++j < m;) {
    for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0;) {
      if (node = group[i]) {
        if (next && node.compareDocumentPosition(next) ^ 4) next.parentNode.insertBefore(node, next);
        next = node;
      }
    }
  }

  return this;
}

function selection_sort(compare) {
  if (!compare) compare = ascending$2;

  function compareNode(a, b) {
    return a && b ? compare(a.__data__, b.__data__) : !a - !b;
  }

  for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        sortgroup[i] = node;
      }
    }
    sortgroup.sort(compareNode);
  }

  return new Selection(sortgroups, this._parents).order();
}

function ascending$2(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}

function selection_call() {
  var callback = arguments[0];
  arguments[0] = this;
  callback.apply(null, arguments);
  return this;
}

function selection_nodes() {
  var nodes = new Array(this.size()), i = -1;
  this.each(function() { nodes[++i] = this; });
  return nodes;
}

function selection_node() {

  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
      var node = group[i];
      if (node) return node;
    }
  }

  return null;
}

function selection_size() {
  var size = 0;
  this.each(function() { ++size; });
  return size;
}

function selection_empty() {
  return !this.node();
}

function selection_each(callback) {

  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
      if (node = group[i]) callback.call(node, node.__data__, i, group);
    }
  }

  return this;
}

function attrRemove(name) {
  return function() {
    this.removeAttribute(name);
  };
}

function attrRemoveNS(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}

function attrConstant(name, value) {
  return function() {
    this.setAttribute(name, value);
  };
}

function attrConstantNS(fullname, value) {
  return function() {
    this.setAttributeNS(fullname.space, fullname.local, value);
  };
}

function attrFunction(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.removeAttribute(name);
    else this.setAttribute(name, v);
  };
}

function attrFunctionNS(fullname, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.removeAttributeNS(fullname.space, fullname.local);
    else this.setAttributeNS(fullname.space, fullname.local, v);
  };
}

function selection_attr(name, value) {
  var fullname = namespace(name);

  if (arguments.length < 2) {
    var node = this.node();
    return fullname.local
        ? node.getAttributeNS(fullname.space, fullname.local)
        : node.getAttribute(fullname);
  }

  return this.each((value == null
      ? (fullname.local ? attrRemoveNS : attrRemove) : (typeof value === "function"
      ? (fullname.local ? attrFunctionNS : attrFunction)
      : (fullname.local ? attrConstantNS : attrConstant)))(fullname, value));
}

function defaultView(node) {
  return (node.ownerDocument && node.ownerDocument.defaultView) // node is a Node
      || (node.document && node) // node is a Window
      || node.defaultView; // node is a Document
}

function styleRemove(name) {
  return function() {
    this.style.removeProperty(name);
  };
}

function styleConstant(name, value, priority) {
  return function() {
    this.style.setProperty(name, value, priority);
  };
}

function styleFunction(name, value, priority) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.style.removeProperty(name);
    else this.style.setProperty(name, v, priority);
  };
}

function selection_style(name, value, priority) {
  return arguments.length > 1
      ? this.each((value == null
            ? styleRemove : typeof value === "function"
            ? styleFunction
            : styleConstant)(name, value, priority == null ? "" : priority))
      : styleValue(this.node(), name);
}

function styleValue(node, name) {
  return node.style.getPropertyValue(name)
      || defaultView(node).getComputedStyle(node, null).getPropertyValue(name);
}

function propertyRemove(name) {
  return function() {
    delete this[name];
  };
}

function propertyConstant(name, value) {
  return function() {
    this[name] = value;
  };
}

function propertyFunction(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) delete this[name];
    else this[name] = v;
  };
}

function selection_property(name, value) {
  return arguments.length > 1
      ? this.each((value == null
          ? propertyRemove : typeof value === "function"
          ? propertyFunction
          : propertyConstant)(name, value))
      : this.node()[name];
}

function classArray(string) {
  return string.trim().split(/^|\s+/);
}

function classList(node) {
  return node.classList || new ClassList(node);
}

function ClassList(node) {
  this._node = node;
  this._names = classArray(node.getAttribute("class") || "");
}

ClassList.prototype = {
  add: function(name) {
    var i = this._names.indexOf(name);
    if (i < 0) {
      this._names.push(name);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  remove: function(name) {
    var i = this._names.indexOf(name);
    if (i >= 0) {
      this._names.splice(i, 1);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  contains: function(name) {
    return this._names.indexOf(name) >= 0;
  }
};

function classedAdd(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n) list.add(names[i]);
}

function classedRemove(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n) list.remove(names[i]);
}

function classedTrue(names) {
  return function() {
    classedAdd(this, names);
  };
}

function classedFalse(names) {
  return function() {
    classedRemove(this, names);
  };
}

function classedFunction(names, value) {
  return function() {
    (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
  };
}

function selection_classed(name, value) {
  var names = classArray(name + "");

  if (arguments.length < 2) {
    var list = classList(this.node()), i = -1, n = names.length;
    while (++i < n) if (!list.contains(names[i])) return false;
    return true;
  }

  return this.each((typeof value === "function"
      ? classedFunction : value
      ? classedTrue
      : classedFalse)(names, value));
}

function textRemove() {
  this.textContent = "";
}

function textConstant(value) {
  return function() {
    this.textContent = value;
  };
}

function textFunction(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.textContent = v == null ? "" : v;
  };
}

function selection_text(value) {
  return arguments.length
      ? this.each(value == null
          ? textRemove : (typeof value === "function"
          ? textFunction
          : textConstant)(value))
      : this.node().textContent;
}

function htmlRemove() {
  this.innerHTML = "";
}

function htmlConstant(value) {
  return function() {
    this.innerHTML = value;
  };
}

function htmlFunction(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.innerHTML = v == null ? "" : v;
  };
}

function selection_html(value) {
  return arguments.length
      ? this.each(value == null
          ? htmlRemove : (typeof value === "function"
          ? htmlFunction
          : htmlConstant)(value))
      : this.node().innerHTML;
}

function raise() {
  if (this.nextSibling) this.parentNode.appendChild(this);
}

function selection_raise() {
  return this.each(raise);
}

function lower() {
  if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);
}

function selection_lower() {
  return this.each(lower);
}

function selection_append(name) {
  var create = typeof name === "function" ? name : creator(name);
  return this.select(function() {
    return this.appendChild(create.apply(this, arguments));
  });
}

function constantNull() {
  return null;
}

function selection_insert(name, before) {
  var create = typeof name === "function" ? name : creator(name),
      select = before == null ? constantNull : typeof before === "function" ? before : selector(before);
  return this.select(function() {
    return this.insertBefore(create.apply(this, arguments), select.apply(this, arguments) || null);
  });
}

function remove() {
  var parent = this.parentNode;
  if (parent) parent.removeChild(this);
}

function selection_remove() {
  return this.each(remove);
}

function selection_cloneShallow() {
  var clone = this.cloneNode(false), parent = this.parentNode;
  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
}

function selection_cloneDeep() {
  var clone = this.cloneNode(true), parent = this.parentNode;
  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
}

function selection_clone(deep) {
  return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
}

function selection_datum(value) {
  return arguments.length
      ? this.property("__data__", value)
      : this.node().__data__;
}

var filterEvents = {};

var event$1 = null;

if (typeof document !== "undefined") {
  var element = document.documentElement;
  if (!("onmouseenter" in element)) {
    filterEvents = {mouseenter: "mouseover", mouseleave: "mouseout"};
  }
}

function filterContextListener(listener, index, group) {
  listener = contextListener(listener, index, group);
  return function(event) {
    var related = event.relatedTarget;
    if (!related || (related !== this && !(related.compareDocumentPosition(this) & 8))) {
      listener.call(this, event);
    }
  };
}

function contextListener(listener, index, group) {
  return function(event1) {
    var event0 = event$1; // Events can be reentrant (e.g., focus).
    event$1 = event1;
    try {
      listener.call(this, this.__data__, index, group);
    } finally {
      event$1 = event0;
    }
  };
}

function parseTypenames(typenames) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    return {type: t, name: name};
  });
}

function onRemove(typename) {
  return function() {
    var on = this.__on;
    if (!on) return;
    for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
      if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.capture);
      } else {
        on[++i] = o;
      }
    }
    if (++i) on.length = i;
    else delete this.__on;
  };
}

function onAdd(typename, value, capture) {
  var wrap = filterEvents.hasOwnProperty(typename.type) ? filterContextListener : contextListener;
  return function(d, i, group) {
    var on = this.__on, o, listener = wrap(value, i, group);
    if (on) for (var j = 0, m = on.length; j < m; ++j) {
      if ((o = on[j]).type === typename.type && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.capture);
        this.addEventListener(o.type, o.listener = listener, o.capture = capture);
        o.value = value;
        return;
      }
    }
    this.addEventListener(typename.type, listener, capture);
    o = {type: typename.type, name: typename.name, value: value, listener: listener, capture: capture};
    if (!on) this.__on = [o];
    else on.push(o);
  };
}

function selection_on(typename, value, capture) {
  var typenames = parseTypenames(typename + ""), i, n = typenames.length, t;

  if (arguments.length < 2) {
    var on = this.node().__on;
    if (on) for (var j = 0, m = on.length, o; j < m; ++j) {
      for (i = 0, o = on[j]; i < n; ++i) {
        if ((t = typenames[i]).type === o.type && t.name === o.name) {
          return o.value;
        }
      }
    }
    return;
  }

  on = value ? onAdd : onRemove;
  if (capture == null) capture = false;
  for (i = 0; i < n; ++i) this.each(on(typenames[i], value, capture));
  return this;
}

function customEvent(event1, listener, that, args) {
  var event0 = event$1;
  event1.sourceEvent = event$1;
  event$1 = event1;
  try {
    return listener.apply(that, args);
  } finally {
    event$1 = event0;
  }
}

function dispatchEvent(node, type, params) {
  var window = defaultView(node),
      event = window.CustomEvent;

  if (typeof event === "function") {
    event = new event(type, params);
  } else {
    event = window.document.createEvent("Event");
    if (params) event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;
    else event.initEvent(type, false, false);
  }

  node.dispatchEvent(event);
}

function dispatchConstant(type, params) {
  return function() {
    return dispatchEvent(this, type, params);
  };
}

function dispatchFunction(type, params) {
  return function() {
    return dispatchEvent(this, type, params.apply(this, arguments));
  };
}

function selection_dispatch(type, params) {
  return this.each((typeof params === "function"
      ? dispatchFunction
      : dispatchConstant)(type, params));
}

var root = [null];

function Selection(groups, parents) {
  this._groups = groups;
  this._parents = parents;
}

function selection() {
  return new Selection([[document.documentElement]], root);
}

Selection.prototype = selection.prototype = {
  constructor: Selection,
  select: selection_select,
  selectAll: selection_selectAll,
  filter: selection_filter,
  data: selection_data,
  enter: selection_enter,
  exit: selection_exit,
  join: selection_join,
  merge: selection_merge,
  order: selection_order,
  sort: selection_sort,
  call: selection_call,
  nodes: selection_nodes,
  node: selection_node,
  size: selection_size,
  empty: selection_empty,
  each: selection_each,
  attr: selection_attr,
  style: selection_style,
  property: selection_property,
  classed: selection_classed,
  text: selection_text,
  html: selection_html,
  raise: selection_raise,
  lower: selection_lower,
  append: selection_append,
  insert: selection_insert,
  remove: selection_remove,
  clone: selection_clone,
  datum: selection_datum,
  on: selection_on,
  dispatch: selection_dispatch
};

function select(selector) {
  return typeof selector === "string"
      ? new Selection([[document.querySelector(selector)]], [document.documentElement])
      : new Selection([[selector]], root);
}

function create(name) {
  return select(creator(name).call(document.documentElement));
}

var nextId = 0;

function local() {
  return new Local;
}

function Local() {
  this._ = "@" + (++nextId).toString(36);
}

Local.prototype = local.prototype = {
  constructor: Local,
  get: function(node) {
    var id = this._;
    while (!(id in node)) if (!(node = node.parentNode)) return;
    return node[id];
  },
  set: function(node, value) {
    return node[this._] = value;
  },
  remove: function(node) {
    return this._ in node && delete node[this._];
  },
  toString: function() {
    return this._;
  }
};

function sourceEvent() {
  var current = event$1, source;
  while (source = current.sourceEvent) current = source;
  return current;
}

function point$4(node, event) {
  var svg = node.ownerSVGElement || node;

  if (svg.createSVGPoint) {
    var point = svg.createSVGPoint();
    point.x = event.clientX, point.y = event.clientY;
    point = point.matrixTransform(node.getScreenCTM().inverse());
    return [point.x, point.y];
  }

  var rect = node.getBoundingClientRect();
  return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];
}

function mouse(node) {
  var event = sourceEvent();
  if (event.changedTouches) event = event.changedTouches[0];
  return point$4(node, event);
}

function selectAll(selector) {
  return typeof selector === "string"
      ? new Selection([document.querySelectorAll(selector)], [document.documentElement])
      : new Selection([selector == null ? [] : selector], root);
}

function touch(node, touches, identifier) {
  if (arguments.length < 3) identifier = touches, touches = sourceEvent().changedTouches;

  for (var i = 0, n = touches ? touches.length : 0, touch; i < n; ++i) {
    if ((touch = touches[i]).identifier === identifier) {
      return point$4(node, touch);
    }
  }

  return null;
}

function touches(node, touches) {
  if (touches == null) touches = sourceEvent().touches;

  for (var i = 0, n = touches ? touches.length : 0, points = new Array(n); i < n; ++i) {
    points[i] = point$4(node, touches[i]);
  }

  return points;
}



var src$2 = /*#__PURE__*/Object.freeze({
	__proto__: null,
	create: create,
	creator: creator,
	local: local,
	matcher: matcher,
	mouse: mouse,
	namespace: namespace,
	namespaces: namespaces,
	clientPoint: point$4,
	select: select,
	selectAll: selectAll,
	selection: selection,
	selector: selector,
	selectorAll: selectorAll,
	style: styleValue,
	touch: touch,
	touches: touches,
	window: defaultView,
	get event () { return event$1; },
	customEvent: customEvent
});

var noop$1 = {value: function() {}};

function dispatch() {
  for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
    if (!(t = arguments[i] + "") || (t in _)) throw new Error("illegal type: " + t);
    _[t] = [];
  }
  return new Dispatch(_);
}

function Dispatch(_) {
  this._ = _;
}

function parseTypenames$1(typenames, types) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    if (t && !types.hasOwnProperty(t)) throw new Error("unknown type: " + t);
    return {type: t, name: name};
  });
}

Dispatch.prototype = dispatch.prototype = {
  constructor: Dispatch,
  on: function(typename, callback) {
    var _ = this._,
        T = parseTypenames$1(typename + "", _),
        t,
        i = -1,
        n = T.length;

    // If no callback was specified, return the callback of the given type and name.
    if (arguments.length < 2) {
      while (++i < n) if ((t = (typename = T[i]).type) && (t = get(_[t], typename.name))) return t;
      return;
    }

    // If a type was specified, set the callback for the given type and name.
    // Otherwise, if a null callback was specified, remove callbacks of the given name.
    if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);
    while (++i < n) {
      if (t = (typename = T[i]).type) _[t] = set(_[t], typename.name, callback);
      else if (callback == null) for (t in _) _[t] = set(_[t], typename.name, null);
    }

    return this;
  },
  copy: function() {
    var copy = {}, _ = this._;
    for (var t in _) copy[t] = _[t].slice();
    return new Dispatch(copy);
  },
  call: function(type, that) {
    if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) args[i] = arguments[i + 2];
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  },
  apply: function(type, that, args) {
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (var t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  }
};

function get(type, name) {
  for (var i = 0, n = type.length, c; i < n; ++i) {
    if ((c = type[i]).name === name) {
      return c.value;
    }
  }
}

function set(type, name, callback) {
  for (var i = 0, n = type.length; i < n; ++i) {
    if (type[i].name === name) {
      type[i] = noop$1, type = type.slice(0, i).concat(type.slice(i + 1));
      break;
    }
  }
  if (callback != null) type.push({name: name, value: callback});
  return type;
}

var frame = 0, // is an animation frame pending?
    timeout = 0, // is a timeout pending?
    interval = 0, // are any timers active?
    pokeDelay = 1000, // how frequently we check for clock skew
    taskHead,
    taskTail,
    clockLast = 0,
    clockNow = 0,
    clockSkew = 0,
    clock = typeof performance === "object" && performance.now ? performance : Date,
    setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) { setTimeout(f, 17); };

function now() {
  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
}

function clearNow() {
  clockNow = 0;
}

function Timer() {
  this._call =
  this._time =
  this._next = null;
}

Timer.prototype = timer.prototype = {
  constructor: Timer,
  restart: function(callback, delay, time) {
    if (typeof callback !== "function") throw new TypeError("callback is not a function");
    time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);
    if (!this._next && taskTail !== this) {
      if (taskTail) taskTail._next = this;
      else taskHead = this;
      taskTail = this;
    }
    this._call = callback;
    this._time = time;
    sleep();
  },
  stop: function() {
    if (this._call) {
      this._call = null;
      this._time = Infinity;
      sleep();
    }
  }
};

function timer(callback, delay, time) {
  var t = new Timer;
  t.restart(callback, delay, time);
  return t;
}

function timerFlush() {
  now(); // Get the current time, if not already set.
  ++frame; // Pretend we’ve set an alarm, if we haven’t already.
  var t = taskHead, e;
  while (t) {
    if ((e = clockNow - t._time) >= 0) t._call.call(null, e);
    t = t._next;
  }
  --frame;
}

function wake() {
  clockNow = (clockLast = clock.now()) + clockSkew;
  frame = timeout = 0;
  try {
    timerFlush();
  } finally {
    frame = 0;
    nap();
    clockNow = 0;
  }
}

function poke() {
  var now = clock.now(), delay = now - clockLast;
  if (delay > pokeDelay) clockSkew -= delay, clockLast = now;
}

function nap() {
  var t0, t1 = taskHead, t2, time = Infinity;
  while (t1) {
    if (t1._call) {
      if (time > t1._time) time = t1._time;
      t0 = t1, t1 = t1._next;
    } else {
      t2 = t1._next, t1._next = null;
      t1 = t0 ? t0._next = t2 : taskHead = t2;
    }
  }
  taskTail = t0;
  sleep(time);
}

function sleep(time) {
  if (frame) return; // Soonest alarm already set, or will be.
  if (timeout) timeout = clearTimeout(timeout);
  var delay = time - clockNow; // Strictly less than if we recomputed clockNow.
  if (delay > 24) {
    if (time < Infinity) timeout = setTimeout(wake, time - clock.now() - clockSkew);
    if (interval) interval = clearInterval(interval);
  } else {
    if (!interval) clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
    frame = 1, setFrame(wake);
  }
}

function timeout$1(callback, delay, time) {
  var t = new Timer;
  delay = delay == null ? 0 : +delay;
  t.restart(function(elapsed) {
    t.stop();
    callback(elapsed + delay);
  }, delay, time);
  return t;
}

var emptyOn = dispatch("start", "end", "cancel", "interrupt");
var emptyTween = [];

var CREATED = 0;
var SCHEDULED = 1;
var STARTING = 2;
var STARTED = 3;
var RUNNING = 4;
var ENDING = 5;
var ENDED = 6;

function schedule(node, name, id, index, group, timing) {
  var schedules = node.__transition;
  if (!schedules) node.__transition = {};
  else if (id in schedules) return;
  create$1(node, id, {
    name: name,
    index: index, // For context during callback.
    group: group, // For context during callback.
    on: emptyOn,
    tween: emptyTween,
    time: timing.time,
    delay: timing.delay,
    duration: timing.duration,
    ease: timing.ease,
    timer: null,
    state: CREATED
  });
}

function init(node, id) {
  var schedule = get$1(node, id);
  if (schedule.state > CREATED) throw new Error("too late; already scheduled");
  return schedule;
}

function set$1(node, id) {
  var schedule = get$1(node, id);
  if (schedule.state > STARTED) throw new Error("too late; already running");
  return schedule;
}

function get$1(node, id) {
  var schedule = node.__transition;
  if (!schedule || !(schedule = schedule[id])) throw new Error("transition not found");
  return schedule;
}

function create$1(node, id, self) {
  var schedules = node.__transition,
      tween;

  // Initialize the self timer when the transition is created.
  // Note the actual delay is not known until the first callback!
  schedules[id] = self;
  self.timer = timer(schedule, 0, self.time);

  function schedule(elapsed) {
    self.state = SCHEDULED;
    self.timer.restart(start, self.delay, self.time);

    // If the elapsed delay is less than our first sleep, start immediately.
    if (self.delay <= elapsed) start(elapsed - self.delay);
  }

  function start(elapsed) {
    var i, j, n, o;

    // If the state is not SCHEDULED, then we previously errored on start.
    if (self.state !== SCHEDULED) return stop();

    for (i in schedules) {
      o = schedules[i];
      if (o.name !== self.name) continue;

      // While this element already has a starting transition during this frame,
      // defer starting an interrupting transition until that transition has a
      // chance to tick (and possibly end); see d3/d3-transition#54!
      if (o.state === STARTED) return timeout$1(start);

      // Interrupt the active transition, if any.
      if (o.state === RUNNING) {
        o.state = ENDED;
        o.timer.stop();
        o.on.call("interrupt", node, node.__data__, o.HospitalFacilities, o.group);
        delete schedules[i];
      }

      // Cancel any pre-empted transitions.
      else if (+i < id) {
        o.state = ENDED;
        o.timer.stop();
        o.on.call("cancel", node, node.__data__, o.HospitalFacilities, o.group);
        delete schedules[i];
      }
    }

    // Defer the first tick to end of the current frame; see d3/d3#1576.
    // Note the transition may be canceled after start and before the first tick!
    // Note this must be scheduled before the start event; see d3/d3-transition#16!
    // Assuming this is successful, subsequent callbacks go straight to tick.
    timeout$1(function() {
      if (self.state === STARTED) {
        self.state = RUNNING;
        self.timer.restart(tick, self.delay, self.time);
        tick(elapsed);
      }
    });

    // Dispatch the start event.
    // Note this must be done before the tween are initialized.
    self.state = STARTING;
    self.on.call("start", node, node.__data__, self.HospitalFacilities, self.group);
    if (self.state !== STARTING) return; // interrupted
    self.state = STARTED;

    // Initialize the tween, deleting null tween.
    tween = new Array(n = self.tween.length);
    for (i = 0, j = -1; i < n; ++i) {
      if (o = self.tween[i].value.call(node, node.__data__, self.HospitalFacilities, self.group)) {
        tween[++j] = o;
      }
    }
    tween.length = j + 1;
  }

  function tick(elapsed) {
    var t = elapsed < self.duration ? self.ease.call(null, elapsed / self.duration) : (self.timer.restart(stop), self.state = ENDING, 1),
        i = -1,
        n = tween.length;

    while (++i < n) {
      tween[i].call(node, t);
    }

    // Dispatch the end event.
    if (self.state === ENDING) {
      self.on.call("end", node, node.__data__, self.HospitalFacilities, self.group);
      stop();
    }
  }

  function stop() {
    self.state = ENDED;
    self.timer.stop();
    delete schedules[id];
    for (var i in schedules) return; // eslint-disable-line no-unused-vars
    delete node.__transition;
  }
}

function interrupt(node, name) {
  var schedules = node.__transition,
      schedule,
      active,
      empty = true,
      i;

  if (!schedules) return;

  name = name == null ? null : name + "";

  for (i in schedules) {
    if ((schedule = schedules[i]).name !== name) { empty = false; continue; }
    active = schedule.state > STARTING && schedule.state < ENDING;
    schedule.state = ENDED;
    schedule.timer.stop();
    schedule.on.call(active ? "interrupt" : "cancel", node, node.__data__, schedule.HospitalFacilities, schedule.group);
    delete schedules[i];
  }

  if (empty) delete node.__transition;
}

function selection_interrupt(name) {
  return this.each(function() {
    interrupt(this, name);
  });
}

function tweenRemove(id, name) {
  var tween0, tween1;
  return function() {
    var schedule = set$1(this, id),
        tween = schedule.tween;

    // If this node shared tween with the previous node,
    // just assign the updated shared tween and we’re done!
    // Otherwise, copy-on-write.
    if (tween !== tween0) {
      tween1 = tween0 = tween;
      for (var i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name) {
          tween1 = tween1.slice();
          tween1.splice(i, 1);
          break;
        }
      }
    }

    schedule.tween = tween1;
  };
}

function tweenFunction(id, name, value) {
  var tween0, tween1;
  if (typeof value !== "function") throw new Error;
  return function() {
    var schedule = set$1(this, id),
        tween = schedule.tween;

    // If this node shared tween with the previous node,
    // just assign the updated shared tween and we’re done!
    // Otherwise, copy-on-write.
    if (tween !== tween0) {
      tween1 = (tween0 = tween).slice();
      for (var t = {name: name, value: value}, i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name) {
          tween1[i] = t;
          break;
        }
      }
      if (i === n) tween1.push(t);
    }

    schedule.tween = tween1;
  };
}

function transition_tween(name, value) {
  var id = this._id;

  name += "";

  if (arguments.length < 2) {
    var tween = get$1(this.node(), id).tween;
    for (var i = 0, n = tween.length, t; i < n; ++i) {
      if ((t = tween[i]).name === name) {
        return t.value;
      }
    }
    return null;
  }

  return this.each((value == null ? tweenRemove : tweenFunction)(id, name, value));
}

function tweenValue(transition, name, value) {
  var id = transition._id;

  transition.each(function() {
    var schedule = set$1(this, id);
    (schedule.value || (schedule.value = {}))[name] = value.apply(this, arguments);
  });

  return function(node) {
    return get$1(node, id).value[name];
  };
}

function interpolate$1(a, b) {
  var c;
  return (typeof b === "number" ? interpolateNumber
      : b instanceof color ? interpolateRgb
      : (c = color(b)) ? (b = c, interpolateRgb)
      : interpolateString)(a, b);
}

function attrRemove$1(name) {
  return function() {
    this.removeAttribute(name);
  };
}

function attrRemoveNS$1(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}

function attrConstant$1(name, interpolate, value1) {
  var string00,
      string1 = value1 + "",
      interpolate0;
  return function() {
    var string0 = this.getAttribute(name);
    return string0 === string1 ? null
        : string0 === string00 ? interpolate0
        : interpolate0 = interpolate(string00 = string0, value1);
  };
}

function attrConstantNS$1(fullname, interpolate, value1) {
  var string00,
      string1 = value1 + "",
      interpolate0;
  return function() {
    var string0 = this.getAttributeNS(fullname.space, fullname.local);
    return string0 === string1 ? null
        : string0 === string00 ? interpolate0
        : interpolate0 = interpolate(string00 = string0, value1);
  };
}

function attrFunction$1(name, interpolate, value) {
  var string00,
      string10,
      interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    if (value1 == null) return void this.removeAttribute(name);
    string0 = this.getAttribute(name);
    string1 = value1 + "";
    return string0 === string1 ? null
        : string0 === string00 && string1 === string10 ? interpolate0
        : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}

function attrFunctionNS$1(fullname, interpolate, value) {
  var string00,
      string10,
      interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    if (value1 == null) return void this.removeAttributeNS(fullname.space, fullname.local);
    string0 = this.getAttributeNS(fullname.space, fullname.local);
    string1 = value1 + "";
    return string0 === string1 ? null
        : string0 === string00 && string1 === string10 ? interpolate0
        : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}

function transition_attr(name, value) {
  var fullname = namespace(name), i = fullname === "transform" ? interpolateTransformSvg : interpolate$1;
  return this.attrTween(name, typeof value === "function"
      ? (fullname.local ? attrFunctionNS$1 : attrFunction$1)(fullname, i, tweenValue(this, "attr." + name, value))
      : value == null ? (fullname.local ? attrRemoveNS$1 : attrRemove$1)(fullname)
      : (fullname.local ? attrConstantNS$1 : attrConstant$1)(fullname, i, value));
}

function attrInterpolate(name, i) {
  return function(t) {
    this.setAttribute(name, i(t));
  };
}

function attrInterpolateNS(fullname, i) {
  return function(t) {
    this.setAttributeNS(fullname.space, fullname.local, i(t));
  };
}

function attrTweenNS(fullname, value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t0 = (i0 = i) && attrInterpolateNS(fullname, i);
    return t0;
  }
  tween._value = value;
  return tween;
}

function attrTween(name, value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t0 = (i0 = i) && attrInterpolate(name, i);
    return t0;
  }
  tween._value = value;
  return tween;
}

function transition_attrTween(name, value) {
  var key = "attr." + name;
  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error;
  var fullname = namespace(name);
  return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
}

function delayFunction(id, value) {
  return function() {
    init(this, id).delay = +value.apply(this, arguments);
  };
}

function delayConstant(id, value) {
  return value = +value, function() {
    init(this, id).delay = value;
  };
}

function transition_delay(value) {
  var id = this._id;

  return arguments.length
      ? this.each((typeof value === "function"
          ? delayFunction
          : delayConstant)(id, value))
      : get$1(this.node(), id).delay;
}

function durationFunction(id, value) {
  return function() {
    set$1(this, id).duration = +value.apply(this, arguments);
  };
}

function durationConstant(id, value) {
  return value = +value, function() {
    set$1(this, id).duration = value;
  };
}

function transition_duration(value) {
  var id = this._id;

  return arguments.length
      ? this.each((typeof value === "function"
          ? durationFunction
          : durationConstant)(id, value))
      : get$1(this.node(), id).duration;
}

function easeConstant(id, value) {
  if (typeof value !== "function") throw new Error;
  return function() {
    set$1(this, id).ease = value;
  };
}

function transition_ease(value) {
  var id = this._id;

  return arguments.length
      ? this.each(easeConstant(id, value))
      : get$1(this.node(), id).ease;
}

function transition_filter(match) {
  if (typeof match !== "function") match = matcher(match);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }

  return new Transition(subgroups, this._parents, this._name, this._id);
}

function transition_merge(transition) {
  if (transition._id !== this._id) throw new Error;

  for (var groups0 = this._groups, groups1 = transition._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }

  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }

  return new Transition(merges, this._parents, this._name, this._id);
}

function start(name) {
  return (name + "").trim().split(/^|\s+/).every(function(t) {
    var i = t.indexOf(".");
    if (i >= 0) t = t.slice(0, i);
    return !t || t === "start";
  });
}

function onFunction(id, name, listener) {
  var on0, on1, sit = start(name) ? init : set$1;
  return function() {
    var schedule = sit(this, id),
        on = schedule.on;

    // If this node shared a dispatch with the previous node,
    // just assign the updated shared dispatch and we’re done!
    // Otherwise, copy-on-write.
    if (on !== on0) (on1 = (on0 = on).copy()).on(name, listener);

    schedule.on = on1;
  };
}

function transition_on(name, listener) {
  var id = this._id;

  return arguments.length < 2
      ? get$1(this.node(), id).on.on(name)
      : this.each(onFunction(id, name, listener));
}

function removeFunction(id) {
  return function() {
    var parent = this.parentNode;
    for (var i in this.__transition) if (+i !== id) return;
    if (parent) parent.removeChild(this);
  };
}

function transition_remove() {
  return this.on("end.remove", removeFunction(this._id));
}

function transition_select(select) {
  var name = this._name,
      id = this._id;

  if (typeof select !== "function") select = selector(select);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
        if ("__data__" in node) subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
        schedule(subgroup[i], name, id, i, subgroup, get$1(node, id));
      }
    }
  }

  return new Transition(subgroups, this._parents, name, id);
}

function transition_selectAll(select) {
  var name = this._name,
      id = this._id;

  if (typeof select !== "function") select = selectorAll(select);

  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        for (var children = select.call(node, node.__data__, i, group), child, inherit = get$1(node, id), k = 0, l = children.length; k < l; ++k) {
          if (child = children[k]) {
            schedule(child, name, id, k, children, inherit);
          }
        }
        subgroups.push(children);
        parents.push(node);
      }
    }
  }

  return new Transition(subgroups, parents, name, id);
}

var Selection$1 = selection.prototype.constructor;

function transition_selection() {
  return new Selection$1(this._groups, this._parents);
}

function styleNull(name, interpolate) {
  var string00,
      string10,
      interpolate0;
  return function() {
    var string0 = styleValue(this, name),
        string1 = (this.style.removeProperty(name), styleValue(this, name));
    return string0 === string1 ? null
        : string0 === string00 && string1 === string10 ? interpolate0
        : interpolate0 = interpolate(string00 = string0, string10 = string1);
  };
}

function styleRemove$1(name) {
  return function() {
    this.style.removeProperty(name);
  };
}

function styleConstant$1(name, interpolate, value1) {
  var string00,
      string1 = value1 + "",
      interpolate0;
  return function() {
    var string0 = styleValue(this, name);
    return string0 === string1 ? null
        : string0 === string00 ? interpolate0
        : interpolate0 = interpolate(string00 = string0, value1);
  };
}

function styleFunction$1(name, interpolate, value) {
  var string00,
      string10,
      interpolate0;
  return function() {
    var string0 = styleValue(this, name),
        value1 = value(this),
        string1 = value1 + "";
    if (value1 == null) string1 = value1 = (this.style.removeProperty(name), styleValue(this, name));
    return string0 === string1 ? null
        : string0 === string00 && string1 === string10 ? interpolate0
        : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}

function styleMaybeRemove(id, name) {
  var on0, on1, listener0, key = "style." + name, event = "end." + key, remove;
  return function() {
    var schedule = set$1(this, id),
        on = schedule.on,
        listener = schedule.value[key] == null ? remove || (remove = styleRemove$1(name)) : undefined;

    // If this node shared a dispatch with the previous node,
    // just assign the updated shared dispatch and we’re done!
    // Otherwise, copy-on-write.
    if (on !== on0 || listener0 !== listener) (on1 = (on0 = on).copy()).on(event, listener0 = listener);

    schedule.on = on1;
  };
}

function transition_style(name, value, priority) {
  var i = (name += "") === "transform" ? interpolateTransformCss : interpolate$1;
  return value == null ? this
      .styleTween(name, styleNull(name, i))
      .on("end.style." + name, styleRemove$1(name))
    : typeof value === "function" ? this
      .styleTween(name, styleFunction$1(name, i, tweenValue(this, "style." + name, value)))
      .each(styleMaybeRemove(this._id, name))
    : this
      .styleTween(name, styleConstant$1(name, i, value), priority)
      .on("end.style." + name, null);
}

function styleInterpolate(name, i, priority) {
  return function(t) {
    this.style.setProperty(name, i(t), priority);
  };
}

function styleTween(name, value, priority) {
  var t, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t = (i0 = i) && styleInterpolate(name, i, priority);
    return t;
  }
  tween._value = value;
  return tween;
}

function transition_styleTween(name, value, priority) {
  var key = "style." + (name += "");
  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error;
  return this.tween(key, styleTween(name, value, priority == null ? "" : priority));
}

function textConstant$1(value) {
  return function() {
    this.textContent = value;
  };
}

function textFunction$1(value) {
  return function() {
    var value1 = value(this);
    this.textContent = value1 == null ? "" : value1;
  };
}

function transition_text(value) {
  return this.tween("text", typeof value === "function"
      ? textFunction$1(tweenValue(this, "text", value))
      : textConstant$1(value == null ? "" : value + ""));
}

function transition_transition() {
  var name = this._name,
      id0 = this._id,
      id1 = newId();

  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        var inherit = get$1(node, id0);
        schedule(node, name, id1, i, group, {
          time: inherit.time + inherit.delay + inherit.duration,
          delay: 0,
          duration: inherit.duration,
          ease: inherit.ease
        });
      }
    }
  }

  return new Transition(groups, this._parents, name, id1);
}

function transition_end() {
  var on0, on1, that = this, id = that._id, size = that.size();
  return new Promise(function(resolve, reject) {
    var cancel = {value: reject},
        end = {value: function() { if (--size === 0) resolve(); }};

    that.each(function() {
      var schedule = set$1(this, id),
          on = schedule.on;

      // If this node shared a dispatch with the previous node,
      // just assign the updated shared dispatch and we’re done!
      // Otherwise, copy-on-write.
      if (on !== on0) {
        on1 = (on0 = on).copy();
        on1._.cancel.push(cancel);
        on1._.interrupt.push(cancel);
        on1._.end.push(end);
      }

      schedule.on = on1;
    });
  });
}

var id = 0;

function Transition(groups, parents, name, id) {
  this._groups = groups;
  this._parents = parents;
  this._name = name;
  this._id = id;
}

function transition(name) {
  return selection().transition(name);
}

function newId() {
  return ++id;
}

var selection_prototype = selection.prototype;

Transition.prototype = transition.prototype = {
  constructor: Transition,
  select: transition_select,
  selectAll: transition_selectAll,
  filter: transition_filter,
  merge: transition_merge,
  selection: transition_selection,
  transition: transition_transition,
  call: selection_prototype.call,
  nodes: selection_prototype.nodes,
  node: selection_prototype.node,
  size: selection_prototype.size,
  empty: selection_prototype.empty,
  each: selection_prototype.each,
  on: transition_on,
  attr: transition_attr,
  attrTween: transition_attrTween,
  style: transition_style,
  styleTween: transition_styleTween,
  text: transition_text,
  remove: transition_remove,
  tween: transition_tween,
  delay: transition_delay,
  duration: transition_duration,
  ease: transition_ease,
  end: transition_end
};

function cubicInOut(t) {
  return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
}

var defaultTiming = {
  time: null, // Set on use.
  delay: 0,
  duration: 250,
  ease: cubicInOut
};

function inherit(node, id) {
  var timing;
  while (!(timing = node.__transition) || !(timing = timing[id])) {
    if (!(node = node.parentNode)) {
      return defaultTiming.time = now(), defaultTiming;
    }
  }
  return timing;
}

function selection_transition(name) {
  var id,
      timing;

  if (name instanceof Transition) {
    id = name._id, name = name._name;
  } else {
    id = newId(), (timing = defaultTiming).time = now(), name = name == null ? null : name + "";
  }

  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        schedule(node, name, id, i, group, timing || inherit(node, id));
      }
    }
  }

  return new Transition(groups, this._parents, name, id);
}

selection.prototype.interrupt = selection_interrupt;
selection.prototype.transition = selection_transition;

function constant$6(x) {
  return function constant() {
    return x;
  };
}

var abs$1 = Math.abs;
var atan2$1 = Math.atan2;
var cos$1 = Math.cos;
var max$3 = Math.max;
var min$3 = Math.min;
var sin$1 = Math.sin;
var sqrt$1 = Math.sqrt;

var epsilon$2 = 1e-12;
var pi$2 = Math.PI;
var halfPi$1 = pi$2 / 2;
var tau$2 = 2 * pi$2;

function acos$1(x) {
  return x > 1 ? 0 : x < -1 ? pi$2 : Math.acos(x);
}

function asin$1(x) {
  return x >= 1 ? halfPi$1 : x <= -1 ? -halfPi$1 : Math.asin(x);
}

function arcInnerRadius$1(d) {
  return d.innerRadius;
}

function arcOuterRadius$1(d) {
  return d.outerRadius;
}

function arcStartAngle$1(d) {
  return d.startAngle;
}

function arcEndAngle$1(d) {
  return d.endAngle;
}

function arcPadAngle$1(d) {
  return d && d.padAngle; // Note: optional!
}

function intersect$1(x0, y0, x1, y1, x2, y2, x3, y3) {
  var x10 = x1 - x0, y10 = y1 - y0,
      x32 = x3 - x2, y32 = y3 - y2,
      t = y32 * x10 - x32 * y10;
  if (t * t < epsilon$2) return;
  t = (x32 * (y0 - y2) - y32 * (x0 - x2)) / t;
  return [x0 + t * x10, y0 + t * y10];
}

// Compute perpendicular offset line of length rc.
// http://mathworld.wolfram.com/Circle-LineIntersection.html
function cornerTangents$1(x0, y0, x1, y1, r1, rc, cw) {
  var x01 = x0 - x1,
      y01 = y0 - y1,
      lo = (cw ? rc : -rc) / sqrt$1(x01 * x01 + y01 * y01),
      ox = lo * y01,
      oy = -lo * x01,
      x11 = x0 + ox,
      y11 = y0 + oy,
      x10 = x1 + ox,
      y10 = y1 + oy,
      x00 = (x11 + x10) / 2,
      y00 = (y11 + y10) / 2,
      dx = x10 - x11,
      dy = y10 - y11,
      d2 = dx * dx + dy * dy,
      r = r1 - rc,
      D = x11 * y10 - x10 * y11,
      d = (dy < 0 ? -1 : 1) * sqrt$1(max$3(0, r * r * d2 - D * D)),
      cx0 = (D * dy - dx * d) / d2,
      cy0 = (-D * dx - dy * d) / d2,
      cx1 = (D * dy + dx * d) / d2,
      cy1 = (-D * dx + dy * d) / d2,
      dx0 = cx0 - x00,
      dy0 = cy0 - y00,
      dx1 = cx1 - x00,
      dy1 = cy1 - y00;

  // Pick the closer of the two intersection points.
  // TODO Is there a faster way to determine which intersection to use?
  if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;

  return {
    cx: cx0,
    cy: cy0,
    x01: -ox,
    y01: -oy,
    x11: cx0 * (r1 / r - 1),
    y11: cy0 * (r1 / r - 1)
  };
}

function arc$2() {
  var innerRadius = arcInnerRadius$1,
      outerRadius = arcOuterRadius$1,
      cornerRadius = constant$6(0),
      padRadius = null,
      startAngle = arcStartAngle$1,
      endAngle = arcEndAngle$1,
      padAngle = arcPadAngle$1,
      context = null;

  function arc() {
    var buffer,
        r,
        r0 = +innerRadius.apply(this, arguments),
        r1 = +outerRadius.apply(this, arguments),
        a0 = startAngle.apply(this, arguments) - halfPi$1,
        a1 = endAngle.apply(this, arguments) - halfPi$1,
        da = abs$1(a1 - a0),
        cw = a1 > a0;

    if (!context) context = buffer = path();

    // Ensure that the outer radius is always larger than the inner radius.
    if (r1 < r0) r = r1, r1 = r0, r0 = r;

    // Is it a point?
    if (!(r1 > epsilon$2)) context.moveTo(0, 0);

    // Or is it a circle or annulus?
    else if (da > tau$2 - epsilon$2) {
      context.moveTo(r1 * cos$1(a0), r1 * sin$1(a0));
      context.arc(0, 0, r1, a0, a1, !cw);
      if (r0 > epsilon$2) {
        context.moveTo(r0 * cos$1(a1), r0 * sin$1(a1));
        context.arc(0, 0, r0, a1, a0, cw);
      }
    }

    // Or is it a circular or annular sector?
    else {
      var a01 = a0,
          a11 = a1,
          a00 = a0,
          a10 = a1,
          da0 = da,
          da1 = da,
          ap = padAngle.apply(this, arguments) / 2,
          rp = (ap > epsilon$2) && (padRadius ? +padRadius.apply(this, arguments) : sqrt$1(r0 * r0 + r1 * r1)),
          rc = min$3(abs$1(r1 - r0) / 2, +cornerRadius.apply(this, arguments)),
          rc0 = rc,
          rc1 = rc,
          t0,
          t1;

      // Apply padding? Note that since r1 ≥ r0, da1 ≥ da0.
      if (rp > epsilon$2) {
        var p0 = asin$1(rp / r0 * sin$1(ap)),
            p1 = asin$1(rp / r1 * sin$1(ap));
        if ((da0 -= p0 * 2) > epsilon$2) p0 *= (cw ? 1 : -1), a00 += p0, a10 -= p0;
        else da0 = 0, a00 = a10 = (a0 + a1) / 2;
        if ((da1 -= p1 * 2) > epsilon$2) p1 *= (cw ? 1 : -1), a01 += p1, a11 -= p1;
        else da1 = 0, a01 = a11 = (a0 + a1) / 2;
      }

      var x01 = r1 * cos$1(a01),
          y01 = r1 * sin$1(a01),
          x10 = r0 * cos$1(a10),
          y10 = r0 * sin$1(a10);

      // Apply rounded corners?
      if (rc > epsilon$2) {
        var x11 = r1 * cos$1(a11),
            y11 = r1 * sin$1(a11),
            x00 = r0 * cos$1(a00),
            y00 = r0 * sin$1(a00),
            oc;

        // Restrict the corner radius according to the sector angle.
        if (da < pi$2 && (oc = intersect$1(x01, y01, x00, y00, x11, y11, x10, y10))) {
          var ax = x01 - oc[0],
              ay = y01 - oc[1],
              bx = x11 - oc[0],
              by = y11 - oc[1],
              kc = 1 / sin$1(acos$1((ax * bx + ay * by) / (sqrt$1(ax * ax + ay * ay) * sqrt$1(bx * bx + by * by))) / 2),
              lc = sqrt$1(oc[0] * oc[0] + oc[1] * oc[1]);
          rc0 = min$3(rc, (r0 - lc) / (kc - 1));
          rc1 = min$3(rc, (r1 - lc) / (kc + 1));
        }
      }

      // Is the sector collapsed to a line?
      if (!(da1 > epsilon$2)) context.moveTo(x01, y01);

      // Does the sector’s outer ring have rounded corners?
      else if (rc1 > epsilon$2) {
        t0 = cornerTangents$1(x00, y00, x01, y01, r1, rc1, cw);
        t1 = cornerTangents$1(x11, y11, x10, y10, r1, rc1, cw);

        context.moveTo(t0.cx + t0.x01, t0.cy + t0.y01);

        // Have the corners merged?
        if (rc1 < rc) context.arc(t0.cx, t0.cy, rc1, atan2$1(t0.y01, t0.x01), atan2$1(t1.y01, t1.x01), !cw);

        // Otherwise, draw the two corners and the ring.
        else {
          context.arc(t0.cx, t0.cy, rc1, atan2$1(t0.y01, t0.x01), atan2$1(t0.y11, t0.x11), !cw);
          context.arc(0, 0, r1, atan2$1(t0.cy + t0.y11, t0.cx + t0.x11), atan2$1(t1.cy + t1.y11, t1.cx + t1.x11), !cw);
          context.arc(t1.cx, t1.cy, rc1, atan2$1(t1.y11, t1.x11), atan2$1(t1.y01, t1.x01), !cw);
        }
      }

      // Or is the outer ring just a circular arc?
      else context.moveTo(x01, y01), context.arc(0, 0, r1, a01, a11, !cw);

      // Is there no inner ring, and it’s a circular sector?
      // Or perhaps it’s an annular sector collapsed due to padding?
      if (!(r0 > epsilon$2) || !(da0 > epsilon$2)) context.lineTo(x10, y10);

      // Does the sector’s inner ring (or point) have rounded corners?
      else if (rc0 > epsilon$2) {
        t0 = cornerTangents$1(x10, y10, x11, y11, r0, -rc0, cw);
        t1 = cornerTangents$1(x01, y01, x00, y00, r0, -rc0, cw);

        context.lineTo(t0.cx + t0.x01, t0.cy + t0.y01);

        // Have the corners merged?
        if (rc0 < rc) context.arc(t0.cx, t0.cy, rc0, atan2$1(t0.y01, t0.x01), atan2$1(t1.y01, t1.x01), !cw);

        // Otherwise, draw the two corners and the ring.
        else {
          context.arc(t0.cx, t0.cy, rc0, atan2$1(t0.y01, t0.x01), atan2$1(t0.y11, t0.x11), !cw);
          context.arc(0, 0, r0, atan2$1(t0.cy + t0.y11, t0.cx + t0.x11), atan2$1(t1.cy + t1.y11, t1.cx + t1.x11), cw);
          context.arc(t1.cx, t1.cy, rc0, atan2$1(t1.y11, t1.x11), atan2$1(t1.y01, t1.x01), !cw);
        }
      }

      // Or is the inner ring just a circular arc?
      else context.arc(0, 0, r0, a10, a00, cw);
    }

    context.closePath();

    if (buffer) return context = null, buffer + "" || null;
  }

  arc.centroid = function() {
    var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2,
        a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - pi$2 / 2;
    return [cos$1(a) * r, sin$1(a) * r];
  };

  arc.innerRadius = function(_) {
    return arguments.length ? (innerRadius = typeof _ === "function" ? _ : constant$6(+_), arc) : innerRadius;
  };

  arc.outerRadius = function(_) {
    return arguments.length ? (outerRadius = typeof _ === "function" ? _ : constant$6(+_), arc) : outerRadius;
  };

  arc.cornerRadius = function(_) {
    return arguments.length ? (cornerRadius = typeof _ === "function" ? _ : constant$6(+_), arc) : cornerRadius;
  };

  arc.padRadius = function(_) {
    return arguments.length ? (padRadius = _ == null ? null : typeof _ === "function" ? _ : constant$6(+_), arc) : padRadius;
  };

  arc.startAngle = function(_) {
    return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant$6(+_), arc) : startAngle;
  };

  arc.endAngle = function(_) {
    return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant$6(+_), arc) : endAngle;
  };

  arc.padAngle = function(_) {
    return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant$6(+_), arc) : padAngle;
  };

  arc.context = function(_) {
    return arguments.length ? ((context = _ == null ? null : _), arc) : context;
  };

  return arc;
}

function Linear$1(context) {
  this._context = context;
}

Linear$1.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; // proceed
      default: this._context.lineTo(x, y); break;
    }
  }
};

function curveLinear$1(context) {
  return new Linear$1(context);
}

function x$1(p) {
  return p[0];
}

function y$1(p) {
  return p[1];
}

function line$1() {
  var x = x$1,
      y = y$1,
      defined = constant$6(true),
      context = null,
      curve = curveLinear$1,
      output = null;

  function line(data) {
    var i,
        n = data.length,
        d,
        defined0 = false,
        buffer;

    if (context == null) output = curve(buffer = path());

    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined(d = data[i], i, data)) === defined0) {
        if (defined0 = !defined0) output.lineStart();
        else output.lineEnd();
      }
      if (defined0) output.point(+x(d, i, data), +y(d, i, data));
    }

    if (buffer) return output = null, buffer + "" || null;
  }

  line.x = function(_) {
    return arguments.length ? (x = typeof _ === "function" ? _ : constant$6(+_), line) : x;
  };

  line.y = function(_) {
    return arguments.length ? (y = typeof _ === "function" ? _ : constant$6(+_), line) : y;
  };

  line.defined = function(_) {
    return arguments.length ? (defined = typeof _ === "function" ? _ : constant$6(!!_), line) : defined;
  };

  line.curve = function(_) {
    return arguments.length ? (curve = _, context != null && (output = curve(context)), line) : curve;
  };

  line.context = function(_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), line) : context;
  };

  return line;
}

function area$1() {
  var x0 = x$1,
      x1 = null,
      y0 = constant$6(0),
      y1 = y$1,
      defined = constant$6(true),
      context = null,
      curve = curveLinear$1,
      output = null;

  function area(data) {
    var i,
        j,
        k,
        n = data.length,
        d,
        defined0 = false,
        buffer,
        x0z = new Array(n),
        y0z = new Array(n);

    if (context == null) output = curve(buffer = path());

    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined(d = data[i], i, data)) === defined0) {
        if (defined0 = !defined0) {
          j = i;
          output.areaStart();
          output.lineStart();
        } else {
          output.lineEnd();
          output.lineStart();
          for (k = i - 1; k >= j; --k) {
            output.point(x0z[k], y0z[k]);
          }
          output.lineEnd();
          output.areaEnd();
        }
      }
      if (defined0) {
        x0z[i] = +x0(d, i, data), y0z[i] = +y0(d, i, data);
        output.point(x1 ? +x1(d, i, data) : x0z[i], y1 ? +y1(d, i, data) : y0z[i]);
      }
    }

    if (buffer) return output = null, buffer + "" || null;
  }

  function arealine() {
    return line$1().defined(defined).curve(curve).context(context);
  }

  area.x = function(_) {
    return arguments.length ? (x0 = typeof _ === "function" ? _ : constant$6(+_), x1 = null, area) : x0;
  };

  area.x0 = function(_) {
    return arguments.length ? (x0 = typeof _ === "function" ? _ : constant$6(+_), area) : x0;
  };

  area.x1 = function(_) {
    return arguments.length ? (x1 = _ == null ? null : typeof _ === "function" ? _ : constant$6(+_), area) : x1;
  };

  area.y = function(_) {
    return arguments.length ? (y0 = typeof _ === "function" ? _ : constant$6(+_), y1 = null, area) : y0;
  };

  area.y0 = function(_) {
    return arguments.length ? (y0 = typeof _ === "function" ? _ : constant$6(+_), area) : y0;
  };

  area.y1 = function(_) {
    return arguments.length ? (y1 = _ == null ? null : typeof _ === "function" ? _ : constant$6(+_), area) : y1;
  };

  area.lineX0 =
  area.lineY0 = function() {
    return arealine().x(x0).y(y0);
  };

  area.lineY1 = function() {
    return arealine().x(x0).y(y1);
  };

  area.lineX1 = function() {
    return arealine().x(x1).y(y0);
  };

  area.defined = function(_) {
    return arguments.length ? (defined = typeof _ === "function" ? _ : constant$6(!!_), area) : defined;
  };

  area.curve = function(_) {
    return arguments.length ? (curve = _, context != null && (output = curve(context)), area) : curve;
  };

  area.context = function(_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), area) : context;
  };

  return area;
}

function descending$2(a, b) {
  return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
}

function identity$5(d) {
  return d;
}

function pie$1() {
  var value = identity$5,
      sortValues = descending$2,
      sort = null,
      startAngle = constant$6(0),
      endAngle = constant$6(tau$2),
      padAngle = constant$6(0);

  function pie(data) {
    var i,
        n = data.length,
        j,
        k,
        sum = 0,
        index = new Array(n),
        arcs = new Array(n),
        a0 = +startAngle.apply(this, arguments),
        da = Math.min(tau$2, Math.max(-tau$2, endAngle.apply(this, arguments) - a0)),
        a1,
        p = Math.min(Math.abs(da) / n, padAngle.apply(this, arguments)),
        pa = p * (da < 0 ? -1 : 1),
        v;

    for (i = 0; i < n; ++i) {
      if ((v = arcs[index[i] = i] = +value(data[i], i, data)) > 0) {
        sum += v;
      }
    }

    // Optionally sort the arcs by previously-computed values or by data.
    if (sortValues != null) index.sort(function(i, j) { return sortValues(arcs[i], arcs[j]); });
    else if (sort != null) index.sort(function(i, j) { return sort(data[i], data[j]); });

    // Compute the arcs! They are stored in the original data's order.
    for (i = 0, k = sum ? (da - n * pa) / sum : 0; i < n; ++i, a0 = a1) {
      j = index[i], v = arcs[j], a1 = a0 + (v > 0 ? v * k : 0) + pa, arcs[j] = {
        data: data[j],
        index: i,
        value: v,
        startAngle: a0,
        endAngle: a1,
        padAngle: p
      };
    }

    return arcs;
  }

  pie.value = function(_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : constant$6(+_), pie) : value;
  };

  pie.sortValues = function(_) {
    return arguments.length ? (sortValues = _, sort = null, pie) : sortValues;
  };

  pie.sort = function(_) {
    return arguments.length ? (sort = _, sortValues = null, pie) : sort;
  };

  pie.startAngle = function(_) {
    return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant$6(+_), pie) : startAngle;
  };

  pie.endAngle = function(_) {
    return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant$6(+_), pie) : endAngle;
  };

  pie.padAngle = function(_) {
    return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant$6(+_), pie) : padAngle;
  };

  return pie;
}

var curveRadialLinear$1 = curveRadial$1(curveLinear$1);

function Radial$1(curve) {
  this._curve = curve;
}

Radial$1.prototype = {
  areaStart: function() {
    this._curve.areaStart();
  },
  areaEnd: function() {
    this._curve.areaEnd();
  },
  lineStart: function() {
    this._curve.lineStart();
  },
  lineEnd: function() {
    this._curve.lineEnd();
  },
  point: function(a, r) {
    this._curve.point(r * Math.sin(a), r * -Math.cos(a));
  }
};

function curveRadial$1(curve) {

  function radial(context) {
    return new Radial$1(curve(context));
  }

  radial._curve = curve;

  return radial;
}

function lineRadial(l) {
  var c = l.curve;

  l.angle = l.x, delete l.x;
  l.radius = l.y, delete l.y;

  l.curve = function(_) {
    return arguments.length ? c(curveRadial$1(_)) : c()._curve;
  };

  return l;
}

function lineRadial$1() {
  return lineRadial(line$1().curve(curveRadialLinear$1));
}

function areaRadial() {
  var a = area$1().curve(curveRadialLinear$1),
      c = a.curve,
      x0 = a.lineX0,
      x1 = a.lineX1,
      y0 = a.lineY0,
      y1 = a.lineY1;

  a.angle = a.x, delete a.x;
  a.startAngle = a.x0, delete a.x0;
  a.endAngle = a.x1, delete a.x1;
  a.radius = a.y, delete a.y;
  a.innerRadius = a.y0, delete a.y0;
  a.outerRadius = a.y1, delete a.y1;
  a.lineStartAngle = function() { return lineRadial(x0()); }, delete a.lineX0;
  a.lineEndAngle = function() { return lineRadial(x1()); }, delete a.lineX1;
  a.lineInnerRadius = function() { return lineRadial(y0()); }, delete a.lineY0;
  a.lineOuterRadius = function() { return lineRadial(y1()); }, delete a.lineY1;

  a.curve = function(_) {
    return arguments.length ? c(curveRadial$1(_)) : c()._curve;
  };

  return a;
}

function pointRadial(x, y) {
  return [(y = +y) * Math.cos(x -= Math.PI / 2), y * Math.sin(x)];
}

var slice$3 = Array.prototype.slice;

function linkSource(d) {
  return d.source;
}

function linkTarget(d) {
  return d.target;
}

function link(curve) {
  var source = linkSource,
      target = linkTarget,
      x = x$1,
      y = y$1,
      context = null;

  function link() {
    var buffer, argv = slice$3.call(arguments), s = source.apply(this, argv), t = target.apply(this, argv);
    if (!context) context = buffer = path();
    curve(context, +x.apply(this, (argv[0] = s, argv)), +y.apply(this, argv), +x.apply(this, (argv[0] = t, argv)), +y.apply(this, argv));
    if (buffer) return context = null, buffer + "" || null;
  }

  link.source = function(_) {
    return arguments.length ? (source = _, link) : source;
  };

  link.target = function(_) {
    return arguments.length ? (target = _, link) : target;
  };

  link.x = function(_) {
    return arguments.length ? (x = typeof _ === "function" ? _ : constant$6(+_), link) : x;
  };

  link.y = function(_) {
    return arguments.length ? (y = typeof _ === "function" ? _ : constant$6(+_), link) : y;
  };

  link.context = function(_) {
    return arguments.length ? ((context = _ == null ? null : _), link) : context;
  };

  return link;
}

function curveHorizontal(context, x0, y0, x1, y1) {
  context.moveTo(x0, y0);
  context.bezierCurveTo(x0 = (x0 + x1) / 2, y0, x0, y1, x1, y1);
}

function curveVertical(context, x0, y0, x1, y1) {
  context.moveTo(x0, y0);
  context.bezierCurveTo(x0, y0 = (y0 + y1) / 2, x1, y0, x1, y1);
}

function curveRadial$2(context, x0, y0, x1, y1) {
  var p0 = pointRadial(x0, y0),
      p1 = pointRadial(x0, y0 = (y0 + y1) / 2),
      p2 = pointRadial(x1, y0),
      p3 = pointRadial(x1, y1);
  context.moveTo(p0[0], p0[1]);
  context.bezierCurveTo(p1[0], p1[1], p2[0], p2[1], p3[0], p3[1]);
}

function linkHorizontal() {
  return link(curveHorizontal);
}

function linkVertical() {
  return link(curveVertical);
}

function linkRadial() {
  var l = link(curveRadial$2);
  l.angle = l.x, delete l.x;
  l.radius = l.y, delete l.y;
  return l;
}

var circle$2 = {
  draw: function(context, size) {
    var r = Math.sqrt(size / pi$2);
    context.moveTo(r, 0);
    context.arc(0, 0, r, 0, tau$2);
  }
};

var cross$2 = {
  draw: function(context, size) {
    var r = Math.sqrt(size / 5) / 2;
    context.moveTo(-3 * r, -r);
    context.lineTo(-r, -r);
    context.lineTo(-r, -3 * r);
    context.lineTo(r, -3 * r);
    context.lineTo(r, -r);
    context.lineTo(3 * r, -r);
    context.lineTo(3 * r, r);
    context.lineTo(r, r);
    context.lineTo(r, 3 * r);
    context.lineTo(-r, 3 * r);
    context.lineTo(-r, r);
    context.lineTo(-3 * r, r);
    context.closePath();
  }
};

var tan30$1 = Math.sqrt(1 / 3),
    tan30_2$1 = tan30$1 * 2;

var diamond$1 = {
  draw: function(context, size) {
    var y = Math.sqrt(size / tan30_2$1),
        x = y * tan30$1;
    context.moveTo(0, -y);
    context.lineTo(x, 0);
    context.lineTo(0, y);
    context.lineTo(-x, 0);
    context.closePath();
  }
};

var ka$1 = 0.89081309152928522810,
    kr$1 = Math.sin(pi$2 / 10) / Math.sin(7 * pi$2 / 10),
    kx$1 = Math.sin(tau$2 / 10) * kr$1,
    ky$1 = -Math.cos(tau$2 / 10) * kr$1;

var star$1 = {
  draw: function(context, size) {
    var r = Math.sqrt(size * ka$1),
        x = kx$1 * r,
        y = ky$1 * r;
    context.moveTo(0, -r);
    context.lineTo(x, y);
    for (var i = 1; i < 5; ++i) {
      var a = tau$2 * i / 5,
          c = Math.cos(a),
          s = Math.sin(a);
      context.lineTo(s * r, -c * r);
      context.lineTo(c * x - s * y, s * x + c * y);
    }
    context.closePath();
  }
};

var square$1 = {
  draw: function(context, size) {
    var w = Math.sqrt(size),
        x = -w / 2;
    context.rect(x, x, w, w);
  }
};

var sqrt3$1 = Math.sqrt(3);

var triangle$1 = {
  draw: function(context, size) {
    var y = -Math.sqrt(size / (sqrt3$1 * 3));
    context.moveTo(0, y * 2);
    context.lineTo(-sqrt3$1 * y, -y);
    context.lineTo(sqrt3$1 * y, -y);
    context.closePath();
  }
};

var c$1 = -0.5,
    s$1 = Math.sqrt(3) / 2,
    k$1 = 1 / Math.sqrt(12),
    a$1 = (k$1 / 2 + 1) * 3;

var wye$1 = {
  draw: function(context, size) {
    var r = Math.sqrt(size / a$1),
        x0 = r / 2,
        y0 = r * k$1,
        x1 = x0,
        y1 = r * k$1 + r,
        x2 = -x1,
        y2 = y1;
    context.moveTo(x0, y0);
    context.lineTo(x1, y1);
    context.lineTo(x2, y2);
    context.lineTo(c$1 * x0 - s$1 * y0, s$1 * x0 + c$1 * y0);
    context.lineTo(c$1 * x1 - s$1 * y1, s$1 * x1 + c$1 * y1);
    context.lineTo(c$1 * x2 - s$1 * y2, s$1 * x2 + c$1 * y2);
    context.lineTo(c$1 * x0 + s$1 * y0, c$1 * y0 - s$1 * x0);
    context.lineTo(c$1 * x1 + s$1 * y1, c$1 * y1 - s$1 * x1);
    context.lineTo(c$1 * x2 + s$1 * y2, c$1 * y2 - s$1 * x2);
    context.closePath();
  }
};

var symbols$1 = [
  circle$2,
  cross$2,
  diamond$1,
  square$1,
  star$1,
  triangle$1,
  wye$1
];

function symbol$1() {
  var type = constant$6(circle$2),
      size = constant$6(64),
      context = null;

  function symbol() {
    var buffer;
    if (!context) context = buffer = path();
    type.apply(this, arguments).draw(context, +size.apply(this, arguments));
    if (buffer) return context = null, buffer + "" || null;
  }

  symbol.type = function(_) {
    return arguments.length ? (type = typeof _ === "function" ? _ : constant$6(_), symbol) : type;
  };

  symbol.size = function(_) {
    return arguments.length ? (size = typeof _ === "function" ? _ : constant$6(+_), symbol) : size;
  };

  symbol.context = function(_) {
    return arguments.length ? (context = _ == null ? null : _, symbol) : context;
  };

  return symbol;
}

function noop$2() {}

function point$5(that, x, y) {
  that._context.bezierCurveTo(
    (2 * that._x0 + that._x1) / 3,
    (2 * that._y0 + that._y1) / 3,
    (that._x0 + 2 * that._x1) / 3,
    (that._y0 + 2 * that._y1) / 3,
    (that._x0 + 4 * that._x1 + x) / 6,
    (that._y0 + 4 * that._y1 + y) / 6
  );
}

function Basis$1(context) {
  this._context = context;
}

Basis$1.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 =
    this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 3: point$5(this, this._x1, this._y1); // proceed
      case 2: this._context.lineTo(this._x1, this._y1); break;
    }
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6); // proceed
      default: point$5(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
  }
};

function curveBasis(context) {
  return new Basis$1(context);
}

function BasisClosed$1(context) {
  this._context = context;
}

BasisClosed$1.prototype = {
  areaStart: noop$2,
  areaEnd: noop$2,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 =
    this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x2, this._y2);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);
        this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x2, this._y2);
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        break;
      }
    }
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._x2 = x, this._y2 = y; break;
      case 1: this._point = 2; this._x3 = x, this._y3 = y; break;
      case 2: this._point = 3; this._x4 = x, this._y4 = y; this._context.moveTo((this._x0 + 4 * this._x1 + x) / 6, (this._y0 + 4 * this._y1 + y) / 6); break;
      default: point$5(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
  }
};

function basisClosed$1(context) {
  return new BasisClosed$1(context);
}

function BasisOpen$1(context) {
  this._context = context;
}

BasisOpen$1.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 =
    this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; var x0 = (this._x0 + 4 * this._x1 + x) / 6, y0 = (this._y0 + 4 * this._y1 + y) / 6; this._line ? this._context.lineTo(x0, y0) : this._context.moveTo(x0, y0); break;
      case 3: this._point = 4; // proceed
      default: point$5(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
  }
};

function basisOpen$1(context) {
  return new BasisOpen$1(context);
}

function Bundle$1(context, beta) {
  this._basis = new Basis$1(context);
  this._beta = beta;
}

Bundle$1.prototype = {
  lineStart: function() {
    this._x = [];
    this._y = [];
    this._basis.lineStart();
  },
  lineEnd: function() {
    var x = this._x,
        y = this._y,
        j = x.length - 1;

    if (j > 0) {
      var x0 = x[0],
          y0 = y[0],
          dx = x[j] - x0,
          dy = y[j] - y0,
          i = -1,
          t;

      while (++i <= j) {
        t = i / j;
        this._basis.point(
          this._beta * x[i] + (1 - this._beta) * (x0 + t * dx),
          this._beta * y[i] + (1 - this._beta) * (y0 + t * dy)
        );
      }
    }

    this._x = this._y = null;
    this._basis.lineEnd();
  },
  point: function(x, y) {
    this._x.push(+x);
    this._y.push(+y);
  }
};

var bundle$1 = (function custom(beta) {

  function bundle(context) {
    return beta === 1 ? new Basis$1(context) : new Bundle$1(context, beta);
  }

  bundle.beta = function(beta) {
    return custom(+beta);
  };

  return bundle;
})(0.85);

function point$6(that, x, y) {
  that._context.bezierCurveTo(
    that._x1 + that._k * (that._x2 - that._x0),
    that._y1 + that._k * (that._y2 - that._y0),
    that._x2 + that._k * (that._x1 - x),
    that._y2 + that._k * (that._y1 - y),
    that._x2,
    that._y2
  );
}

function Cardinal$1(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}

Cardinal$1.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 =
    this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2: this._context.lineTo(this._x2, this._y2); break;
      case 3: point$6(this, this._x1, this._y1); break;
    }
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; this._x1 = x, this._y1 = y; break;
      case 2: this._point = 3; // proceed
      default: point$6(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

var curveCardinal = (function custom(tension) {

  function cardinal(context) {
    return new Cardinal$1(context, tension);
  }

  cardinal.tension = function(tension) {
    return custom(+tension);
  };

  return cardinal;
})(0);

function CardinalClosed$1(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}

CardinalClosed$1.prototype = {
  areaStart: noop$2,
  areaEnd: noop$2,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 =
    this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._x3 = x, this._y3 = y; break;
      case 1: this._point = 2; this._context.moveTo(this._x4 = x, this._y4 = y); break;
      case 2: this._point = 3; this._x5 = x, this._y5 = y; break;
      default: point$6(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

var cardinalClosed$1 = (function custom(tension) {

  function cardinal(context) {
    return new CardinalClosed$1(context, tension);
  }

  cardinal.tension = function(tension) {
    return custom(+tension);
  };

  return cardinal;
})(0);

function CardinalOpen$1(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}

CardinalOpen$1.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 =
    this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2); break;
      case 3: this._point = 4; // proceed
      default: point$6(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

var cardinalOpen$1 = (function custom(tension) {

  function cardinal(context) {
    return new CardinalOpen$1(context, tension);
  }

  cardinal.tension = function(tension) {
    return custom(+tension);
  };

  return cardinal;
})(0);

function point$7(that, x, y) {
  var x1 = that._x1,
      y1 = that._y1,
      x2 = that._x2,
      y2 = that._y2;

  if (that._l01_a > epsilon$2) {
    var a = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a,
        n = 3 * that._l01_a * (that._l01_a + that._l12_a);
    x1 = (x1 * a - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n;
    y1 = (y1 * a - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n;
  }

  if (that._l23_a > epsilon$2) {
    var b = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a,
        m = 3 * that._l23_a * (that._l23_a + that._l12_a);
    x2 = (x2 * b + that._x1 * that._l23_2a - x * that._l12_2a) / m;
    y2 = (y2 * b + that._y1 * that._l23_2a - y * that._l12_2a) / m;
  }

  that._context.bezierCurveTo(x1, y1, x2, y2, that._x2, that._y2);
}

function CatmullRom$1(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}

CatmullRom$1.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 =
    this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a =
    this._l01_2a = this._l12_2a = this._l23_2a =
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2: this._context.lineTo(this._x2, this._y2); break;
      case 3: this.point(this._x2, this._y2); break;
    }
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;

    if (this._point) {
      var x23 = this._x2 - x,
          y23 = this._y2 - y;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }

    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; // proceed
      default: point$7(this, x, y); break;
    }

    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

var curveCatmullRom = (function custom(alpha) {

  function catmullRom(context) {
    return alpha ? new CatmullRom$1(context, alpha) : new Cardinal$1(context, 0);
  }

  catmullRom.alpha = function(alpha) {
    return custom(+alpha);
  };

  return catmullRom;
})(0.5);

function CatmullRomClosed$1(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}

CatmullRomClosed$1.prototype = {
  areaStart: noop$2,
  areaEnd: noop$2,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 =
    this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._l01_a = this._l12_a = this._l23_a =
    this._l01_2a = this._l12_2a = this._l23_2a =
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(x, y) {
    x = +x, y = +y;

    if (this._point) {
      var x23 = this._x2 - x,
          y23 = this._y2 - y;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }

    switch (this._point) {
      case 0: this._point = 1; this._x3 = x, this._y3 = y; break;
      case 1: this._point = 2; this._context.moveTo(this._x4 = x, this._y4 = y); break;
      case 2: this._point = 3; this._x5 = x, this._y5 = y; break;
      default: point$7(this, x, y); break;
    }

    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

var catmullRomClosed$1 = (function custom(alpha) {

  function catmullRom(context) {
    return alpha ? new CatmullRomClosed$1(context, alpha) : new CardinalClosed$1(context, 0);
  }

  catmullRom.alpha = function(alpha) {
    return custom(+alpha);
  };

  return catmullRom;
})(0.5);

function CatmullRomOpen$1(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}

CatmullRomOpen$1.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 =
    this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a =
    this._l01_2a = this._l12_2a = this._l23_2a =
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;

    if (this._point) {
      var x23 = this._x2 - x,
          y23 = this._y2 - y;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }

    switch (this._point) {
      case 0: this._point = 1; break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2); break;
      case 3: this._point = 4; // proceed
      default: point$7(this, x, y); break;
    }

    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

var catmullRomOpen$1 = (function custom(alpha) {

  function catmullRom(context) {
    return alpha ? new CatmullRomOpen$1(context, alpha) : new CardinalOpen$1(context, 0);
  }

  catmullRom.alpha = function(alpha) {
    return custom(+alpha);
  };

  return catmullRom;
})(0.5);

function LinearClosed$1(context) {
  this._context = context;
}

LinearClosed$1.prototype = {
  areaStart: noop$2,
  areaEnd: noop$2,
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._point) this._context.closePath();
  },
  point: function(x, y) {
    x = +x, y = +y;
    if (this._point) this._context.lineTo(x, y);
    else this._point = 1, this._context.moveTo(x, y);
  }
};

function curveLinearClosed(context) {
  return new LinearClosed$1(context);
}

function sign$1(x) {
  return x < 0 ? -1 : 1;
}

// Calculate the slopes of the tangents (Hermite-type interpolation) based on
// the following paper: Steffen, M. 1990. A Simple Method for Monotonic
// Interpolation in One Dimension. Astronomy and Astrophysics, Vol. 239, NO.
// NOV(II), P. 443, 1990.
function slope3$1(that, x2, y2) {
  var h0 = that._x1 - that._x0,
      h1 = x2 - that._x1,
      s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0),
      s1 = (y2 - that._y1) / (h1 || h0 < 0 && -0),
      p = (s0 * h1 + s1 * h0) / (h0 + h1);
  return (sign$1(s0) + sign$1(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;
}

// Calculate a one-sided slope.
function slope2$1(that, t) {
  var h = that._x1 - that._x0;
  return h ? (3 * (that._y1 - that._y0) / h - t) / 2 : t;
}

// According to https://en.wikipedia.org/wiki/Cubic_Hermite_spline#Representations
// "you can express cubic Hermite interpolation in terms of cubic Bézier curves
// with respect to the four values p0, p0 + m0 / 3, p1 - m1 / 3, p1".
function point$8(that, t0, t1) {
  var x0 = that._x0,
      y0 = that._y0,
      x1 = that._x1,
      y1 = that._y1,
      dx = (x1 - x0) / 3;
  that._context.bezierCurveTo(x0 + dx, y0 + dx * t0, x1 - dx, y1 - dx * t1, x1, y1);
}

function MonotoneX$1(context) {
  this._context = context;
}

MonotoneX$1.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 =
    this._y0 = this._y1 =
    this._t0 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2: this._context.lineTo(this._x1, this._y1); break;
      case 3: point$8(this, this._t0, slope2$1(this, this._t0)); break;
    }
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    var t1 = NaN;

    x = +x, y = +y;
    if (x === this._x1 && y === this._y1) return; // Ignore coincident points.
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; point$8(this, slope2$1(this, t1 = slope3$1(this, x, y)), t1); break;
      default: point$8(this, this._t0, t1 = slope3$1(this, x, y)); break;
    }

    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
    this._t0 = t1;
  }
};

function MonotoneY$1(context) {
  this._context = new ReflectContext$1(context);
}

(MonotoneY$1.prototype = Object.create(MonotoneX$1.prototype)).point = function(x, y) {
  MonotoneX$1.prototype.point.call(this, y, x);
};

function ReflectContext$1(context) {
  this._context = context;
}

ReflectContext$1.prototype = {
  moveTo: function(x, y) { this._context.moveTo(y, x); },
  closePath: function() { this._context.closePath(); },
  lineTo: function(x, y) { this._context.lineTo(y, x); },
  bezierCurveTo: function(x1, y1, x2, y2, x, y) { this._context.bezierCurveTo(y1, x1, y2, x2, y, x); }
};

function monotoneX$1(context) {
  return new MonotoneX$1(context);
}

function monotoneY$1(context) {
  return new MonotoneY$1(context);
}

function Natural$1(context) {
  this._context = context;
}

Natural$1.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = [];
    this._y = [];
  },
  lineEnd: function() {
    var x = this._x,
        y = this._y,
        n = x.length;

    if (n) {
      this._line ? this._context.lineTo(x[0], y[0]) : this._context.moveTo(x[0], y[0]);
      if (n === 2) {
        this._context.lineTo(x[1], y[1]);
      } else {
        var px = controlPoints$1(x),
            py = controlPoints$1(y);
        for (var i0 = 0, i1 = 1; i1 < n; ++i0, ++i1) {
          this._context.bezierCurveTo(px[0][i0], py[0][i0], px[1][i0], py[1][i0], x[i1], y[i1]);
        }
      }
    }

    if (this._line || (this._line !== 0 && n === 1)) this._context.closePath();
    this._line = 1 - this._line;
    this._x = this._y = null;
  },
  point: function(x, y) {
    this._x.push(+x);
    this._y.push(+y);
  }
};

// See https://www.particleincell.com/2012/bezier-splines/ for derivation.
function controlPoints$1(x) {
  var i,
      n = x.length - 1,
      m,
      a = new Array(n),
      b = new Array(n),
      r = new Array(n);
  a[0] = 0, b[0] = 2, r[0] = x[0] + 2 * x[1];
  for (i = 1; i < n - 1; ++i) a[i] = 1, b[i] = 4, r[i] = 4 * x[i] + 2 * x[i + 1];
  a[n - 1] = 2, b[n - 1] = 7, r[n - 1] = 8 * x[n - 1] + x[n];
  for (i = 1; i < n; ++i) m = a[i] / b[i - 1], b[i] -= m, r[i] -= m * r[i - 1];
  a[n - 1] = r[n - 1] / b[n - 1];
  for (i = n - 2; i >= 0; --i) a[i] = (r[i] - a[i + 1]) / b[i];
  b[n - 1] = (x[n] + a[n - 1]) / 2;
  for (i = 0; i < n - 1; ++i) b[i] = 2 * x[i + 1] - a[i + 1];
  return [a, b];
}

function curveNatural(context) {
  return new Natural$1(context);
}

function Step$1(context, t) {
  this._context = context;
  this._t = t;
}

Step$1.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = this._y = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (0 < this._t && this._t < 1 && this._point === 2) this._context.lineTo(this._x, this._y);
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    if (this._line >= 0) this._t = 1 - this._t, this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; // proceed
      default: {
        if (this._t <= 0) {
          this._context.lineTo(this._x, y);
          this._context.lineTo(x, y);
        } else {
          var x1 = this._x * (1 - this._t) + x * this._t;
          this._context.lineTo(x1, this._y);
          this._context.lineTo(x1, y);
        }
        break;
      }
    }
    this._x = x, this._y = y;
  }
};

function curveStep(context) {
  return new Step$1(context, 0.5);
}

function stepBefore$1(context) {
  return new Step$1(context, 0);
}

function stepAfter$1(context) {
  return new Step$1(context, 1);
}

function none$3(series, order) {
  if (!((n = series.length) > 1)) return;
  for (var i = 1, j, s0, s1 = series[order[0]], n, m = s1.length; i < n; ++i) {
    s0 = s1, s1 = series[order[i]];
    for (j = 0; j < m; ++j) {
      s1[j][1] += s1[j][0] = isNaN(s0[j][1]) ? s0[j][0] : s0[j][1];
    }
  }
}

function none$4(series) {
  var n = series.length, o = new Array(n);
  while (--n >= 0) o[n] = n;
  return o;
}

function stackValue$1(d, key) {
  return d[key];
}

function stack$1() {
  var keys = constant$6([]),
      order = none$4,
      offset = none$3,
      value = stackValue$1;

  function stack(data) {
    var kz = keys.apply(this, arguments),
        i,
        m = data.length,
        n = kz.length,
        sz = new Array(n),
        oz;

    for (i = 0; i < n; ++i) {
      for (var ki = kz[i], si = sz[i] = new Array(m), j = 0, sij; j < m; ++j) {
        si[j] = sij = [0, +value(data[j], ki, j, data)];
        sij.data = data[j];
      }
      si.key = ki;
    }

    for (i = 0, oz = order(sz); i < n; ++i) {
      sz[oz[i]].index = i;
    }

    offset(sz, oz);
    return sz;
  }

  stack.keys = function(_) {
    return arguments.length ? (keys = typeof _ === "function" ? _ : constant$6(slice$3.call(_)), stack) : keys;
  };

  stack.value = function(_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : constant$6(+_), stack) : value;
  };

  stack.order = function(_) {
    return arguments.length ? (order = _ == null ? none$4 : typeof _ === "function" ? _ : constant$6(slice$3.call(_)), stack) : order;
  };

  stack.offset = function(_) {
    return arguments.length ? (offset = _ == null ? none$3 : _, stack) : offset;
  };

  return stack;
}

function expand$1(series, order) {
  if (!((n = series.length) > 0)) return;
  for (var i, n, j = 0, m = series[0].length, y; j < m; ++j) {
    for (y = i = 0; i < n; ++i) y += series[i][j][1] || 0;
    if (y) for (i = 0; i < n; ++i) series[i][j][1] /= y;
  }
  none$3(series, order);
}

function diverging(series, order) {
  if (!((n = series.length) > 0)) return;
  for (var i, j = 0, d, dy, yp, yn, n, m = series[order[0]].length; j < m; ++j) {
    for (yp = yn = 0, i = 0; i < n; ++i) {
      if ((dy = (d = series[order[i]][j])[1] - d[0]) > 0) {
        d[0] = yp, d[1] = yp += dy;
      } else if (dy < 0) {
        d[1] = yn, d[0] = yn += dy;
      } else {
        d[0] = 0, d[1] = dy;
      }
    }
  }
}

function silhouette$1(series, order) {
  if (!((n = series.length) > 0)) return;
  for (var j = 0, s0 = series[order[0]], n, m = s0.length; j < m; ++j) {
    for (var i = 0, y = 0; i < n; ++i) y += series[i][j][1] || 0;
    s0[j][1] += s0[j][0] = -y / 2;
  }
  none$3(series, order);
}

function wiggle$1(series, order) {
  if (!((n = series.length) > 0) || !((m = (s0 = series[order[0]]).length) > 0)) return;
  for (var y = 0, j = 1, s0, m, n; j < m; ++j) {
    for (var i = 0, s1 = 0, s2 = 0; i < n; ++i) {
      var si = series[order[i]],
          sij0 = si[j][1] || 0,
          sij1 = si[j - 1][1] || 0,
          s3 = (sij0 - sij1) / 2;
      for (var k = 0; k < i; ++k) {
        var sk = series[order[k]],
            skj0 = sk[j][1] || 0,
            skj1 = sk[j - 1][1] || 0;
        s3 += skj0 - skj1;
      }
      s1 += sij0, s2 += s3 * sij0;
    }
    s0[j - 1][1] += s0[j - 1][0] = y;
    if (s1) y -= s2 / s1;
  }
  s0[j - 1][1] += s0[j - 1][0] = y;
  none$3(series, order);
}

function appearance(series) {
  var peaks = series.map(peak);
  return none$4(series).sort(function(a, b) { return peaks[a] - peaks[b]; });
}

function peak(series) {
  var i = -1, j = 0, n = series.length, vi, vj = -Infinity;
  while (++i < n) if ((vi = +series[i][1]) > vj) vj = vi, j = i;
  return j;
}

function ascending$3(series) {
  var sums = series.map(sum$2);
  return none$4(series).sort(function(a, b) { return sums[a] - sums[b]; });
}

function sum$2(series) {
  var s = 0, i = -1, n = series.length, v;
  while (++i < n) if (v = +series[i][1]) s += v;
  return s;
}

function descending$3(series) {
  return ascending$3(series).reverse();
}

function insideOut$1(series) {
  var n = series.length,
      i,
      j,
      sums = series.map(sum$2),
      order = appearance(series),
      top = 0,
      bottom = 0,
      tops = [],
      bottoms = [];

  for (i = 0; i < n; ++i) {
    j = order[i];
    if (top < bottom) {
      top += sums[j];
      tops.push(j);
    } else {
      bottom += sums[j];
      bottoms.push(j);
    }
  }

  return bottoms.reverse().concat(tops);
}

function reverse$1(series) {
  return none$4(series).reverse();
}



var src$3 = /*#__PURE__*/Object.freeze({
	__proto__: null,
	arc: arc$2,
	area: area$1,
	line: line$1,
	pie: pie$1,
	areaRadial: areaRadial,
	radialArea: areaRadial,
	lineRadial: lineRadial$1,
	radialLine: lineRadial$1,
	pointRadial: pointRadial,
	linkHorizontal: linkHorizontal,
	linkVertical: linkVertical,
	linkRadial: linkRadial,
	symbol: symbol$1,
	symbols: symbols$1,
	symbolCircle: circle$2,
	symbolCross: cross$2,
	symbolDiamond: diamond$1,
	symbolSquare: square$1,
	symbolStar: star$1,
	symbolTriangle: triangle$1,
	symbolWye: wye$1,
	curveBasisClosed: basisClosed$1,
	curveBasisOpen: basisOpen$1,
	curveBasis: curveBasis,
	curveBundle: bundle$1,
	curveCardinalClosed: cardinalClosed$1,
	curveCardinalOpen: cardinalOpen$1,
	curveCardinal: curveCardinal,
	curveCatmullRomClosed: catmullRomClosed$1,
	curveCatmullRomOpen: catmullRomOpen$1,
	curveCatmullRom: curveCatmullRom,
	curveLinearClosed: curveLinearClosed,
	curveLinear: curveLinear$1,
	curveMonotoneX: monotoneX$1,
	curveMonotoneY: monotoneY$1,
	curveNatural: curveNatural,
	curveStep: curveStep,
	curveStepAfter: stepAfter$1,
	curveStepBefore: stepBefore$1,
	stack: stack$1,
	stackOffsetExpand: expand$1,
	stackOffsetDiverging: diverging,
	stackOffsetNone: none$3,
	stackOffsetSilhouette: silhouette$1,
	stackOffsetWiggle: wiggle$1,
	stackOrderAppearance: appearance,
	stackOrderAscending: ascending$3,
	stackOrderDescending: descending$3,
	stackOrderInsideOut: insideOut$1,
	stackOrderNone: none$4,
	stackOrderReverse: reverse$1
});

function ascending$4(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}

function bisector$1(compare) {
  if (compare.length === 1) compare = ascendingComparator$1(compare);
  return {
    left: function(a, x, lo, hi) {
      if (lo == null) lo = 0;
      if (hi == null) hi = a.length;
      while (lo < hi) {
        var mid = lo + hi >>> 1;
        if (compare(a[mid], x) < 0) lo = mid + 1;
        else hi = mid;
      }
      return lo;
    },
    right: function(a, x, lo, hi) {
      if (lo == null) lo = 0;
      if (hi == null) hi = a.length;
      while (lo < hi) {
        var mid = lo + hi >>> 1;
        if (compare(a[mid], x) > 0) hi = mid;
        else lo = mid + 1;
      }
      return lo;
    }
  };
}

function ascendingComparator$1(f) {
  return function(d, x) {
    return ascending$4(f(d), x);
  };
}

var ascendingBisect$1 = bisector$1(ascending$4);
var bisectRight$1 = ascendingBisect$1.right;

function number$1(x) {
  return x === null ? NaN : +x;
}

function sequence$1(start, stop, step) {
  start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;

  var i = -1,
      n = Math.max(0, Math.ceil((stop - start) / step)) | 0,
      range = new Array(n);

  while (++i < n) {
    range[i] = start + i * step;
  }

  return range;
}

var e10$1 = Math.sqrt(50),
    e5$1 = Math.sqrt(10),
    e2$1 = Math.sqrt(2);

function ticks$1(start, stop, count) {
  var reverse,
      i = -1,
      n,
      ticks,
      step;

  stop = +stop, start = +start, count = +count;
  if (start === stop && count > 0) return [start];
  if (reverse = stop < start) n = start, start = stop, stop = n;
  if ((step = tickIncrement$1(start, stop, count)) === 0 || !isFinite(step)) return [];

  if (step > 0) {
    start = Math.ceil(start / step);
    stop = Math.floor(stop / step);
    ticks = new Array(n = Math.ceil(stop - start + 1));
    while (++i < n) ticks[i] = (start + i) * step;
  } else {
    start = Math.floor(start * step);
    stop = Math.ceil(stop * step);
    ticks = new Array(n = Math.ceil(start - stop + 1));
    while (++i < n) ticks[i] = (start - i) / step;
  }

  if (reverse) ticks.reverse();

  return ticks;
}

function tickIncrement$1(start, stop, count) {
  var step = (stop - start) / Math.max(0, count),
      power = Math.floor(Math.log(step) / Math.LN10),
      error = step / Math.pow(10, power);
  return power >= 0
      ? (error >= e10$1 ? 10 : error >= e5$1 ? 5 : error >= e2$1 ? 2 : 1) * Math.pow(10, power)
      : -Math.pow(10, -power) / (error >= e10$1 ? 10 : error >= e5$1 ? 5 : error >= e2$1 ? 2 : 1);
}

function tickStep$1(start, stop, count) {
  var step0 = Math.abs(stop - start) / Math.max(0, count),
      step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)),
      error = step0 / step1;
  if (error >= e10$1) step1 *= 10;
  else if (error >= e5$1) step1 *= 5;
  else if (error >= e2$1) step1 *= 2;
  return stop < start ? -step1 : step1;
}

function threshold(values, p, valueof) {
  if (valueof == null) valueof = number$1;
  if (!(n = values.length)) return;
  if ((p = +p) <= 0 || n < 2) return +valueof(values[0], 0, values);
  if (p >= 1) return +valueof(values[n - 1], n - 1, values);
  var n,
      i = (n - 1) * p,
      i0 = Math.floor(i),
      value0 = +valueof(values[i0], i0, values),
      value1 = +valueof(values[i0 + 1], i0 + 1, values);
  return value0 + (value1 - value0) * (i - i0);
}

var prefix = "$";

function Map$1() {}

Map$1.prototype = map$1.prototype = {
  constructor: Map$1,
  has: function(key) {
    return (prefix + key) in this;
  },
  get: function(key) {
    return this[prefix + key];
  },
  set: function(key, value) {
    this[prefix + key] = value;
    return this;
  },
  remove: function(key) {
    var property = prefix + key;
    return property in this && delete this[property];
  },
  clear: function() {
    for (var property in this) if (property[0] === prefix) delete this[property];
  },
  keys: function() {
    var keys = [];
    for (var property in this) if (property[0] === prefix) keys.push(property.slice(1));
    return keys;
  },
  values: function() {
    var values = [];
    for (var property in this) if (property[0] === prefix) values.push(this[property]);
    return values;
  },
  entries: function() {
    var entries = [];
    for (var property in this) if (property[0] === prefix) entries.push({key: property.slice(1), value: this[property]});
    return entries;
  },
  size: function() {
    var size = 0;
    for (var property in this) if (property[0] === prefix) ++size;
    return size;
  },
  empty: function() {
    for (var property in this) if (property[0] === prefix) return false;
    return true;
  },
  each: function(f) {
    for (var property in this) if (property[0] === prefix) f(this[property], property.slice(1), this);
  }
};

function map$1(object, f) {
  var map = new Map$1;

  // Copy constructor.
  if (object instanceof Map$1) object.each(function(value, key) { map.set(key, value); });

  // Index array by numeric index or specified key function.
  else if (Array.isArray(object)) {
    var i = -1,
        n = object.length,
        o;

    if (f == null) while (++i < n) map.set(i, object[i]);
    else while (++i < n) map.set(f(o = object[i], i, object), o);
  }

  // Convert object to map.
  else if (object) for (var key in object) map.set(key, object[key]);

  return map;
}

function nest$1() {
  var keys = [],
      sortKeys = [],
      sortValues,
      rollup,
      nest;

  function apply(array, depth, createResult, setResult) {
    if (depth >= keys.length) {
      if (sortValues != null) array.sort(sortValues);
      return rollup != null ? rollup(array) : array;
    }

    var i = -1,
        n = array.length,
        key = keys[depth++],
        keyValue,
        value,
        valuesByKey = map$1(),
        values,
        result = createResult();

    while (++i < n) {
      if (values = valuesByKey.get(keyValue = key(value = array[i]) + "")) {
        values.push(value);
      } else {
        valuesByKey.set(keyValue, [value]);
      }
    }

    valuesByKey.each(function(values, key) {
      setResult(result, key, apply(values, depth, createResult, setResult));
    });

    return result;
  }

  function entries(map, depth) {
    if (++depth > keys.length) return map;
    var array, sortKey = sortKeys[depth - 1];
    if (rollup != null && depth >= keys.length) array = map.entries();
    else array = [], map.each(function(v, k) { array.push({key: k, values: entries(v, depth)}); });
    return sortKey != null ? array.sort(function(a, b) { return sortKey(a.key, b.key); }) : array;
  }

  return nest = {
    object: function(array) { return apply(array, 0, createObject, setObject); },
    map: function(array) { return apply(array, 0, createMap, setMap); },
    entries: function(array) { return entries(apply(array, 0, createMap, setMap), 0); },
    key: function(d) { keys.push(d); return nest; },
    sortKeys: function(order) { sortKeys[keys.length - 1] = order; return nest; },
    sortValues: function(order) { sortValues = order; return nest; },
    rollup: function(f) { rollup = f; return nest; }
  };
}

function createObject() {
  return {};
}

function setObject(object, key, value) {
  object[key] = value;
}

function createMap() {
  return map$1();
}

function setMap(map, key, value) {
  map.set(key, value);
}

function Set() {}

var proto = map$1.prototype;

Set.prototype = set$2.prototype = {
  constructor: Set,
  has: proto.has,
  add: function(value) {
    value += "";
    this[prefix + value] = value;
    return this;
  },
  remove: proto.remove,
  clear: proto.clear,
  values: proto.keys,
  size: proto.size,
  empty: proto.empty,
  each: proto.each
};

function set$2(object, f) {
  var set = new Set;

  // Copy constructor.
  if (object instanceof Set) object.each(function(value) { set.add(value); });

  // Otherwise, assume it’s an array.
  else if (object) {
    var i = -1, n = object.length;
    if (f == null) while (++i < n) set.add(object[i]);
    else while (++i < n) set.add(f(object[i], i, object));
  }

  return set;
}

var array$1 = Array.prototype;

var map$2 = array$1.map;
var slice$4 = array$1.slice;

var implicit$1 = {name: "implicit"};

function ordinal$1(range) {
  var index = map$1(),
      domain = [],
      unknown = implicit$1;

  range = range == null ? [] : slice$4.call(range);

  function scale(d) {
    var key = d + "", i = index.get(key);
    if (!i) {
      if (unknown !== implicit$1) return unknown;
      index.set(key, i = domain.push(d));
    }
    return range[(i - 1) % range.length];
  }

  scale.domain = function(_) {
    if (!arguments.length) return domain.slice();
    domain = [], index = map$1();
    var i = -1, n = _.length, d, key;
    while (++i < n) if (!index.has(key = (d = _[i]) + "")) index.set(key, domain.push(d));
    return scale;
  };

  scale.range = function(_) {
    return arguments.length ? (range = slice$4.call(_), scale) : range.slice();
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  scale.copy = function() {
    return ordinal$1()
        .domain(domain)
        .range(range)
        .unknown(unknown);
  };

  return scale;
}

function band$1() {
  var scale = ordinal$1().unknown(undefined),
      domain = scale.domain,
      ordinalRange = scale.range,
      range = [0, 1],
      step,
      bandwidth,
      round = false,
      paddingInner = 0,
      paddingOuter = 0,
      align = 0.5;

  delete scale.unknown;

  function rescale() {
    var n = domain().length,
        reverse = range[1] < range[0],
        start = range[reverse - 0],
        stop = range[1 - reverse];
    step = (stop - start) / Math.max(1, n - paddingInner + paddingOuter * 2);
    if (round) step = Math.floor(step);
    start += (stop - start - step * (n - paddingInner)) * align;
    bandwidth = step * (1 - paddingInner);
    if (round) start = Math.round(start), bandwidth = Math.round(bandwidth);
    var values = sequence$1(n).map(function(i) { return start + step * i; });
    return ordinalRange(reverse ? values.reverse() : values);
  }

  scale.domain = function(_) {
    return arguments.length ? (domain(_), rescale()) : domain();
  };

  scale.range = function(_) {
    return arguments.length ? (range = [+_[0], +_[1]], rescale()) : range.slice();
  };

  scale.rangeRound = function(_) {
    return range = [+_[0], +_[1]], round = true, rescale();
  };

  scale.bandwidth = function() {
    return bandwidth;
  };

  scale.step = function() {
    return step;
  };

  scale.round = function(_) {
    return arguments.length ? (round = !!_, rescale()) : round;
  };

  scale.padding = function(_) {
    return arguments.length ? (paddingInner = paddingOuter = Math.max(0, Math.min(1, _)), rescale()) : paddingInner;
  };

  scale.paddingInner = function(_) {
    return arguments.length ? (paddingInner = Math.max(0, Math.min(1, _)), rescale()) : paddingInner;
  };

  scale.paddingOuter = function(_) {
    return arguments.length ? (paddingOuter = Math.max(0, Math.min(1, _)), rescale()) : paddingOuter;
  };

  scale.align = function(_) {
    return arguments.length ? (align = Math.max(0, Math.min(1, _)), rescale()) : align;
  };

  scale.copy = function() {
    return band$1()
        .domain(domain())
        .range(range)
        .round(round)
        .paddingInner(paddingInner)
        .paddingOuter(paddingOuter)
        .align(align);
  };

  return rescale();
}

function pointish(scale) {
  var copy = scale.copy;

  scale.padding = scale.paddingOuter;
  delete scale.paddingInner;
  delete scale.paddingOuter;

  scale.copy = function() {
    return pointish(copy());
  };

  return scale;
}

function point$9() {
  return pointish(band$1().paddingInner(1));
}

function constant$7(x) {
  return function() {
    return x;
  };
}

function number$2(x) {
  return +x;
}

var unit$1 = [0, 1];

function deinterpolateLinear(a, b) {
  return (b -= (a = +a))
      ? function(x) { return (x - a) / b; }
      : constant$7(b);
}

function deinterpolateClamp(deinterpolate) {
  return function(a, b) {
    var d = deinterpolate(a = +a, b = +b);
    return function(x) { return x <= a ? 0 : x >= b ? 1 : d(x); };
  };
}

function reinterpolateClamp(reinterpolate) {
  return function(a, b) {
    var r = reinterpolate(a = +a, b = +b);
    return function(t) { return t <= 0 ? a : t >= 1 ? b : r(t); };
  };
}

function bimap$1(domain, range, deinterpolate, reinterpolate) {
  var d0 = domain[0], d1 = domain[1], r0 = range[0], r1 = range[1];
  if (d1 < d0) d0 = deinterpolate(d1, d0), r0 = reinterpolate(r1, r0);
  else d0 = deinterpolate(d0, d1), r0 = reinterpolate(r0, r1);
  return function(x) { return r0(d0(x)); };
}

function polymap$1(domain, range, deinterpolate, reinterpolate) {
  var j = Math.min(domain.length, range.length) - 1,
      d = new Array(j),
      r = new Array(j),
      i = -1;

  // Reverse descending domains.
  if (domain[j] < domain[0]) {
    domain = domain.slice().reverse();
    range = range.slice().reverse();
  }

  while (++i < j) {
    d[i] = deinterpolate(domain[i], domain[i + 1]);
    r[i] = reinterpolate(range[i], range[i + 1]);
  }

  return function(x) {
    var i = bisectRight$1(domain, x, 1, j) - 1;
    return r[i](d[i](x));
  };
}

function copy$1(source, target) {
  return target
      .domain(source.domain())
      .range(source.range())
      .interpolate(source.interpolate())
      .clamp(source.clamp());
}

// deinterpolate(a, b)(x) takes a domain value x in [a,b] and returns the corresponding parameter t in [0,1].
// reinterpolate(a, b)(t) takes a parameter t in [0,1] and returns the corresponding domain value x in [a,b].
function continuous$1(deinterpolate, reinterpolate) {
  var domain = unit$1,
      range = unit$1,
      interpolate$1 = interpolate,
      clamp = false,
      piecewise,
      output,
      input;

  function rescale() {
    piecewise = Math.min(domain.length, range.length) > 2 ? polymap$1 : bimap$1;
    output = input = null;
    return scale;
  }

  function scale(x) {
    return (output || (output = piecewise(domain, range, clamp ? deinterpolateClamp(deinterpolate) : deinterpolate, interpolate$1)))(+x);
  }

  scale.invert = function(y) {
    return (input || (input = piecewise(range, domain, deinterpolateLinear, clamp ? reinterpolateClamp(reinterpolate) : reinterpolate)))(+y);
  };

  scale.domain = function(_) {
    return arguments.length ? (domain = map$2.call(_, number$2), rescale()) : domain.slice();
  };

  scale.range = function(_) {
    return arguments.length ? (range = slice$4.call(_), rescale()) : range.slice();
  };

  scale.rangeRound = function(_) {
    return range = slice$4.call(_), interpolate$1 = interpolateRound, rescale();
  };

  scale.clamp = function(_) {
    return arguments.length ? (clamp = !!_, rescale()) : clamp;
  };

  scale.interpolate = function(_) {
    return arguments.length ? (interpolate$1 = _, rescale()) : interpolate$1;
  };

  return rescale();
}

function tickFormat$1(domain, count, specifier) {
  var start = domain[0],
      stop = domain[domain.length - 1],
      step = tickStep$1(start, stop, count == null ? 10 : count),
      precision;
  specifier = formatSpecifier(specifier == null ? ",f" : specifier);
  switch (specifier.type) {
    case "s": {
      var value = Math.max(Math.abs(start), Math.abs(stop));
      if (specifier.precision == null && !isNaN(precision = precisionPrefix(step, value))) specifier.precision = precision;
      return formatPrefix(specifier, value);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      if (specifier.precision == null && !isNaN(precision = precisionRound(step, Math.max(Math.abs(start), Math.abs(stop))))) specifier.precision = precision - (specifier.type === "e");
      break;
    }
    case "f":
    case "%": {
      if (specifier.precision == null && !isNaN(precision = precisionFixed(step))) specifier.precision = precision - (specifier.type === "%") * 2;
      break;
    }
  }
  return format(specifier);
}

function linearish$1(scale) {
  var domain = scale.domain;

  scale.ticks = function(count) {
    var d = domain();
    return ticks$1(d[0], d[d.length - 1], count == null ? 10 : count);
  };

  scale.tickFormat = function(count, specifier) {
    return tickFormat$1(domain(), count, specifier);
  };

  scale.nice = function(count) {
    if (count == null) count = 10;

    var d = domain(),
        i0 = 0,
        i1 = d.length - 1,
        start = d[i0],
        stop = d[i1],
        step;

    if (stop < start) {
      step = start, start = stop, stop = step;
      step = i0, i0 = i1, i1 = step;
    }

    step = tickIncrement$1(start, stop, count);

    if (step > 0) {
      start = Math.floor(start / step) * step;
      stop = Math.ceil(stop / step) * step;
      step = tickIncrement$1(start, stop, count);
    } else if (step < 0) {
      start = Math.ceil(start * step) / step;
      stop = Math.floor(stop * step) / step;
      step = tickIncrement$1(start, stop, count);
    }

    if (step > 0) {
      d[i0] = Math.floor(start / step) * step;
      d[i1] = Math.ceil(stop / step) * step;
      domain(d);
    } else if (step < 0) {
      d[i0] = Math.ceil(start * step) / step;
      d[i1] = Math.floor(stop * step) / step;
      domain(d);
    }

    return scale;
  };

  return scale;
}

function linear$2() {
  var scale = continuous$1(deinterpolateLinear, interpolateNumber);

  scale.copy = function() {
    return copy$1(scale, linear$2());
  };

  return linearish$1(scale);
}

function identity$6() {
  var domain = [0, 1];

  function scale(x) {
    return +x;
  }

  scale.invert = scale;

  scale.domain = scale.range = function(_) {
    return arguments.length ? (domain = map$2.call(_, number$2), scale) : domain.slice();
  };

  scale.copy = function() {
    return identity$6().domain(domain);
  };

  return linearish$1(scale);
}

function nice(domain, interval) {
  domain = domain.slice();

  var i0 = 0,
      i1 = domain.length - 1,
      x0 = domain[i0],
      x1 = domain[i1],
      t;

  if (x1 < x0) {
    t = i0, i0 = i1, i1 = t;
    t = x0, x0 = x1, x1 = t;
  }

  domain[i0] = interval.floor(x0);
  domain[i1] = interval.ceil(x1);
  return domain;
}

function deinterpolate(a, b) {
  return (b = Math.log(b / a))
      ? function(x) { return Math.log(x / a) / b; }
      : constant$7(b);
}

function reinterpolate(a, b) {
  return a < 0
      ? function(t) { return -Math.pow(-b, t) * Math.pow(-a, 1 - t); }
      : function(t) { return Math.pow(b, t) * Math.pow(a, 1 - t); };
}

function pow10(x) {
  return isFinite(x) ? +("1e" + x) : x < 0 ? 0 : x;
}

function powp(base) {
  return base === 10 ? pow10
      : base === Math.E ? Math.exp
      : function(x) { return Math.pow(base, x); };
}

function logp(base) {
  return base === Math.E ? Math.log
      : base === 10 && Math.log10
      || base === 2 && Math.log2
      || (base = Math.log(base), function(x) { return Math.log(x) / base; });
}

function reflect(f) {
  return function(x) {
    return -f(-x);
  };
}

function log() {
  var scale = continuous$1(deinterpolate, reinterpolate).domain([1, 10]),
      domain = scale.domain,
      base = 10,
      logs = logp(10),
      pows = powp(10);

  function rescale() {
    logs = logp(base), pows = powp(base);
    if (domain()[0] < 0) logs = reflect(logs), pows = reflect(pows);
    return scale;
  }

  scale.base = function(_) {
    return arguments.length ? (base = +_, rescale()) : base;
  };

  scale.domain = function(_) {
    return arguments.length ? (domain(_), rescale()) : domain();
  };

  scale.ticks = function(count) {
    var d = domain(),
        u = d[0],
        v = d[d.length - 1],
        r;

    if (r = v < u) i = u, u = v, v = i;

    var i = logs(u),
        j = logs(v),
        p,
        k,
        t,
        n = count == null ? 10 : +count,
        z = [];

    if (!(base % 1) && j - i < n) {
      i = Math.round(i) - 1, j = Math.round(j) + 1;
      if (u > 0) for (; i < j; ++i) {
        for (k = 1, p = pows(i); k < base; ++k) {
          t = p * k;
          if (t < u) continue;
          if (t > v) break;
          z.push(t);
        }
      } else for (; i < j; ++i) {
        for (k = base - 1, p = pows(i); k >= 1; --k) {
          t = p * k;
          if (t < u) continue;
          if (t > v) break;
          z.push(t);
        }
      }
    } else {
      z = ticks$1(i, j, Math.min(j - i, n)).map(pows);
    }

    return r ? z.reverse() : z;
  };

  scale.tickFormat = function(count, specifier) {
    if (specifier == null) specifier = base === 10 ? ".0e" : ",";
    if (typeof specifier !== "function") specifier = format(specifier);
    if (count === Infinity) return specifier;
    if (count == null) count = 10;
    var k = Math.max(1, base * count / scale.ticks().length); // TODO fast estimate?
    return function(d) {
      var i = d / pows(Math.round(logs(d)));
      if (i * base < base - 0.5) i *= base;
      return i <= k ? specifier(d) : "";
    };
  };

  scale.nice = function() {
    return domain(nice(domain(), {
      floor: function(x) { return pows(Math.floor(logs(x))); },
      ceil: function(x) { return pows(Math.ceil(logs(x))); }
    }));
  };

  scale.copy = function() {
    return copy$1(scale, log().base(base));
  };

  return scale;
}

function raise$1(x, exponent) {
  return x < 0 ? -Math.pow(-x, exponent) : Math.pow(x, exponent);
}

function pow() {
  var exponent = 1,
      scale = continuous$1(deinterpolate, reinterpolate),
      domain = scale.domain;

  function deinterpolate(a, b) {
    return (b = raise$1(b, exponent) - (a = raise$1(a, exponent)))
        ? function(x) { return (raise$1(x, exponent) - a) / b; }
        : constant$7(b);
  }

  function reinterpolate(a, b) {
    b = raise$1(b, exponent) - (a = raise$1(a, exponent));
    return function(t) { return raise$1(a + b * t, 1 / exponent); };
  }

  scale.exponent = function(_) {
    return arguments.length ? (exponent = +_, domain(domain())) : exponent;
  };

  scale.copy = function() {
    return copy$1(scale, pow().exponent(exponent));
  };

  return linearish$1(scale);
}

function sqrt$2() {
  return pow().exponent(0.5);
}

function quantile$1() {
  var domain = [],
      range = [],
      thresholds = [];

  function rescale() {
    var i = 0, n = Math.max(1, range.length);
    thresholds = new Array(n - 1);
    while (++i < n) thresholds[i - 1] = threshold(domain, i / n);
    return scale;
  }

  function scale(x) {
    if (!isNaN(x = +x)) return range[bisectRight$1(thresholds, x)];
  }

  scale.invertExtent = function(y) {
    var i = range.indexOf(y);
    return i < 0 ? [NaN, NaN] : [
      i > 0 ? thresholds[i - 1] : domain[0],
      i < thresholds.length ? thresholds[i] : domain[domain.length - 1]
    ];
  };

  scale.domain = function(_) {
    if (!arguments.length) return domain.slice();
    domain = [];
    for (var i = 0, n = _.length, d; i < n; ++i) if (d = _[i], d != null && !isNaN(d = +d)) domain.push(d);
    domain.sort(ascending$4);
    return rescale();
  };

  scale.range = function(_) {
    return arguments.length ? (range = slice$4.call(_), rescale()) : range.slice();
  };

  scale.quantiles = function() {
    return thresholds.slice();
  };

  scale.copy = function() {
    return quantile$1()
        .domain(domain)
        .range(range);
  };

  return scale;
}

function quantize() {
  var x0 = 0,
      x1 = 1,
      n = 1,
      domain = [0.5],
      range = [0, 1];

  function scale(x) {
    if (x <= x) return range[bisectRight$1(domain, x, 0, n)];
  }

  function rescale() {
    var i = -1;
    domain = new Array(n);
    while (++i < n) domain[i] = ((i + 1) * x1 - (i - n) * x0) / (n + 1);
    return scale;
  }

  scale.domain = function(_) {
    return arguments.length ? (x0 = +_[0], x1 = +_[1], rescale()) : [x0, x1];
  };

  scale.range = function(_) {
    return arguments.length ? (n = (range = slice$4.call(_)).length - 1, rescale()) : range.slice();
  };

  scale.invertExtent = function(y) {
    var i = range.indexOf(y);
    return i < 0 ? [NaN, NaN]
        : i < 1 ? [x0, domain[0]]
        : i >= n ? [domain[n - 1], x1]
        : [domain[i - 1], domain[i]];
  };

  scale.copy = function() {
    return quantize()
        .domain([x0, x1])
        .range(range);
  };

  return linearish$1(scale);
}

function threshold$1() {
  var domain = [0.5],
      range = [0, 1],
      n = 1;

  function scale(x) {
    if (x <= x) return range[bisectRight$1(domain, x, 0, n)];
  }

  scale.domain = function(_) {
    return arguments.length ? (domain = slice$4.call(_), n = Math.min(domain.length, range.length - 1), scale) : domain.slice();
  };

  scale.range = function(_) {
    return arguments.length ? (range = slice$4.call(_), n = Math.min(domain.length, range.length - 1), scale) : range.slice();
  };

  scale.invertExtent = function(y) {
    var i = range.indexOf(y);
    return [domain[i - 1], domain[i]];
  };

  scale.copy = function() {
    return threshold$1()
        .domain(domain)
        .range(range);
  };

  return scale;
}

var durationSecond$1 = 1000,
    durationMinute$1 = durationSecond$1 * 60,
    durationHour$1 = durationMinute$1 * 60,
    durationDay$1 = durationHour$1 * 24,
    durationWeek$1 = durationDay$1 * 7,
    durationMonth = durationDay$1 * 30,
    durationYear = durationDay$1 * 365;

function date$1(t) {
  return new Date(t);
}

function number$3(t) {
  return t instanceof Date ? +t : +new Date(+t);
}

function calendar(year, month, week, day, hour, minute, second, millisecond, format) {
  var scale = continuous$1(deinterpolateLinear, interpolateNumber),
      invert = scale.invert,
      domain = scale.domain;

  var formatMillisecond = format(".%L"),
      formatSecond = format(":%S"),
      formatMinute = format("%I:%M"),
      formatHour = format("%I %p"),
      formatDay = format("%a %d"),
      formatWeek = format("%b %d"),
      formatMonth = format("%B"),
      formatYear = format("%Y");

  var tickIntervals = [
    [second,  1,      durationSecond$1],
    [second,  5,  5 * durationSecond$1],
    [second, 15, 15 * durationSecond$1],
    [second, 30, 30 * durationSecond$1],
    [minute,  1,      durationMinute$1],
    [minute,  5,  5 * durationMinute$1],
    [minute, 15, 15 * durationMinute$1],
    [minute, 30, 30 * durationMinute$1],
    [  hour,  1,      durationHour$1  ],
    [  hour,  3,  3 * durationHour$1  ],
    [  hour,  6,  6 * durationHour$1  ],
    [  hour, 12, 12 * durationHour$1  ],
    [   day,  1,      durationDay$1   ],
    [   day,  2,  2 * durationDay$1   ],
    [  week,  1,      durationWeek$1  ],
    [ month,  1,      durationMonth ],
    [ month,  3,  3 * durationMonth ],
    [  year,  1,      durationYear  ]
  ];

  function tickFormat(date) {
    return (second(date) < date ? formatMillisecond
        : minute(date) < date ? formatSecond
        : hour(date) < date ? formatMinute
        : day(date) < date ? formatHour
        : month(date) < date ? (week(date) < date ? formatDay : formatWeek)
        : year(date) < date ? formatMonth
        : formatYear)(date);
  }

  function tickInterval(interval, start, stop, step) {
    if (interval == null) interval = 10;

    // If a desired tick count is specified, pick a reasonable tick interval
    // based on the extent of the domain and a rough estimate of tick size.
    // Otherwise, assume interval is already a time interval and use it.
    if (typeof interval === "number") {
      var target = Math.abs(stop - start) / interval,
          i = bisector$1(function(i) { return i[2]; }).right(tickIntervals, target);
      if (i === tickIntervals.length) {
        step = tickStep$1(start / durationYear, stop / durationYear, interval);
        interval = year;
      } else if (i) {
        i = tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i];
        step = i[1];
        interval = i[0];
      } else {
        step = Math.max(tickStep$1(start, stop, interval), 1);
        interval = millisecond;
      }
    }

    return step == null ? interval : interval.every(step);
  }

  scale.invert = function(y) {
    return new Date(invert(y));
  };

  scale.domain = function(_) {
    return arguments.length ? domain(map$2.call(_, number$3)) : domain().map(date$1);
  };

  scale.ticks = function(interval, step) {
    var d = domain(),
        t0 = d[0],
        t1 = d[d.length - 1],
        r = t1 < t0,
        t;
    if (r) t = t0, t0 = t1, t1 = t;
    t = tickInterval(interval, t0, t1, step);
    t = t ? t.range(t0, t1 + 1) : []; // inclusive stop
    return r ? t.reverse() : t;
  };

  scale.tickFormat = function(count, specifier) {
    return specifier == null ? tickFormat : format(specifier);
  };

  scale.nice = function(interval, step) {
    var d = domain();
    return (interval = tickInterval(interval, d[0], d[d.length - 1], step))
        ? domain(nice(d, interval))
        : scale;
  };

  scale.copy = function() {
    return copy$1(scale, calendar(year, month, week, day, hour, minute, second, millisecond, format));
  };

  return scale;
}

function time() {
  return calendar(year, month, sunday, day, hour, minute, second, millisecond, timeFormat).domain([new Date(2000, 0, 1), new Date(2000, 0, 2)]);
}

function utcTime() {
  return calendar(utcYear, utcMonth, utcSunday, utcDay, utcHour, utcMinute, second, millisecond, utcFormat).domain([Date.UTC(2000, 0, 1), Date.UTC(2000, 0, 2)]);
}

function colors(s) {
  return s.match(/.{6}/g).map(function(x) {
    return "#" + x;
  });
}

var category10 = colors("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf");

var category20b = colors("393b795254a36b6ecf9c9ede6379398ca252b5cf6bcedb9c8c6d31bd9e39e7ba52e7cb94843c39ad494ad6616be7969c7b4173a55194ce6dbdde9ed6");

var category20c = colors("3182bd6baed69ecae1c6dbefe6550dfd8d3cfdae6bfdd0a231a35474c476a1d99bc7e9c0756bb19e9ac8bcbddcdadaeb636363969696bdbdbdd9d9d9");

var category20 = colors("1f77b4aec7e8ff7f0effbb782ca02c98df8ad62728ff98969467bdc5b0d58c564bc49c94e377c2f7b6d27f7f7fc7c7c7bcbd22dbdb8d17becf9edae5");

var cubehelix$2 = cubehelixLong(cubehelix(300, 0.5, 0.0), cubehelix(-240, 0.5, 1.0));

var warm = cubehelixLong(cubehelix(-100, 0.75, 0.35), cubehelix(80, 1.50, 0.8));

var cool = cubehelixLong(cubehelix(260, 0.75, 0.35), cubehelix(80, 1.50, 0.8));

var rainbow = cubehelix();

function rainbow$1(t) {
  if (t < 0 || t > 1) t -= Math.floor(t);
  var ts = Math.abs(t - 0.5);
  rainbow.h = 360 * t - 100;
  rainbow.s = 1.5 - 1.5 * ts;
  rainbow.l = 0.8 - 0.9 * ts;
  return rainbow + "";
}

function ramp(range) {
  var n = range.length;
  return function(t) {
    return range[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
  };
}

var viridis = ramp(colors("44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725"));

var magma = ramp(colors("00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf"));

var inferno = ramp(colors("00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4"));

var plasma = ramp(colors("0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921"));

function sequential(interpolator) {
  var x0 = 0,
      x1 = 1,
      clamp = false;

  function scale(x) {
    var t = (x - x0) / (x1 - x0);
    return interpolator(clamp ? Math.max(0, Math.min(1, t)) : t);
  }

  scale.domain = function(_) {
    return arguments.length ? (x0 = +_[0], x1 = +_[1], scale) : [x0, x1];
  };

  scale.clamp = function(_) {
    return arguments.length ? (clamp = !!_, scale) : clamp;
  };

  scale.interpolator = function(_) {
    return arguments.length ? (interpolator = _, scale) : interpolator;
  };

  scale.copy = function() {
    return sequential(interpolator).domain([x0, x1]).clamp(clamp);
  };

  return linearish$1(scale);
}



var d3Scale = /*#__PURE__*/Object.freeze({
	__proto__: null,
	scaleBand: band$1,
	scalePoint: point$9,
	scaleIdentity: identity$6,
	scaleLinear: linear$2,
	scaleLog: log,
	scaleOrdinal: ordinal$1,
	scaleImplicit: implicit$1,
	scalePow: pow,
	scaleSqrt: sqrt$2,
	scaleQuantile: quantile$1,
	scaleQuantize: quantize,
	scaleThreshold: threshold$1,
	scaleTime: time,
	scaleUtc: utcTime,
	schemeCategory10: category10,
	schemeCategory20b: category20b,
	schemeCategory20c: category20c,
	schemeCategory20: category20,
	interpolateCubehelixDefault: cubehelix$2,
	interpolateRainbow: rainbow$1,
	interpolateWarm: warm,
	interpolateCool: cool,
	interpolateViridis: viridis,
	interpolateMagma: magma,
	interpolateInferno: inferno,
	interpolatePlasma: plasma,
	scaleSequential: sequential
});

var drawing = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.areaLineGenerator = areaLineGenerator;
exports.areaLine = areaLine;
exports.verticalbar = verticalbar;
exports.horizontalbar = horizontalbar;
exports.pathStr = pathStr;
exports.circlePath = circlePath;
exports.rectPath = rectPath;
exports.linePath = linePath;
exports.jitterLine = jitterLine;
exports.cheapSketchy = cheapSketchy;
exports.cheapPopArtsy = cheapPopArtsy;
exports.randomColor = randomColor;
exports.painty = painty;
exports.generateSVG = generateSVG;



var _react2 = _interopRequireDefault(React$1__default);









function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

//All generic line constructors expect a projected coordinates array with x & y coordinates, if there are no y1 & x1 coordinates then it defaults to 0-width
function roundToTenth(number) {
  return Math.round(number * 10) / 10;
}

function areaLineGenerator(customAccessors, interpolator) {
  var lineGenerator = (0, src$3.area)().x0(customAccessors.x).y0(customAccessors.y).x1(customAccessors.x1).y1(customAccessors.y1).interpolate(interpolator || "linear");
  return lineGenerator;
}

function areaLine(props) {
  var lineGenerator = areaLineGenerator(props.customAccessors, props.interpolate);
  props.d = lineGenerator(props.coordinates);

  return props;
}

function verticalbar(props) {
  props.y = props.y - props.height;
  return props;
}

function horizontalbar(props) {
  //just flips height for width
  var originalHeight = props.height;
  var originalWidth = props.width;
  props.width = originalHeight;
  props.height = originalWidth;

  return props;
}

function pathStr(_ref) {
  var x = _ref.x,
      y = _ref.y,
      width = _ref.width,
      height = _ref.height,
      cx = _ref.cx,
      cy = _ref.cy,
      r = _ref.r;

  if (cx !== undefined) {
    return ["M", roundToTenth(cx - r), roundToTenth(cy), "a", r, r, 0, 1, 0, r * 2, 0, "a", r, r, 0, 1, 0, -(r * 2), 0].join(" ") + "Z";
  }
  return ["M", roundToTenth(x), roundToTenth(y), "h", width, "v", height, "h", -width, "v", -height].join(" ") + "Z";
}

function circlePath(cx, cy, r) {
  return pathStr({ cx: cx, cy: cy, r: r });
}

function rectPath(x, y, width, height) {
  return pathStr({ x: x, y: y, width: width, height: height });
}

function linePath(x1, x2, y1, y2) {
  return "M" + x1 + "," + y1 + "L" + x2 + "," + y2 + "L";
}

function jitterLine(pathNode) {
  var length = pathNode.getTotalLength();
  var j = 2;
  var x = j + Math.random() * j * 5;
  var jitteredPoints = [];
  var lineGen = (0, src$3.line)().x(function (d) {
    return d.x;
  }).y(function (d) {
    return d.y;
  }).curve(src$3.curveBasis);

  var newPoint = pathNode.getPointAtLength(0);
  jitteredPoints.push(newPoint);

  while (x < length) {
    newPoint = pathNode.getPointAtLength(x);
    var newX = newPoint.x + (Math.random() * j - j / 2);
    var newY = newPoint.y + (Math.random() * j - j / 2);
    jitteredPoints.push({ x: newX, y: newY });
    x += j + Math.random() * j * 5;
  }
  newPoint = pathNode.getPointAtLength(length);
  jitteredPoints.push(newPoint);

  return lineGen(jitteredPoints);
}

function cheapSketchy(path) {
  var opacity = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

  if (opacity === 0) {
    //no fill
    return "";
  }
  var opacitySketchyScale = (0, d3Scale.scaleLinear)().domain([0, 1]).range([10, 1]).clamp(true);
  var length = path.getTotalLength();
  var drawCode = "";
  var x = 0;
  var step = opacitySketchyScale(opacity);

  while (x < length / 2) {
    var start = path.getPointAtLength(x);
    var end = path.getPointAtLength(length - x);

    drawCode += " M" + (start.x + (Math.random() * step - step / 2)) + " " + (start.y + (Math.random() * step - step / 2)) + "L" + (end.x + (Math.random() * step - step / 2)) + " " + (end.y + (Math.random() * step - step / 2));

    x += step + Math.random() * step;
  }

  return drawCode;
}

function cheapPopArtsy(path, size) {
  var length = path.getTotalLength();
  var circles = [];
  var x = 0;
  var step = size * 3;

  while (x < length / 2) {
    var start = path.getPointAtLength(x);
    var end = path.getPointAtLength(length - x);
    var distance = Math.sqrt(Math.pow(end.x - start.x, 2) + Math.pow(end.y - start.y, 2));
    var begin = size / 2;
    while (begin < distance - size / 2) {
      var percent = begin / distance;
      var circleXa = percent * start.x;
      var circleXb = (1 - percent) * end.x;
      var circleYa = percent * start.y;
      var circleYb = (1 - percent) * end.y;
      circles.push([circleXa + circleXb, circleYa + circleYb]);
      begin = begin + (step + Math.random());
    }
    x = x + step;
  }

  return circles;
}

function randomColor(baseColor, range) {
  var hslBase = (0, src.hsl)(baseColor);
  hslBase.h = hslBase.h + (Math.floor(Math.random() * (range * 255)) - Math.floor(range / 2));
  hslBase.s = hslBase.s + (Math.floor(Math.random() * range) - Math.floor(range / 2));
  hslBase.l = hslBase.l + (Math.floor(Math.random() * range) - Math.floor(range / 2));
  return hslBase.toString();
}

function painty(markType, cloneProps) {
  delete cloneProps.markType;
  if ((markType === "path" || markType === "circle" || markType === "line" || markType === "rect") && cloneProps.style && (cloneProps.style.stroke || cloneProps.style.fill)) {
    if (markType === "circle") {
      cloneProps.d = circlePath(cloneProps.cx || 0, cloneProps.cy || 0, cloneProps.r);
    }

    if (markType === "rect") {
      cloneProps.d = rectPath(cloneProps.x || 0, cloneProps.y || 0, cloneProps.width, cloneProps.height);
    }

    if (markType === "line") {
      cloneProps.d = linePath(cloneProps.x1, cloneProps.x2, cloneProps.y1, cloneProps.y2);
    }

    (0, src$2.select)("body").append("svg").attr("id", "sketchyTempSVG");

    var fills = [];
    var outlines = [];

    cloneProps.d.split("M").filter(function (d, i) {
      return i !== 0;
    }).forEach(function (pathD, i) {
      var pathDummy = (0, src$2.select)("#sketchyTempSVG").append("path").attr("class", cloneProps.className).attr("d", "M" + pathD);

      var pathNode = pathDummy.node();

      if (cloneProps.style && cloneProps.style.fill !== "none") {
        var sketchyFill = cheapPopArtsy(pathNode, 4);
        var fillProps = _extends({}, cloneProps);
        var fillStyle = _extends({}, cloneProps.style);
        var fillValue = fillStyle.fill;
        fillProps.style = fillStyle;
        delete fillProps.d;
        delete fillProps.style.fillOpacity;
        delete fillProps.style.stroke;
        delete fillProps.style.strokeWidth;

        fills.push(sketchyFill.map(function (circle, ci) {
          fillProps.key = "painty-fill-" + i + "-" + ci;
          fillProps.cx = circle[0];
          fillProps.cy = circle[1];
          fillProps.style = _extends({}, fillProps.style);
          fillProps.style.fill = fillProps.style.fill.substr(0, 3) === "url" ? fillProps.style.fill : randomColor(fillValue, 0.05);
          fillProps.r = Math.random() * 2 + 3;
          return _react2.default.createElement("circle", fillProps);
        }));
      }

      if (cloneProps.style && cloneProps.style.stroke !== "none" && cloneProps.style.strokeWidth !== 0) {
        var sketchyOutline = jitterLine(pathNode);

        var outlineProps = _extends({}, cloneProps);
        var outlineStyle = _extends({}, cloneProps.style);
        outlineProps.style = outlineStyle;
        outlineProps.d = sketchyOutline;
        outlineProps.key = "painty-outline-" + i;
        outlineProps.style.fill = "none";

        outlines.push(_react2.default.createElement("path", outlineProps));
      }
    });

    (0, src$2.select)("#sketchyTempSVG").remove();

    return [_react2.default.createElement("path", {
      key: "painty-interaction-overlay",
      d: cloneProps.d,
      style: { opacity: 0 }
    }), _react2.default.createElement(
      "g",
      { key: "painty-fill", style: { filter: "url(#paintyFilterHeavy)" } },
      fills
    ), outlines];
  }

  return _react2.default.createElement(markType, cloneProps);
}

function generateSVG(props, className) {
  var markType = props.markType;
  var renderMode = props.renderMode;

  var cloneProps = _extends({}, props);
  delete cloneProps.markType;
  delete cloneProps.renderMode;
  delete cloneProps.resetAfter;
  delete cloneProps.droppable;
  delete cloneProps.nid;
  delete cloneProps.dropFunction;
  delete cloneProps.context;
  delete cloneProps.updateContext;
  delete cloneProps.parameters;
  delete cloneProps.lineDataAccessor;
  delete cloneProps.customAccessors;
  delete cloneProps.interpolate;
  delete cloneProps.forceUpdate;
  delete cloneProps.searchIterations;
  delete cloneProps.simpleInterpolate;
  delete cloneProps.transitionDuration;
  delete cloneProps.tx;
  delete cloneProps.ty;
  delete cloneProps.customTween;

  if (markType === "verticalbar") {
    markType = "rect";
    cloneProps = verticalbar(cloneProps);
  } else if (markType === "horizontalbar") {
    markType = "rect";
    cloneProps = horizontalbar(cloneProps);
  } else if (markType === "simpleline") {
    markType = "path";
    cloneProps = areaLine(cloneProps);
  }

  //        let transform = cloneProps['transform'];
  if (props.draggable) {
    delete cloneProps.transform;
  }

  cloneProps.className = className;

  var actualSVG = null;

  if (renderMode === "painty") {
    actualSVG = painty(markType, cloneProps);
  } else if (renderMode === "forcePath" && markType === "circle") {
    cloneProps.d = circlePath(cloneProps.cx || 0, cloneProps.cy || 0, cloneProps.r);
    markType = "path";
    actualSVG = _react2.default.createElement(markType, cloneProps);
  } else if (renderMode === "forcePath" && markType === "rect") {
    cloneProps.d = rectPath(cloneProps.x || 0, cloneProps.y || 0, cloneProps.width, cloneProps.height);
    markType = "path";
    actualSVG = _react2.default.createElement(markType, cloneProps);
  } else {
    if (props.markType === "text" && _typeof(cloneProps.children) !== "object") {
      cloneProps.children = _react2.default.createElement(
        "tspan",
        null,
        cloneProps.children
      );
    }
    actualSVG = _react2.default.createElement(markType, cloneProps);
  }
  return actualSVG;
}
});

unwrapExports(drawing);
var drawing_1 = drawing.areaLineGenerator;
var drawing_2 = drawing.areaLine;
var drawing_3 = drawing.verticalbar;
var drawing_4 = drawing.horizontalbar;
var drawing_5 = drawing.pathStr;
var drawing_6 = drawing.circlePath;
var drawing_7 = drawing.rectPath;
var drawing_8 = drawing.linePath;
var drawing_9 = drawing.jitterLine;
var drawing_10 = drawing.cheapSketchy;
var drawing_11 = drawing.cheapPopArtsy;
var drawing_12 = drawing.randomColor;
var drawing_13 = drawing.painty;
var drawing_14 = drawing.generateSVG;

var runtime = createCommonjsModule(function (module) {
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

!(function(global) {

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined$1; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
  var runtime = global.regeneratorRuntime;
  if (runtime) {
    {
      // If regeneratorRuntime is defined globally and we're in a module,
      // make the exports object identical to regeneratorRuntime.
      module.exports = runtime;
    }
    // Don't bother evaluating the rest of this file if the runtime was
    // already defined globally.
    return;
  }

  // Define the runtime globally (as expected by generated code) as either
  // module.exports (if we're in a module) or a new, empty object.
  runtime = global.regeneratorRuntime =  module.exports ;

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  runtime.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] =
    GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      prototype[method] = function(arg) {
        return this._invoke(method, arg);
      };
    });
  }

  runtime.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  runtime.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  runtime.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return Promise.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return Promise.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration. If the Promise is rejected, however, the
          // result for this iteration will be rejected with the same
          // reason. Note that rejections of yielded Promises are not
          // thrown back into the generator function, as is the case
          // when an awaited Promise is rejected. This difference in
          // behavior between yield and await is important, because it
          // allows the consumer to decide what to do with the yielded
          // rejection (swallow it and continue, manually .throw it back
          // into the generator, abandon iteration, whatever). With
          // await, by contrast, there is no opportunity to examine the
          // rejection reason outside the generator function, so the
          // only option is to throw it from the await expression, and
          // let the generator function handle the exception.
          result.value = unwrapped;
          resolve(result);
        }, reject);
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new Promise(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  runtime.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList)
    );

    return runtime.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined$1) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        if (delegate.iterator.return) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined$1;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined$1;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[toStringTagSymbol] = "Generator";

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  runtime.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined$1;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  runtime.values = values;

  function doneResult() {
    return { value: undefined$1, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined$1;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined$1;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined$1;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined$1;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined$1;
      }

      return ContinueSentinel;
    }
  };
})(
  // In sloppy mode, unbound `this` refers to the global object, fallback to
  // Function constructor if we're in global strict mode. That is sadly a form
  // of indirect eval which violates Content Security Policy.
  (function() { return this })() || Function("return this")()
);
});

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

// This method of obtaining a reference to the global object needs to be
// kept identical to the way it is obtained in runtime.js
var g = (function() { return this })() || Function("return this")();

// Use `getOwnPropertyNames` because not all browsers support calling
// `hasOwnProperty` on the global `self` object in a worker. See #183.
var hadRuntime = g.regeneratorRuntime &&
  Object.getOwnPropertyNames(g).indexOf("regeneratorRuntime") >= 0;

// Save the old regeneratorRuntime in case it needs to be restored later.
var oldRuntime = hadRuntime && g.regeneratorRuntime;

// Force reevalutation of runtime.js.
g.regeneratorRuntime = undefined;

var runtimeModule = runtime;

if (hadRuntime) {
  // Restore the original runtime.
  g.regeneratorRuntime = oldRuntime;
} else {
  // Remove the global property added by runtime.js.
  try {
    delete g.regeneratorRuntime;
  } catch(e) {
    g.regeneratorRuntime = undefined;
  }
}

var regenerator = runtimeModule;

var segment = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.RoughSegmentRelation = RoughSegmentRelation;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function RoughSegmentRelation() {
  return {
    LEFT: 0,
    RIGHT: 1,
    INTERSECTS: 2,
    AHEAD: 3,
    BEHIND: 4,
    SEPARATE: 5,
    UNDEFINED: 6
  };
}

var RoughSegment = exports.RoughSegment = function () {
  function RoughSegment(px1, py1, px2, py2) {
    _classCallCheck(this, RoughSegment);

    this.RoughSegmentRelationConst = RoughSegmentRelation();
    this.px1 = px1;
    this.py1 = py1;
    this.px2 = px2;
    this.py2 = py2;
    this.xi = Number.MAX_VALUE;
    this.yi = Number.MAX_VALUE;
    this.a = py2 - py1;
    this.b = px1 - px2;
    this.c = px2 * py1 - px1 * py2;
    this._undefined = this.a == 0 && this.b == 0 && this.c == 0;
  }

  _createClass(RoughSegment, [{
    key: "isUndefined",
    value: function isUndefined() {
      return this._undefined;
    }
  }, {
    key: "compare",
    value: function compare(otherSegment) {
      if (this.isUndefined() || otherSegment.isUndefined()) {
        return this.RoughSegmentRelationConst.UNDEFINED;
      }
      var grad1 = Number.MAX_VALUE;
      var grad2 = Number.MAX_VALUE;
      var int1 = 0,
          int2 = 0;
      var a = this.a,
          b = this.b,
          c = this.c;

      if (Math.abs(b) > 0.00001) {
        grad1 = -a / b;
        int1 = -c / b;
      }
      if (Math.abs(otherSegment.b) > 0.00001) {
        grad2 = -otherSegment.a / otherSegment.b;
        int2 = -otherSegment.c / otherSegment.b;
      }

      if (grad1 == Number.MAX_VALUE) {
        if (grad2 == Number.MAX_VALUE) {
          if (-c / a != -otherSegment.c / otherSegment.a) {
            return this.RoughSegmentRelationConst.SEPARATE;
          }
          if (this.py1 >= Math.min(otherSegment.py1, otherSegment.py2) && this.py1 <= Math.max(otherSegment.py1, otherSegment.py2)) {
            this.xi = this.px1;
            this.yi = this.py1;
            return this.RoughSegmentRelationConst.INTERSECTS;
          }
          if (this.py2 >= Math.min(otherSegment.py1, otherSegment.py2) && this.py2 <= Math.max(otherSegment.py1, otherSegment.py2)) {
            this.xi = this.px2;
            this.yi = this.py2;
            return this.RoughSegmentRelationConst.INTERSECTS;
          }
          return this.RoughSegmentRelationConst.SEPARATE;
        }
        this.xi = this.px1;
        this.yi = grad2 * this.xi + int2;
        if ((this.py1 - this.yi) * (this.yi - this.py2) < -0.00001 || (otherSegment.py1 - this.yi) * (this.yi - otherSegment.py2) < -0.00001) {
          return this.RoughSegmentRelationConst.SEPARATE;
        }
        if (Math.abs(otherSegment.a) < 0.00001) {
          if ((otherSegment.px1 - this.xi) * (this.xi - otherSegment.px2) < -0.00001) {
            return this.RoughSegmentRelationConst.SEPARATE;
          }
          return this.RoughSegmentRelationConst.INTERSECTS;
        }
        return this.RoughSegmentRelationConst.INTERSECTS;
      }

      if (grad2 == Number.MAX_VALUE) {
        this.xi = otherSegment.px1;
        this.yi = grad1 * this.xi + int1;
        if ((otherSegment.py1 - this.yi) * (this.yi - otherSegment.py2) < -0.00001 || (this.py1 - this.yi) * (this.yi - this.py2) < -0.00001) {
          return this.RoughSegmentRelationConst.SEPARATE;
        }
        if (Math.abs(a) < 0.00001) {
          if ((this.px1 - this.xi) * (this.xi - this.px2) < -0.00001) {
            return this.RoughSegmentRelationConst.SEPARATE;
          }
          return this.RoughSegmentRelationConst.INTERSECTS;
        }
        return this.RoughSegmentRelationConst.INTERSECTS;
      }

      if (grad1 == grad2) {
        if (int1 != int2) {
          return this.RoughSegmentRelationConst.SEPARATE;
        }
        if (this.px1 >= Math.min(otherSegment.px1, otherSegment.px2) && this.px1 <= Math.max(otherSegment.py1, otherSegment.py2)) {
          this.xi = this.px1;
          this.yi = this.py1;
          return this.RoughSegmentRelationConst.INTERSECTS;
        }
        if (this.px2 >= Math.min(otherSegment.px1, otherSegment.px2) && this.px2 <= Math.max(otherSegment.px1, otherSegment.px2)) {
          this.xi = this.px2;
          this.yi = this.py2;
          return this.RoughSegmentRelationConst.INTERSECTS;
        }
        return this.RoughSegmentRelationConst.SEPARATE;
      }

      this.xi = (int2 - int1) / (grad1 - grad2);
      this.yi = grad1 * this.xi + int1;

      if ((this.px1 - this.xi) * (this.xi - this.px2) < -0.00001 || (otherSegment.px1 - this.xi) * (this.xi - otherSegment.px2) < -0.00001) {
        return this.RoughSegmentRelationConst.SEPARATE;
      }
      return this.RoughSegmentRelationConst.INTERSECTS;
    }
  }, {
    key: "getLength",
    value: function getLength() {
      return this._getLength(this.px1, this.py1, this.px2, this.py2);
    }
  }, {
    key: "_getLength",
    value: function _getLength(x1, y1, x2, y2) {
      var dx = x2 - x1;
      var dy = y2 - y1;
      return Math.sqrt(dx * dx + dy * dy);
    }
  }]);

  return RoughSegment;
}();
});

unwrapExports(segment);
var segment_1 = segment.RoughSegmentRelation;
var segment_2 = segment.RoughSegment;

var hachure = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RoughHachureIterator = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();



function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var RoughHachureIterator = exports.RoughHachureIterator = function () {
  function RoughHachureIterator(top, bottom, left, right, gap, sinAngle, cosAngle, tanAngle) {
    _classCallCheck(this, RoughHachureIterator);

    this.top = top;
    this.bottom = bottom;
    this.left = left;
    this.right = right;
    this.gap = gap;
    this.sinAngle = sinAngle;
    this.tanAngle = tanAngle;

    if (Math.abs(sinAngle) < 0.0001) {
      this.pos = left + gap;
    } else if (Math.abs(sinAngle) > 0.9999) {
      this.pos = top + gap;
    } else {
      this.deltaX = (bottom - top) * Math.abs(tanAngle);
      this.pos = left - Math.abs(this.deltaX);
      this.hGap = Math.abs(gap / cosAngle);
      this.sLeft = new segment.RoughSegment(left, bottom, left, top);
      this.sRight = new segment.RoughSegment(right, bottom, right, top);
    }
  }

  _createClass(RoughHachureIterator, [{
    key: "getNextLine",
    value: function getNextLine() {
      if (Math.abs(this.sinAngle) < 0.0001) {
        if (this.pos < this.right) {
          var line = [this.pos, this.top, this.pos, this.bottom];
          this.pos += this.gap;
          return line;
        }
      } else if (Math.abs(this.sinAngle) > 0.9999) {
        if (this.pos < this.bottom) {
          var _line = [this.left, this.pos, this.right, this.pos];
          this.pos += this.gap;
          return _line;
        }
      } else {
        var xLower = this.pos - this.deltaX / 2;
        var xUpper = this.pos + this.deltaX / 2;
        var yLower = this.bottom;
        var yUpper = this.top;
        if (this.pos < this.right + this.deltaX) {
          while (xLower < this.left && xUpper < this.left || xLower > this.right && xUpper > this.right) {
            this.pos += this.hGap;
            xLower = this.pos - this.deltaX / 2;
            xUpper = this.pos + this.deltaX / 2;
            if (this.pos > this.right + this.deltaX) {
              return null;
            }
          }
          var s = new segment.RoughSegment(xLower, yLower, xUpper, yUpper);
          if (s.compare(this.sLeft) == (0, segment.RoughSegmentRelation)().INTERSECTS) {
            xLower = s.xi;
            yLower = s.yi;
          }
          if (s.compare(this.sRight) == (0, segment.RoughSegmentRelation)().INTERSECTS) {
            xUpper = s.xi;
            yUpper = s.yi;
          }
          if (this.tanAngle > 0) {
            xLower = this.right - (xLower - this.left);
            xUpper = this.right - (xUpper - this.left);
          }
          var _line2 = [xLower, yLower, xUpper, yUpper];
          this.pos += this.hGap;
          return _line2;
        }
      }
      return null;
    }
  }]);

  return RoughHachureIterator;
}();
});

unwrapExports(hachure);
var hachure_1 = hachure.RoughHachureIterator;

var path$1 = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var PathToken = function () {
  function PathToken(type, text) {
    _classCallCheck(this, PathToken);

    this.type = type;
    this.text = text;
  }

  _createClass(PathToken, [{
    key: "isType",
    value: function isType(type) {
      return this.type === type;
    }
  }]);

  return PathToken;
}();

var ParsedPath = function () {
  function ParsedPath(d) {
    _classCallCheck(this, ParsedPath);

    this.PARAMS = {
      A: ["rx", "ry", "x-axis-rotation", "large-arc-flag", "sweep-flag", "x", "y"],
      a: ["rx", "ry", "x-axis-rotation", "large-arc-flag", "sweep-flag", "x", "y"],
      C: ["x1", "y1", "x2", "y2", "x", "y"],
      c: ["x1", "y1", "x2", "y2", "x", "y"],
      H: ["x"],
      h: ["x"],
      L: ["x", "y"],
      l: ["x", "y"],
      M: ["x", "y"],
      m: ["x", "y"],
      Q: ["x1", "y1", "x", "y"],
      q: ["x1", "y1", "x", "y"],
      S: ["x2", "y2", "x", "y"],
      s: ["x2", "y2", "x", "y"],
      T: ["x", "y"],
      t: ["x", "y"],
      V: ["y"],
      v: ["y"],
      Z: [],
      z: []
    };
    this.COMMAND = 0;
    this.NUMBER = 1;
    this.EOD = 2;
    this.segments = [];
    this.d = d || "";
    this.parseData(d);
    this.processPoints();
  }

  _createClass(ParsedPath, [{
    key: "loadFromSegments",
    value: function loadFromSegments(segments) {
      this.segments = segments;
      this.processPoints();
    }
  }, {
    key: "processPoints",
    value: function processPoints() {
      var first = null,
          currentPoint = [0, 0];
      for (var i = 0; i < this.segments.length; i++) {
        var s = this.segments[i];
        switch (s.key) {
          case 'M':
          case 'L':
          case 'T':
            s.point = [s.data[0], s.data[1]];
            break;
          case 'm':
          case 'l':
          case 't':
            s.point = [s.data[0] + currentPoint[0], s.data[1] + currentPoint[1]];
            break;
          case 'H':
            s.point = [s.data[0], currentPoint[1]];
            break;
          case 'h':
            s.point = [s.data[0] + currentPoint[0], currentPoint[1]];
            break;
          case 'V':
            s.point = [currentPoint[0], s.data[0]];
            break;
          case 'v':
            s.point = [currentPoint[0], s.data[0] + currentPoint[1]];
            break;
          case 'z':
          case 'Z':
            if (first) {
              s.point = [first[0], first[1]];
            }
            break;
          case 'C':
            s.point = [s.data[4], s.data[5]];
            break;
          case 'c':
            s.point = [s.data[4] + currentPoint[0], s.data[5] + currentPoint[1]];
            break;
          case 'S':
            s.point = [s.data[2], s.data[3]];
            break;
          case 's':
            s.point = [s.data[2] + currentPoint[0], s.data[3] + currentPoint[1]];
            break;
          case 'Q':
            s.point = [s.data[2], s.data[3]];
            break;
          case 'q':
            s.point = [s.data[2] + currentPoint[0], s.data[3] + currentPoint[1]];
            break;
          case 'A':
            s.point = [s.data[5], s.data[6]];
            break;
          case 'a':
            s.point = [s.data[5] + currentPoint[0], s.data[6] + currentPoint[1]];
            break;
        }
        if (s.key === 'm' || s.key === 'M') {
          first = null;
        }
        if (s.point) {
          currentPoint = s.point;
          if (!first) {
            first = s.point;
          }
        }
        if (s.key === 'z' || s.key === 'Z') {
          first = null;
        }
      }
    }
  }, {
    key: "parseData",
    value: function parseData(d) {
      var tokens = this.tokenize(d);
      var index = 0;
      var token = tokens[index];
      var mode = "BOD";
      this.segments = new Array();
      while (!token.isType(this.EOD)) {
        var param_length;
        var params = new Array();
        if (mode == "BOD") {
          if (token.text == "M" || token.text == "m") {
            index++;
            param_length = this.PARAMS[token.text].length;
            mode = token.text;
          } else {
            return this.parseData('M0,0' + d);
          }
        } else {
          if (token.isType(this.NUMBER)) {
            param_length = this.PARAMS[mode].length;
          } else {
            index++;
            param_length = this.PARAMS[token.text].length;
            mode = token.text;
          }
        }

        if (index + param_length < tokens.length) {
          for (var i = index; i < index + param_length; i++) {
            var number = tokens[i];
            if (number.isType(this.NUMBER)) {
              params[params.length] = number.text;
            } else {
              console.error("Parameter type is not a number: " + mode + "," + number.text);
              return;
            }
          }
          var segment;
          if (this.PARAMS[mode]) {
            segment = { key: mode, data: params };
          } else {
            console.error("Unsupported segment type: " + mode);
            return;
          }
          this.segments.push(segment);
          index += param_length;
          token = tokens[index];
          if (mode == "M") mode = "L";
          if (mode == "m") mode = "l";
        } else {
          console.error("Path data ended before all parameters were found");
        }
      }
    }
  }, {
    key: "tokenize",
    value: function tokenize(d) {
      var tokens = new Array();
      while (d != "") {
        if (d.match(/^([ \t\r\n,]+)/)) {
          d = d.substr(RegExp.$1.length);
        } else if (d.match(/^([aAcChHlLmMqQsStTvVzZ])/)) {
          tokens[tokens.length] = new PathToken(this.COMMAND, RegExp.$1);
          d = d.substr(RegExp.$1.length);
        } else if (d.match(/^(([-+]?[0-9]+(\.[0-9]*)?|[-+]?\.[0-9]+)([eE][-+]?[0-9]+)?)/)) {
          tokens[tokens.length] = new PathToken(this.NUMBER, parseFloat(RegExp.$1));
          d = d.substr(RegExp.$1.length);
        } else {
          console.error("Unrecognized segment command: " + d);
          return null;
        }
      }
      tokens[tokens.length] = new PathToken(this.EOD, null);
      return tokens;
    }
  }, {
    key: "closed",
    get: function get() {
      if (typeof this._closed === 'undefined') {
        this._closed = false;
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = this.segments[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var s = _step.value;

            if (s.key.toLowerCase() === 'z') {
              this._closed = true;
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      }
      return this._closed;
    }
  }]);

  return ParsedPath;
}();

var RoughPath = exports.RoughPath = function () {
  function RoughPath(d) {
    _classCallCheck(this, RoughPath);

    this.d = d;
    this.parsed = new ParsedPath(d);
    this._position = [0, 0];
    this.bezierReflectionPoint = null;
    this.quadReflectionPoint = null;
    this._first = null;
  }

  _createClass(RoughPath, [{
    key: "setPosition",
    value: function setPosition(x, y) {
      this._position = [x, y];
      if (!this._first) {
        this._first = [x, y];
      }
    }
  }, {
    key: "segments",
    get: function get() {
      return this.parsed.segments;
    }
  }, {
    key: "closed",
    get: function get() {
      return this.parsed.closed;
    }
  }, {
    key: "linearPoints",
    get: function get() {
      if (!this._linearPoints) {
        var lp = [];
        var points = [];
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = this.parsed.segments[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var s = _step2.value;

            var key = s.key.toLowerCase();
            if (key === 'm' || key === 'z') {
              if (points.length) {
                lp.push(points);
                points = [];
              }
              if (key === 'z') {
                continue;
              }
            }
            if (s.point) {
              points.push(s.point);
            }
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }

        if (points.length) {
          lp.push(points);
          points = [];
        }
        this._linearPoints = lp;
      }
      return this._linearPoints;
    }
  }, {
    key: "first",
    get: function get() {
      return this._first;
    },
    set: function set(v) {
      this._first = v;
    }
  }, {
    key: "position",
    get: function get() {
      return this._position;
    }
  }, {
    key: "x",
    get: function get() {
      return this._position[0];
    }
  }, {
    key: "y",
    get: function get() {
      return this._position[1];
    }
  }]);

  return RoughPath;
}();

var RoughArcConverter = exports.RoughArcConverter = function () {
  // Algorithm as described in https://www.w3.org/TR/SVG/implnote.html
  // Code adapted from nsSVGPathDataParser.cpp in Mozilla 
  // https://hg.mozilla.org/mozilla-central/file/17156fbebbc8/content/svg/content/src/nsSVGPathDataParser.cpp#l887
  function RoughArcConverter(from, to, radii, angle, largeArcFlag, sweepFlag) {
    _classCallCheck(this, RoughArcConverter);

    var radPerDeg = Math.PI / 180;
    this._segIndex = 0;
    this._numSegs = 0;
    if (from[0] == to[0] && from[1] == to[1]) {
      return;
    }
    this._rx = Math.abs(radii[0]);
    this._ry = Math.abs(radii[1]);
    this._sinPhi = Math.sin(angle * radPerDeg);
    this._cosPhi = Math.cos(angle * radPerDeg);
    var x1dash = this._cosPhi * (from[0] - to[0]) / 2.0 + this._sinPhi * (from[1] - to[1]) / 2.0;
    var y1dash = -this._sinPhi * (from[0] - to[0]) / 2.0 + this._cosPhi * (from[1] - to[1]) / 2.0;
    var root;
    var numerator = this._rx * this._rx * this._ry * this._ry - this._rx * this._rx * y1dash * y1dash - this._ry * this._ry * x1dash * x1dash;
    if (numerator < 0) {
      var s = Math.sqrt(1 - numerator / (this._rx * this._rx * this._ry * this._ry));
      this._rx = s;
      this._ry = s;
      root = 0;
    } else {
      root = (largeArcFlag == sweepFlag ? -1.0 : 1.0) * Math.sqrt(numerator / (this._rx * this._rx * y1dash * y1dash + this._ry * this._ry * x1dash * x1dash));
    }
    var cxdash = root * this._rx * y1dash / this._ry;
    var cydash = -root * this._ry * x1dash / this._rx;
    this._C = [0, 0];
    this._C[0] = this._cosPhi * cxdash - this._sinPhi * cydash + (from[0] + to[0]) / 2.0;
    this._C[1] = this._sinPhi * cxdash + this._cosPhi * cydash + (from[1] + to[1]) / 2.0;
    this._theta = this.calculateVectorAngle(1.0, 0.0, (x1dash - cxdash) / this._rx, (y1dash - cydash) / this._ry);
    var dtheta = this.calculateVectorAngle((x1dash - cxdash) / this._rx, (y1dash - cydash) / this._ry, (-x1dash - cxdash) / this._rx, (-y1dash - cydash) / this._ry);
    if (!sweepFlag && dtheta > 0) {
      dtheta -= 2 * Math.PI;
    } else if (sweepFlag && dtheta < 0) {
      dtheta += 2 * Math.PI;
    }
    this._numSegs = Math.ceil(Math.abs(dtheta / (Math.PI / 2)));
    this._delta = dtheta / this._numSegs;
    this._T = 8 / 3 * Math.sin(this._delta / 4) * Math.sin(this._delta / 4) / Math.sin(this._delta / 2);
    this._from = from;
  }

  _createClass(RoughArcConverter, [{
    key: "getNextSegment",
    value: function getNextSegment() {
      var cp1, cp2, to;
      if (this._segIndex == this._numSegs) {
        return null;
      }
      var cosTheta1 = Math.cos(this._theta);
      var sinTheta1 = Math.sin(this._theta);
      var theta2 = this._theta + this._delta;
      var cosTheta2 = Math.cos(theta2);
      var sinTheta2 = Math.sin(theta2);

      to = [this._cosPhi * this._rx * cosTheta2 - this._sinPhi * this._ry * sinTheta2 + this._C[0], this._sinPhi * this._rx * cosTheta2 + this._cosPhi * this._ry * sinTheta2 + this._C[1]];
      cp1 = [this._from[0] + this._T * (-this._cosPhi * this._rx * sinTheta1 - this._sinPhi * this._ry * cosTheta1), this._from[1] + this._T * (-this._sinPhi * this._rx * sinTheta1 + this._cosPhi * this._ry * cosTheta1)];
      cp2 = [to[0] + this._T * (this._cosPhi * this._rx * sinTheta2 + this._sinPhi * this._ry * cosTheta2), to[1] + this._T * (this._sinPhi * this._rx * sinTheta2 - this._cosPhi * this._ry * cosTheta2)];

      this._theta = theta2;
      this._from = [to[0], to[1]];
      this._segIndex++;

      return {
        cp1: cp1,
        cp2: cp2,
        to: to
      };
    }
  }, {
    key: "calculateVectorAngle",
    value: function calculateVectorAngle(ux, uy, vx, vy) {
      var ta = Math.atan2(uy, ux);
      var tb = Math.atan2(vy, vx);
      if (tb >= ta) return tb - ta;
      return 2 * Math.PI - (ta - tb);
    }
  }]);

  return RoughArcConverter;
}();

var PathFitter = exports.PathFitter = function () {
  function PathFitter(sets, closed) {
    _classCallCheck(this, PathFitter);

    this.sets = sets;
    this.closed = closed;
  }

  _createClass(PathFitter, [{
    key: "fit",
    value: function fit(simplification) {
      var outSets = [];
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = this.sets[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var set = _step3.value;

          var length = set.length;
          var estLength = Math.floor(simplification * length);
          if (estLength < 5) {
            if (length <= 5) {
              continue;
            }
            estLength = 5;
          }
          outSets.push(this.reduce(set, estLength));
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3.return) {
            _iterator3.return();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }

      var d = '';
      var _iteratorNormalCompletion4 = true;
      var _didIteratorError4 = false;
      var _iteratorError4 = undefined;

      try {
        for (var _iterator4 = outSets[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          var _set = _step4.value;

          for (var i = 0; i < _set.length; i++) {
            var point = _set[i];
            if (i === 0) {
              d += 'M' + point[0] + "," + point[1];
            } else {
              d += 'L' + point[0] + "," + point[1];
            }
          }
          if (this.closed) {
            d += 'z ';
          }
        }
      } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion4 && _iterator4.return) {
            _iterator4.return();
          }
        } finally {
          if (_didIteratorError4) {
            throw _iteratorError4;
          }
        }
      }

      return d;
    }
  }, {
    key: "distance",
    value: function distance(p1, p2) {
      return Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2));
    }
  }, {
    key: "reduce",
    value: function reduce(set, count) {
      if (set.length <= count) {
        return set;
      }
      var points = set.slice(0);
      while (points.length > count) {
        var areas = [];
        var minArea = -1;
        var minIndex = -1;
        for (var i = 1; i < points.length - 1; i++) {
          var a = this.distance(points[i - 1], points[i]);
          var b = this.distance(points[i], points[i + 1]);
          var c = this.distance(points[i - 1], points[i + 1]);
          var s = (a + b + c) / 2.0;
          var area = Math.sqrt(s * (s - a) * (s - b) * (s - c));
          areas.push(area);
          if (minArea < 0 || area < minArea) {
            minArea = area;
            minIndex = i;
          }
        }
        if (minIndex > 0) {
          points.splice(minIndex, 1);
        } else {
          break;
        }
      }
      return points;
    }
  }]);

  return PathFitter;
}();
});

unwrapExports(path$1);
var path_1 = path$1.RoughPath;
var path_2 = path$1.RoughArcConverter;
var path_3 = path$1.PathFitter;

var renderer = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RoughRenderer = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();







function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var RoughRenderer = exports.RoughRenderer = function () {
  function RoughRenderer() {
    _classCallCheck(this, RoughRenderer);
  }

  _createClass(RoughRenderer, [{
    key: "line",
    value: function line(x1, y1, x2, y2, o) {
      var ops = this._doubleLine(x1, y1, x2, y2, o);
      return { type: "path", ops: ops };
    }
  }, {
    key: "linearPath",
    value: function linearPath(points, close, o) {
      var len = (points || []).length;
      if (len > 2) {
        var ops = [];
        for (var i = 0; i < len - 1; i++) {
          ops = ops.concat(this._doubleLine(points[i][0], points[i][1], points[i + 1][0], points[i + 1][1], o));
        }
        if (close) {
          ops = ops.concat(this._doubleLine(points[len - 1][0], points[len - 1][1], points[0][0], points[0][1], o));
        }
        return { type: "path", ops: ops };
      } else if (len === 2) {
        return this.line(points[0][0], points[0][1], points[1][0], points[1][1], o);
      }
    }
  }, {
    key: "polygon",
    value: function polygon(points, o) {
      return this.linearPath(points, true, o);
    }
  }, {
    key: "rectangle",
    value: function rectangle(x, y, width, height, o) {
      var points = [[x, y], [x + width, y], [x + width, y + height], [x, y + height]];
      return this.polygon(points, o);
    }
  }, {
    key: "curve",
    value: function curve(points, o) {
      var o1 = this._curveWithOffset(points, 1 * (1 + o.roughness * 0.2), o);
      var o2 = this._curveWithOffset(points, 1.5 * (1 + o.roughness * 0.22), o);
      return { type: "path", ops: o1.concat(o2) };
    }
  }, {
    key: "ellipse",
    value: function ellipse(x, y, width, height, o) {
      var increment = Math.PI * 2 / o.curveStepCount;
      var rx = Math.abs(width / 2);
      var ry = Math.abs(height / 2);
      rx += this._getOffset(-rx * 0.05, rx * 0.05, o);
      ry += this._getOffset(-ry * 0.05, ry * 0.05, o);
      var o1 = this._ellipse(increment, x, y, rx, ry, 1, increment * this._getOffset(0.1, this._getOffset(0.4, 1, o), o), o);
      var o2 = this._ellipse(increment, x, y, rx, ry, 1.5, 0, o);
      return { type: "path", ops: o1.concat(o2) };
    }
  }, {
    key: "arc",
    value: function arc(x, y, width, height, start, stop, closed, roughClosure, o) {
      var cx = x;
      var cy = y;
      var rx = Math.abs(width / 2);
      var ry = Math.abs(height / 2);
      rx += this._getOffset(-rx * 0.01, rx * 0.01, o);
      ry += this._getOffset(-ry * 0.01, ry * 0.01, o);
      var strt = start;
      var stp = stop;
      while (strt < 0) {
        strt += Math.PI * 2;
        stp += Math.PI * 2;
      }
      if (stp - strt > Math.PI * 2) {
        strt = 0;
        stp = Math.PI * 2;
      }
      var ellipseInc = Math.PI * 2 / o.curveStepCount;
      var arcInc = Math.min(ellipseInc / 2, (stp - strt) / 2);
      var o1 = this._arc(arcInc, cx, cy, rx, ry, strt, stp, 1, o);
      var o2 = this._arc(arcInc, cx, cy, rx, ry, strt, stp, 1.5, o);
      var ops = o1.concat(o2);
      if (closed) {
        if (roughClosure) {
          ops = ops.concat(this._doubleLine(cx, cy, cx + rx * Math.cos(strt), cy + ry * Math.sin(strt), o));
          ops = ops.concat(this._doubleLine(cx, cy, cx + rx * Math.cos(stp), cy + ry * Math.sin(stp), o));
        } else {
          ops.push({ op: "lineTo", data: [cx, cy] });
          ops.push({
            op: "lineTo",
            data: [cx + rx * Math.cos(strt), cy + ry * Math.sin(strt)]
          });
        }
      }
      return { type: "path", ops: ops };
    }
  }, {
    key: "hachureFillArc",
    value: function hachureFillArc(x, y, width, height, start, stop, o) {
      var cx = x;
      var cy = y;
      var rx = Math.abs(width / 2);
      var ry = Math.abs(height / 2);
      rx += this._getOffset(-rx * 0.01, rx * 0.01, o);
      ry += this._getOffset(-ry * 0.01, ry * 0.01, o);
      var strt = start;
      var stp = stop;
      while (strt < 0) {
        strt += Math.PI * 2;
        stp += Math.PI * 2;
      }
      if (stp - strt > Math.PI * 2) {
        strt = 0;
        stp = Math.PI * 2;
      }
      var increment = (stp - strt) / o.curveStepCount;
      var xc = [],
          yc = [];
      for (var angle = strt; angle <= stp; angle = angle + increment) {
        xc.push(cx + rx * Math.cos(angle));
        yc.push(cy + ry * Math.sin(angle));
      }
      xc.push(cx + rx * Math.cos(stp));
      yc.push(cy + ry * Math.sin(stp));
      xc.push(cx);
      yc.push(cy);
      return this.hachureFillShape(xc, yc, o);
    }
  }, {
    key: "solidFillShape",
    value: function solidFillShape(xCoords, yCoords, o) {
      var ops = [];
      if (xCoords && yCoords && xCoords.length && yCoords.length && xCoords.length === yCoords.length) {
        var offset = o.maxRandomnessOffset || 0;
        var len = xCoords.length;
        if (len > 2) {
          ops.push({
            op: "move",
            data: [xCoords[0] + this._getOffset(-offset, offset, o), yCoords[0] + this._getOffset(-offset, offset, o)]
          });
          for (var i = 1; i < len; i++) {
            ops.push({
              op: "lineTo",
              data: [xCoords[i] + this._getOffset(-offset, offset, o), yCoords[i] + this._getOffset(-offset, offset, o)]
            });
          }
        }
      }
      return { type: "fillPath", ops: ops };
    }
  }, {
    key: "hachureFillShape",
    value: function hachureFillShape(xCoords, yCoords, o) {
      var ops = [];
      if (xCoords && yCoords && xCoords.length && yCoords.length) {
        var left = xCoords[0];
        var right = xCoords[0];
        var top = yCoords[0];
        var bottom = yCoords[0];
        for (var i = 1; i < xCoords.length; i++) {
          left = Math.min(left, xCoords[i]);
          right = Math.max(right, xCoords[i]);
          top = Math.min(top, yCoords[i]);
          bottom = Math.max(bottom, yCoords[i]);
        }
        var angle = o.hachureAngle;
        var gap = o.hachureGap;
        if (gap < 0) {
          gap = o.strokeWidth * 4;
        }
        gap = Math.max(gap, 0.1);

        var radPerDeg = Math.PI / 180;
        var hachureAngle = angle % 180 * radPerDeg;
        var cosAngle = Math.cos(hachureAngle);
        var sinAngle = Math.sin(hachureAngle);
        var tanAngle = Math.tan(hachureAngle);

        var it = new hachure.RoughHachureIterator(top - 1, bottom + 1, left - 1, right + 1, gap, sinAngle, cosAngle, tanAngle);
        var rectCoords = void 0;
        while ((rectCoords = it.getNextLine()) != null) {
          var lines = this._getIntersectingLines(rectCoords, xCoords, yCoords);
          for (var _i = 0; _i < lines.length; _i++) {
            if (_i < lines.length - 1) {
              var p1 = lines[_i];
              var p2 = lines[_i + 1];
              ops = ops.concat(this._doubleLine(p1[0], p1[1], p2[0], p2[1], o));
            }
          }
        }
      }
      return { type: "fillSketch", ops: ops };
    }
  }, {
    key: "hachureFillEllipse",
    value: function hachureFillEllipse(cx, cy, width, height, o) {
      var ops = [];
      var rx = Math.abs(width / 2);
      var ry = Math.abs(height / 2);
      rx += this._getOffset(-rx * 0.05, rx * 0.05, o);
      ry += this._getOffset(-ry * 0.05, ry * 0.05, o);
      var angle = o.hachureAngle;
      var gap = o.hachureGap;
      if (gap <= 0) {
        gap = o.strokeWidth * 4;
      }
      var fweight = o.fillWeight;
      if (fweight < 0) {
        fweight = o.strokeWidth / 2;
      }
      var radPerDeg = Math.PI / 180;
      var hachureAngle = angle % 180 * radPerDeg;
      var tanAngle = Math.tan(hachureAngle);
      var aspectRatio = ry / rx;
      var hyp = Math.sqrt(aspectRatio * tanAngle * aspectRatio * tanAngle + 1);
      var sinAnglePrime = aspectRatio * tanAngle / hyp;
      var cosAnglePrime = 1 / hyp;
      var gapPrime = gap / (rx * ry / Math.sqrt(ry * cosAnglePrime * (ry * cosAnglePrime) + rx * sinAnglePrime * (rx * sinAnglePrime)) / rx);
      var halfLen = Math.sqrt(rx * rx - (cx - rx + gapPrime) * (cx - rx + gapPrime));
      for (var xPos = cx - rx + gapPrime; xPos < cx + rx; xPos += gapPrime) {
        halfLen = Math.sqrt(rx * rx - (cx - xPos) * (cx - xPos));
        var p1 = this._affine(xPos, cy - halfLen, cx, cy, sinAnglePrime, cosAnglePrime, aspectRatio);
        var p2 = this._affine(xPos, cy + halfLen, cx, cy, sinAnglePrime, cosAnglePrime, aspectRatio);
        ops = ops.concat(this._doubleLine(p1[0], p1[1], p2[0], p2[1], o));
      }
      return { type: "fillSketch", ops: ops };
    }
  }, {
    key: "svgPath",
    value: function svgPath(path, o) {
      path = (path || "").replace(/\n/g, " ").replace(/(-\s)/g, "-").replace("/(ss)/g", " ");
      var p = new path$1.RoughPath(path);
      if (o.simplification) {
        var fitter = new path$1.PathFitter(p.linearPoints, p.closed);
        var d = fitter.fit(o.simplification);
        p = new path$1.RoughPath(d);
      }
      var ops = [];
      var segments = p.segments || [];
      for (var i = 0; i < segments.length; i++) {
        var s = segments[i];
        var prev = i > 0 ? segments[i - 1] : null;
        var opList = this._processSegment(p, s, prev, o);
        if (opList && opList.length) {
          ops = ops.concat(opList);
        }
      }
      return { type: "path", ops: ops };
    }

    // privates

  }, {
    key: "_bezierTo",
    value: function _bezierTo(x1, y1, x2, y2, x, y, path, o) {
      var ops = [];
      var ros = [o.maxRandomnessOffset || 1, (o.maxRandomnessOffset || 1) + 0.5];
      var f = null;
      for (var i = 0; i < 2; i++) {
        if (i === 0) {
          ops.push({ op: "move", data: [path.x, path.y] });
        } else {
          ops.push({
            op: "move",
            data: [path.x + this._getOffset(-ros[0], ros[0], o), path.y + this._getOffset(-ros[0], ros[0], o)]
          });
        }
        f = [x + this._getOffset(-ros[i], ros[i], o), y + this._getOffset(-ros[i], ros[i], o)];
        ops.push({
          op: "bcurveTo",
          data: [x1 + this._getOffset(-ros[i], ros[i], o), y1 + this._getOffset(-ros[i], ros[i], o), x2 + this._getOffset(-ros[i], ros[i], o), y2 + this._getOffset(-ros[i], ros[i], o), f[0], f[1]]
        });
      }
      path.setPosition(f[0], f[1]);
      return ops;
    }
  }, {
    key: "_processSegment",
    value: function _processSegment(path, seg, prevSeg, o) {
      var ops = [];
      switch (seg.key) {
        case "M":
        case "m":
          {
            var delta = seg.key === "m";
            if (seg.data.length >= 2) {
              var x = +seg.data[0];
              var y = +seg.data[1];
              if (delta) {
                x += path.x;
                y += path.y;
              }
              var ro = 1 * (o.maxRandomnessOffset || 0);
              x = x + this._getOffset(-ro, ro, o);
              y = y + this._getOffset(-ro, ro, o);
              path.setPosition(x, y);
              ops.push({ op: "move", data: [x, y] });
            }
            break;
          }
        case "L":
        case "l":
          {
            var _delta = seg.key === "l";
            if (seg.data.length >= 2) {
              var _x = +seg.data[0];
              var _y = +seg.data[1];
              if (_delta) {
                _x += path.x;
                _y += path.y;
              }
              ops = ops.concat(this._doubleLine(path.x, path.y, _x, _y, o));
              path.setPosition(_x, _y);
            }
            break;
          }
        case "H":
        case "h":
          {
            var _delta2 = seg.key === "h";
            if (seg.data.length) {
              var _x2 = +seg.data[0];
              if (_delta2) {
                _x2 += path.x;
              }
              ops = ops.concat(this._doubleLine(path.x, path.y, _x2, path.y, o));
              path.setPosition(_x2, path.y);
            }
            break;
          }
        case "V":
        case "v":
          {
            var _delta3 = seg.key === "v";
            if (seg.data.length) {
              var _y2 = +seg.data[0];
              if (_delta3) {
                _y2 += path.y;
              }
              ops = ops.concat(this._doubleLine(path.x, path.y, path.x, _y2, o));
              path.setPosition(path.x, _y2);
            }
            break;
          }
        case "Z":
        case "z":
          {
            if (path.first) {
              ops = ops.concat(this._doubleLine(path.x, path.y, path.first[0], path.first[1], o));
              path.setPosition(path.first[0], path.first[1]);
              path.first = null;
            }
            break;
          }
        case "C":
        case "c":
          {
            var _delta4 = seg.key === "c";
            if (seg.data.length >= 6) {
              var x1 = +seg.data[0];
              var y1 = +seg.data[1];
              var x2 = +seg.data[2];
              var y2 = +seg.data[3];
              var _x3 = +seg.data[4];
              var _y3 = +seg.data[5];
              if (_delta4) {
                x1 += path.x;
                x2 += path.x;
                _x3 += path.x;
                y1 += path.y;
                y2 += path.y;
                _y3 += path.y;
              }
              var ob = this._bezierTo(x1, y1, x2, y2, _x3, _y3, path, o);
              ops = ops.concat(ob);
              path.bezierReflectionPoint = [_x3 + (_x3 - x2), _y3 + (_y3 - y2)];
            }
            break;
          }
        case "S":
        case "s":
          {
            var _delta5 = seg.key === "s";
            if (seg.data.length >= 4) {
              var _x4 = +seg.data[0];
              var _y4 = +seg.data[1];
              var _x5 = +seg.data[2];
              var _y5 = +seg.data[3];
              if (_delta5) {
                _x4 += path.x;
                _x5 += path.x;
                _y4 += path.y;
                _y5 += path.y;
              }
              var _x6 = _x4;
              var _y6 = _y4;
              var prevKey = prevSeg ? prevSeg.key : "";
              var ref = null;
              if (prevKey == "c" || prevKey == "C" || prevKey == "s" || prevKey == "S") {
                ref = path.bezierReflectionPoint;
              }
              if (ref) {
                _x6 = ref[0];
                _y6 = ref[1];
              }
              var _ob = this._bezierTo(_x6, _y6, _x4, _y4, _x5, _y5, path, o);
              ops = ops.concat(_ob);
              path.bezierReflectionPoint = [_x5 + (_x5 - _x4), _y5 + (_y5 - _y4)];
            }
            break;
          }
        case "Q":
        case "q":
          {
            var _delta6 = seg.key === "q";
            if (seg.data.length >= 4) {
              var _x7 = +seg.data[0];
              var _y7 = +seg.data[1];
              var _x8 = +seg.data[2];
              var _y8 = +seg.data[3];
              if (_delta6) {
                _x7 += path.x;
                _x8 += path.x;
                _y7 += path.y;
                _y8 += path.y;
              }
              var offset1 = 1 * (1 + o.roughness * 0.2);
              var offset2 = 1.5 * (1 + o.roughness * 0.22);
              ops.push({
                op: "move",
                data: [path.x + this._getOffset(-offset1, offset1, o), path.y + this._getOffset(-offset1, offset1, o)]
              });
              var f = [_x8 + this._getOffset(-offset1, offset1, o), _y8 + this._getOffset(-offset1, offset1, o)];
              ops.push({
                op: "qcurveTo",
                data: [_x7 + this._getOffset(-offset1, offset1, o), _y7 + this._getOffset(-offset1, offset1, o), f[0], f[1]]
              });
              ops.push({
                op: "move",
                data: [path.x + this._getOffset(-offset2, offset2, o), path.y + this._getOffset(-offset2, offset2, o)]
              });
              f = [_x8 + this._getOffset(-offset2, offset2, o), _y8 + this._getOffset(-offset2, offset2, o)];
              ops.push({
                op: "qcurveTo",
                data: [_x7 + this._getOffset(-offset2, offset2, o), _y7 + this._getOffset(-offset2, offset2, o), f[0], f[1]]
              });
              path.setPosition(f[0], f[1]);
              path.quadReflectionPoint = [_x8 + (_x8 - _x7), _y8 + (_y8 - _y7)];
            }
            break;
          }
        case "T":
        case "t":
          {
            var _delta7 = seg.key === "t";
            if (seg.data.length >= 2) {
              var _x9 = +seg.data[0];
              var _y9 = +seg.data[1];
              if (_delta7) {
                _x9 += path.x;
                _y9 += path.y;
              }
              var _x10 = _x9;
              var _y10 = _y9;
              var _prevKey = prevSeg ? prevSeg.key : "";
              var ref = null;
              if (_prevKey == "q" || _prevKey == "Q" || _prevKey == "t" || _prevKey == "T") {
                ref = path.quadReflectionPoint;
              }
              if (ref) {
                _x10 = ref[0];
                _y10 = ref[1];
              }
              var _offset = 1 * (1 + o.roughness * 0.2);
              var _offset2 = 1.5 * (1 + o.roughness * 0.22);
              ops.push({
                op: "move",
                data: [path.x + this._getOffset(-_offset, _offset, o), path.y + this._getOffset(-_offset, _offset, o)]
              });
              var _f = [_x9 + this._getOffset(-_offset, _offset, o), _y9 + this._getOffset(-_offset, _offset, o)];
              ops.push({
                op: "qcurveTo",
                data: [_x10 + this._getOffset(-_offset, _offset, o), _y10 + this._getOffset(-_offset, _offset, o), _f[0], _f[1]]
              });
              ops.push({
                op: "move",
                data: [path.x + this._getOffset(-_offset2, _offset2, o), path.y + this._getOffset(-_offset2, _offset2, o)]
              });
              _f = [_x9 + this._getOffset(-_offset2, _offset2, o), _y9 + this._getOffset(-_offset2, _offset2, o)];
              ops.push({
                op: "qcurveTo",
                data: [_x10 + this._getOffset(-_offset2, _offset2, o), _y10 + this._getOffset(-_offset2, _offset2, o), _f[0], _f[1]]
              });
              path.setPosition(_f[0], _f[1]);
              path.quadReflectionPoint = [_x9 + (_x9 - _x10), _y9 + (_y9 - _y10)];
            }
            break;
          }
        case "A":
        case "a":
          {
            var _delta8 = seg.key === "a";
            if (seg.data.length >= 7) {
              var rx = +seg.data[0];
              var ry = +seg.data[1];
              var angle = +seg.data[2];
              var largeArcFlag = +seg.data[3];
              var sweepFlag = +seg.data[4];
              var _x11 = +seg.data[5];
              var _y11 = +seg.data[6];
              if (_delta8) {
                _x11 += path.x;
                _y11 += path.y;
              }
              if (_x11 == path.x && _y11 == path.y) {
                break;
              }
              if (rx == 0 || ry == 0) {
                ops = ops.concat(this._doubleLine(path.x, path.y, _x11, _y11, o));
                path.setPosition(_x11, _y11);
              } else {
                var _ro = o.maxRandomnessOffset || 0;
                for (var i = 0; i < 1; i++) {
                  var arcConverter = new path$1.RoughArcConverter([path.x, path.y], [_x11, _y11], [rx, ry], angle, largeArcFlag ? true : false, sweepFlag ? true : false);
                  var segment = arcConverter.getNextSegment();
                  while (segment) {
                    var _ob2 = this._bezierTo(segment.cp1[0], segment.cp1[1], segment.cp2[0], segment.cp2[1], segment.to[0], segment.to[1], path, o);
                    ops = ops.concat(_ob2);
                    segment = arcConverter.getNextSegment();
                  }
                }
              }
            }
            break;
          }
      }
      return ops;
    }
  }, {
    key: "_getOffset",
    value: function _getOffset(min, max, ops) {
      return ops.roughness * (Math.random() * (max - min) + min);
    }
  }, {
    key: "_affine",
    value: function _affine(x, y, cx, cy, sinAnglePrime, cosAnglePrime, R) {
      var A = -cx * cosAnglePrime - cy * sinAnglePrime + cx;
      var B = R * (cx * sinAnglePrime - cy * cosAnglePrime) + cy;
      var C = cosAnglePrime;
      var D = sinAnglePrime;
      var E = -R * sinAnglePrime;
      var F = R * cosAnglePrime;
      return [A + C * x + D * y, B + E * x + F * y];
    }
  }, {
    key: "_doubleLine",
    value: function _doubleLine(x1, y1, x2, y2, o) {
      var o1 = this._line(x1, y1, x2, y2, o, true, false);
      var o2 = this._line(x1, y1, x2, y2, o, true, true);
      return o1.concat(o2);
    }
  }, {
    key: "_line",
    value: function _line(x1, y1, x2, y2, o, move, overlay) {
      var lengthSq = Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2);
      var offset = o.maxRandomnessOffset || 0;
      if (offset * offset * 100 > lengthSq) {
        offset = Math.sqrt(lengthSq) / 10;
      }
      var halfOffset = offset / 2;
      var divergePoint = 0.2 + Math.random() * 0.2;
      var midDispX = o.bowing * o.maxRandomnessOffset * (y2 - y1) / 200;
      var midDispY = o.bowing * o.maxRandomnessOffset * (x1 - x2) / 200;
      midDispX = this._getOffset(-midDispX, midDispX, o);
      midDispY = this._getOffset(-midDispY, midDispY, o);
      var ops = [];
      if (move) {
        if (overlay) {
          ops.push({
            op: "move",
            data: [x1 + this._getOffset(-halfOffset, halfOffset, o), y1 + this._getOffset(-halfOffset, halfOffset, o)]
          });
        } else {
          ops.push({
            op: "move",
            data: [x1 + this._getOffset(-offset, offset, o), y1 + this._getOffset(-offset, offset, o)]
          });
        }
      }
      if (overlay) {
        ops.push({
          op: "bcurveTo",
          data: [midDispX + x1 + (x2 - x1) * divergePoint + this._getOffset(-halfOffset, halfOffset, o), midDispY + y1 + (y2 - y1) * divergePoint + this._getOffset(-halfOffset, halfOffset, o), midDispX + x1 + 2 * (x2 - x1) * divergePoint + this._getOffset(-halfOffset, halfOffset, o), midDispY + y1 + 2 * (y2 - y1) * divergePoint + this._getOffset(-halfOffset, halfOffset, o), x2 + this._getOffset(-halfOffset, halfOffset, o), y2 + this._getOffset(-halfOffset, halfOffset, o)]
        });
      } else {
        ops.push({
          op: "bcurveTo",
          data: [midDispX + x1 + (x2 - x1) * divergePoint + this._getOffset(-offset, offset, o), midDispY + y1 + (y2 - y1) * divergePoint + this._getOffset(-offset, offset, o), midDispX + x1 + 2 * (x2 - x1) * divergePoint + this._getOffset(-offset, offset, o), midDispY + y1 + 2 * (y2 - y1) * divergePoint + this._getOffset(-offset, offset, o), x2 + this._getOffset(-offset, offset, o), y2 + this._getOffset(-offset, offset, o)]
        });
      }
      return ops;
    }
  }, {
    key: "_curve",
    value: function _curve(points, closePoint, o) {
      var len = points.length;
      var ops = [];
      if (len > 3) {
        var b = [];
        var s = 1 - o.curveTightness;
        ops.push({ op: "move", data: [points[1][0], points[1][1]] });
        for (var i = 1; i + 2 < len; i++) {
          var cachedVertArray = points[i];
          b[0] = [cachedVertArray[0], cachedVertArray[1]];
          b[1] = [cachedVertArray[0] + (s * points[i + 1][0] - s * points[i - 1][0]) / 6, cachedVertArray[1] + (s * points[i + 1][1] - s * points[i - 1][1]) / 6];
          b[2] = [points[i + 1][0] + (s * points[i][0] - s * points[i + 2][0]) / 6, points[i + 1][1] + (s * points[i][1] - s * points[i + 2][1]) / 6];
          b[3] = [points[i + 1][0], points[i + 1][1]];
          ops.push({
            op: "bcurveTo",
            data: [b[1][0], b[1][1], b[2][0], b[2][1], b[3][0], b[3][1]]
          });
        }
        if (closePoint && closePoint.length === 2) {
          var ro = o.maxRandomnessOffset;
          // TODO: more roughness here?
          ops.push({
            ops: "lineTo",
            data: [closePoint[0] + this._getOffset(-ro, ro, o), closePoint[1] + +this._getOffset(-ro, ro, o)]
          });
        }
      } else if (len === 3) {
        ops.push({ op: "move", data: [points[1][0], points[1][1]] });
        ops.push({
          op: "bcurveTo",
          data: [points[1][0], points[1][1], points[2][0], points[2][1], points[2][0], points[2][1]]
        });
      } else if (len === 2) {
        ops = ops.concat(this._doubleLine(points[0][0], points[0][1], points[1][0], points[1][1], o));
      }
      return ops;
    }
  }, {
    key: "_ellipse",
    value: function _ellipse(increment, cx, cy, rx, ry, offset, overlap, o) {
      var radOffset = this._getOffset(-0.5, 0.5, o) - Math.PI / 2;
      var points = [];
      points.push([this._getOffset(-offset, offset, o) + cx + 0.9 * rx * Math.cos(radOffset - increment), this._getOffset(-offset, offset, o) + cy + 0.9 * ry * Math.sin(radOffset - increment)]);
      for (var angle = radOffset; angle < Math.PI * 2 + radOffset - 0.01; angle = angle + increment) {
        points.push([this._getOffset(-offset, offset, o) + cx + rx * Math.cos(angle), this._getOffset(-offset, offset, o) + cy + ry * Math.sin(angle)]);
      }
      points.push([this._getOffset(-offset, offset, o) + cx + rx * Math.cos(radOffset + Math.PI * 2 + overlap * 0.5), this._getOffset(-offset, offset, o) + cy + ry * Math.sin(radOffset + Math.PI * 2 + overlap * 0.5)]);
      points.push([this._getOffset(-offset, offset, o) + cx + 0.98 * rx * Math.cos(radOffset + overlap), this._getOffset(-offset, offset, o) + cy + 0.98 * ry * Math.sin(radOffset + overlap)]);
      points.push([this._getOffset(-offset, offset, o) + cx + 0.9 * rx * Math.cos(radOffset + overlap * 0.5), this._getOffset(-offset, offset, o) + cy + 0.9 * ry * Math.sin(radOffset + overlap * 0.5)]);
      return this._curve(points, null, o);
    }
  }, {
    key: "_curveWithOffset",
    value: function _curveWithOffset(points, offset, o) {
      var ps = [];
      ps.push([points[0][0] + this._getOffset(-offset, offset, o), points[0][1] + this._getOffset(-offset, offset, o)]);
      ps.push([points[0][0] + this._getOffset(-offset, offset, o), points[0][1] + this._getOffset(-offset, offset, o)]);
      for (var i = 1; i < points.length; i++) {
        ps.push([points[i][0] + this._getOffset(-offset, offset, o), points[i][1] + this._getOffset(-offset, offset, o)]);
        if (i === points.length - 1) {
          ps.push([points[i][0] + this._getOffset(-offset, offset, o), points[i][1] + this._getOffset(-offset, offset, o)]);
        }
      }
      return this._curve(ps, null, o);
    }
  }, {
    key: "_arc",
    value: function _arc(increment, cx, cy, rx, ry, strt, stp, offset, o) {
      var radOffset = strt + this._getOffset(-0.1, 0.1, o);
      var points = [];
      points.push([this._getOffset(-offset, offset, o) + cx + 0.9 * rx * Math.cos(radOffset - increment), this._getOffset(-offset, offset, o) + cy + 0.9 * ry * Math.sin(radOffset - increment)]);
      for (var angle = radOffset; angle <= stp; angle = angle + increment) {
        points.push([this._getOffset(-offset, offset, o) + cx + rx * Math.cos(angle), this._getOffset(-offset, offset, o) + cy + ry * Math.sin(angle)]);
      }
      points.push([cx + rx * Math.cos(stp), cy + ry * Math.sin(stp)]);
      points.push([cx + rx * Math.cos(stp), cy + ry * Math.sin(stp)]);
      return this._curve(points, null, o);
    }
  }, {
    key: "_getIntersectingLines",
    value: function _getIntersectingLines(lineCoords, xCoords, yCoords) {
      var intersections = [];
      var s1 = new segment.RoughSegment(lineCoords[0], lineCoords[1], lineCoords[2], lineCoords[3]);
      for (var i = 0; i < xCoords.length; i++) {
        var s2 = new segment.RoughSegment(xCoords[i], yCoords[i], xCoords[(i + 1) % xCoords.length], yCoords[(i + 1) % xCoords.length]);
        if (s1.compare(s2) == (0, segment.RoughSegmentRelation)().INTERSECTS) {
          intersections.push([s1.xi, s1.yi]);
        }
      }
      return intersections;
    }
  }]);

  return RoughRenderer;
}();
});

unwrapExports(renderer);
var renderer_1 = renderer.RoughRenderer;

var generator = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RoughGeneratorAsync = exports.RoughGenerator = undefined;



var _regenerator2 = _interopRequireDefault(regenerator);

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();



function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

self._roughScript = self.document && self.document.currentScript && self.document.currentScript.src;

var RoughGenerator = exports.RoughGenerator = function () {
  function RoughGenerator(config, canvas) {
    _classCallCheck(this, RoughGenerator);

    this.config = config || {};
    this.canvas = canvas;
    this.defaultOptions = {
      maxRandomnessOffset: 2,
      roughness: 1,
      bowing: 1,
      stroke: '#000',
      strokeWidth: 1,
      curveTightness: 0,
      curveStepCount: 9,
      fill: null,
      fillStyle: 'hachure',
      fillWeight: -1,
      hachureAngle: -41,
      hachureGap: -1
    };
    if (this.config.options) {
      this.defaultOptions = this._options(this.config.options);
    }
  }

  _createClass(RoughGenerator, [{
    key: '_options',
    value: function _options(options) {
      return options ? Object.assign({}, this.defaultOptions, options) : this.defaultOptions;
    }
  }, {
    key: '_drawable',
    value: function _drawable(shape, sets, options) {
      return { shape: shape, sets: sets || [], options: options || this.defaultOptions };
    }
  }, {
    key: 'line',
    value: function line(x1, y1, x2, y2, options) {
      var o = this._options(options);
      return this._drawable('line', [this.lib.line(x1, y1, x2, y2, o)], o);
    }
  }, {
    key: 'rectangle',
    value: function rectangle(x, y, width, height, options) {
      var o = this._options(options);
      var paths = [];
      if (o.fill) {
        var xc = [x, x + width, x + width, x];
        var yc = [y, y, y + height, y + height];
        if (o.fillStyle === 'solid') {
          paths.push(this.lib.solidFillShape(xc, yc, o));
        } else {
          paths.push(this.lib.hachureFillShape(xc, yc, o));
        }
      }
      paths.push(this.lib.rectangle(x, y, width, height, o));
      return this._drawable('rectangle', paths, o);
    }
  }, {
    key: 'ellipse',
    value: function ellipse(x, y, width, height, options) {
      var o = this._options(options);
      var paths = [];
      if (o.fill) {
        if (o.fillStyle === 'solid') {
          var shape = this.lib.ellipse(x, y, width, height, o);
          shape.type = 'fillPath';
          paths.push(shape);
        } else {
          paths.push(this.lib.hachureFillEllipse(x, y, width, height, o));
        }
      }
      paths.push(this.lib.ellipse(x, y, width, height, o));
      return this._drawable('ellipse', paths, o);
    }
  }, {
    key: 'circle',
    value: function circle(x, y, diameter, options) {
      var ret = this.ellipse(x, y, diameter, diameter, options);
      ret.shape = 'circle';
      return ret;
    }
  }, {
    key: 'linearPath',
    value: function linearPath(points, options) {
      var o = this._options(options);
      return this._drawable('linearPath', [this.lib.linearPath(points, false, o)], o);
    }
  }, {
    key: 'polygon',
    value: function polygon(points, options) {
      var o = this._options(options);
      var paths = [];
      if (o.fill) {
        var xc = [],
            yc = [];
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = points[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var p = _step.value;

            xc.push(p[0]);
            yc.push(p[1]);
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        if (o.fillStyle === 'solid') {
          paths.push(this.lib.solidFillShape(xc, yc, o));
        } else {
          paths.push(this.lib.hachureFillShape(xc, yc, o));
        }
      }
      paths.push(this.lib.linearPath(points, true, o));
      return this._drawable('polygon', paths, o);
    }
  }, {
    key: 'arc',
    value: function arc(x, y, width, height, start, stop, closed, options) {
      var o = this._options(options);
      var paths = [];
      if (closed && o.fill) {
        if (o.fillStyle === 'solid') {
          var shape = this.lib.arc(x, y, width, height, start, stop, true, false, o);
          shape.type = 'fillPath';
          paths.push(shape);
        } else {
          paths.push(this.lib.hachureFillArc(x, y, width, height, start, stop, o));
        }
      }
      paths.push(this.lib.arc(x, y, width, height, start, stop, closed, true, o));
      return this._drawable('arc', paths, o);
    }
  }, {
    key: 'curve',
    value: function curve(points, options) {
      var o = this._options(options);
      return this._drawable('curve', [this.lib.curve(points, o)], o);
    }
  }, {
    key: 'path',
    value: function path(d, options) {
      var o = this._options(options);
      var paths = [];
      if (!d) {
        return this._drawable('path', paths, o);
      }
      if (o.fill) {
        if (o.fillStyle === 'solid') {
          var shape = { type: 'path2Dfill', path: d };
          paths.push(shape);
        } else {
          var size = this._computePathSize(d);
          var xc = [0, size[0], size[0], 0];
          var yc = [0, 0, size[1], size[1]];
          var _shape = this.lib.hachureFillShape(xc, yc, o);
          _shape.type = 'path2Dpattern';
          _shape.size = size;
          _shape.path = d;
          paths.push(_shape);
        }
      }
      paths.push(this.lib.svgPath(d, o));
      return this._drawable('path', paths, o);
    }
  }, {
    key: 'toPaths',
    value: function toPaths(drawable) {
      var sets = drawable.sets || [];
      var o = drawable.options || this.defaultOptions;
      var paths = [];
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = sets[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var drawing = _step2.value;

          var path = null;
          switch (drawing.type) {
            case 'path':
              path = {
                d: this.opsToPath(drawing),
                stroke: o.stroke,
                strokeWidth: o.strokeWidth,
                fill: 'none'
              };
              break;
            case 'fillPath':
              path = {
                d: this.opsToPath(drawing),
                stroke: 'none',
                strokeWidth: 0,
                fill: o.fill
              };
              break;
            case 'fillSketch':
              path = this._fillSketch(drawing, o);
              break;
            case 'path2Dfill':
              path = {
                d: drawing.path,
                stroke: 'none',
                strokeWidth: 0,
                fill: o.fill
              };
              break;
            case 'path2Dpattern':
              {
                var size = drawing.size;
                var pattern = {
                  x: 0, y: 0, width: 1, height: 1,
                  viewBox: '0 0 ' + Math.round(size[0]) + ' ' + Math.round(size[1]),
                  patternUnits: 'objectBoundingBox',
                  path: this._fillSketch(drawing, o)
                };
                path = {
                  d: drawing.path,
                  stroke: 'none',
                  strokeWidth: 0,
                  pattern: pattern
                };
                break;
              }
          }
          if (path) {
            paths.push(path);
          }
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      return paths;
    }
  }, {
    key: '_fillSketch',
    value: function _fillSketch(drawing, o) {
      var fweight = o.fillWeight;
      if (fweight < 0) {
        fweight = o.strokeWidth / 2;
      }
      return {
        d: this.opsToPath(drawing),
        stroke: o.fill,
        strokeWidth: fweight,
        fill: 'none'
      };
    }
  }, {
    key: 'opsToPath',
    value: function opsToPath(drawing) {
      var path = '';
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = drawing.ops[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var item = _step3.value;

          var data = item.data;
          switch (item.op) {
            case 'move':
              path += 'M' + data[0] + ' ' + data[1] + ' ';
              break;
            case 'bcurveTo':
              path += 'C' + data[0] + ' ' + data[1] + ', ' + data[2] + ' ' + data[3] + ', ' + data[4] + ' ' + data[5] + ' ';
              break;
            case 'qcurveTo':
              path += 'Q' + data[0] + ' ' + data[1] + ', ' + data[2] + ' ' + data[3] + ' ';
              break;
            case 'lineTo':
              path += 'L' + data[0] + ' ' + data[1] + ' ';
              break;
          }
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3.return) {
            _iterator3.return();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }

      return path.trim();
    }
  }, {
    key: '_computePathSize',
    value: function _computePathSize(d) {
      var size = [0, 0];
      if (self.document) {
        try {
          var ns = "http://www.w3.org/2000/svg";
          var svg = self.document.createElementNS(ns, "svg");
          svg.setAttribute("width", "0");
          svg.setAttribute("height", "0");
          var pathNode = self.document.createElementNS(ns, "path");
          pathNode.setAttribute('d', d);
          svg.appendChild(pathNode);
          self.document.body.appendChild(svg);
          var bb = pathNode.getBBox();
          if (bb) {
            size[0] = bb.width || 0;
            size[1] = bb.height || 0;
          }
          self.document.body.removeChild(svg);
        } catch (err) {}
      }
      var canvasSize = this._canvasSize();
      if (!(size[0] * size[1])) {
        size = canvasSize;
      }
      size[0] = Math.min(size[0], canvasSize[0]);
      size[1] = Math.min(size[1], canvasSize[1]);
      return size;
    }
  }, {
    key: '_canvasSize',
    value: function _canvasSize() {
      var val = function val(w) {
        if (w) {
          if ((typeof w === 'undefined' ? 'undefined' : _typeof(w)) === 'object') {
            if (w.baseVal && w.baseVal.value) {
              return w.baseVal.value;
            }
          }
        }
        return w || 100;
      };
      return this.canvas ? [val(this.canvas.width), val(this.canvas.height)] : [100, 100];
    }
  }, {
    key: 'lib',
    get: function get() {
      if (!this._renderer) {
        if (self && self.workly && this.config.async && !this.config.noWorker) {
          var worklySource = this.config.worklyURL || 'https://cdn.jsdelivr.net/gh/pshihn/workly/dist/workly.min.js';
          var rendererSource = this.config.roughURL || self._roughScript;
          if (rendererSource && worklySource) {
            var code = 'importScripts(\'' + worklySource + '\', \'' + rendererSource + '\');\nworkly.expose(self.rough.createRenderer());';
            var ourl = URL.createObjectURL(new Blob([code]));
            this._renderer = workly.proxy(ourl);
          } else {
            this._renderer = new renderer.RoughRenderer();
          }
        } else {
          this._renderer = new renderer.RoughRenderer();
        }
      }
      return this._renderer;
    }
  }]);

  return RoughGenerator;
}();

var RoughGeneratorAsync = exports.RoughGeneratorAsync = function (_RoughGenerator) {
  _inherits(RoughGeneratorAsync, _RoughGenerator);

  function RoughGeneratorAsync() {
    _classCallCheck(this, RoughGeneratorAsync);

    return _possibleConstructorReturn(this, (RoughGeneratorAsync.__proto__ || Object.getPrototypeOf(RoughGeneratorAsync)).apply(this, arguments));
  }

  _createClass(RoughGeneratorAsync, [{
    key: 'line',
    value: function () {
      var _ref = _asyncToGenerator( /*#__PURE__*/_regenerator2.default.mark(function _callee(x1, y1, x2, y2, options) {
        var o;
        return _regenerator2.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                o = this._options(options);
                _context.t0 = this;
                _context.next = 4;
                return this.lib.line(x1, y1, x2, y2, o);

              case 4:
                _context.t1 = _context.sent;
                _context.t2 = [_context.t1];
                _context.t3 = o;
                return _context.abrupt('return', _context.t0._drawable.call(_context.t0, 'line', _context.t2, _context.t3));

              case 8:
              case 'end':
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function line(_x, _x2, _x3, _x4, _x5) {
        return _ref.apply(this, arguments);
      }

      return line;
    }()
  }, {
    key: 'rectangle',
    value: function () {
      var _ref2 = _asyncToGenerator( /*#__PURE__*/_regenerator2.default.mark(function _callee2(x, y, width, height, options) {
        var o, paths, xc, yc;
        return _regenerator2.default.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                o = this._options(options);
                paths = [];

                if (!o.fill) {
                  _context2.next = 18;
                  break;
                }

                xc = [x, x + width, x + width, x];
                yc = [y, y, y + height, y + height];

                if (!(o.fillStyle === 'solid')) {
                  _context2.next = 13;
                  break;
                }

                _context2.t0 = paths;
                _context2.next = 9;
                return this.lib.solidFillShape(xc, yc, o);

              case 9:
                _context2.t1 = _context2.sent;

                _context2.t0.push.call(_context2.t0, _context2.t1);

                _context2.next = 18;
                break;

              case 13:
                _context2.t2 = paths;
                _context2.next = 16;
                return this.lib.hachureFillShape(xc, yc, o);

              case 16:
                _context2.t3 = _context2.sent;

                _context2.t2.push.call(_context2.t2, _context2.t3);

              case 18:
                _context2.t4 = paths;
                _context2.next = 21;
                return this.lib.rectangle(x, y, width, height, o);

              case 21:
                _context2.t5 = _context2.sent;

                _context2.t4.push.call(_context2.t4, _context2.t5);

                return _context2.abrupt('return', this._drawable('rectangle', paths, o));

              case 24:
              case 'end':
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function rectangle(_x6, _x7, _x8, _x9, _x10) {
        return _ref2.apply(this, arguments);
      }

      return rectangle;
    }()
  }, {
    key: 'ellipse',
    value: function () {
      var _ref3 = _asyncToGenerator( /*#__PURE__*/_regenerator2.default.mark(function _callee3(x, y, width, height, options) {
        var o, paths, shape;
        return _regenerator2.default.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                o = this._options(options);
                paths = [];

                if (!o.fill) {
                  _context3.next = 16;
                  break;
                }

                if (!(o.fillStyle === 'solid')) {
                  _context3.next = 11;
                  break;
                }

                _context3.next = 6;
                return this.lib.ellipse(x, y, width, height, o);

              case 6:
                shape = _context3.sent;

                shape.type = 'fillPath';
                paths.push(shape);
                _context3.next = 16;
                break;

              case 11:
                _context3.t0 = paths;
                _context3.next = 14;
                return this.lib.hachureFillEllipse(x, y, width, height, o);

              case 14:
                _context3.t1 = _context3.sent;

                _context3.t0.push.call(_context3.t0, _context3.t1);

              case 16:
                _context3.t2 = paths;
                _context3.next = 19;
                return this.lib.ellipse(x, y, width, height, o);

              case 19:
                _context3.t3 = _context3.sent;

                _context3.t2.push.call(_context3.t2, _context3.t3);

                return _context3.abrupt('return', this._drawable('ellipse', paths, o));

              case 22:
              case 'end':
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function ellipse(_x11, _x12, _x13, _x14, _x15) {
        return _ref3.apply(this, arguments);
      }

      return ellipse;
    }()
  }, {
    key: 'circle',
    value: function () {
      var _ref4 = _asyncToGenerator( /*#__PURE__*/_regenerator2.default.mark(function _callee4(x, y, diameter, options) {
        var ret;
        return _regenerator2.default.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return this.ellipse(x, y, diameter, diameter, options);

              case 2:
                ret = _context4.sent;

                ret.shape = 'circle';
                return _context4.abrupt('return', ret);

              case 5:
              case 'end':
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function circle(_x16, _x17, _x18, _x19) {
        return _ref4.apply(this, arguments);
      }

      return circle;
    }()
  }, {
    key: 'linearPath',
    value: function () {
      var _ref5 = _asyncToGenerator( /*#__PURE__*/_regenerator2.default.mark(function _callee5(points, options) {
        var o;
        return _regenerator2.default.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                o = this._options(options);
                _context5.t0 = this;
                _context5.next = 4;
                return this.lib.linearPath(points, false, o);

              case 4:
                _context5.t1 = _context5.sent;
                _context5.t2 = [_context5.t1];
                _context5.t3 = o;
                return _context5.abrupt('return', _context5.t0._drawable.call(_context5.t0, 'linearPath', _context5.t2, _context5.t3));

              case 8:
              case 'end':
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function linearPath(_x20, _x21) {
        return _ref5.apply(this, arguments);
      }

      return linearPath;
    }()
  }, {
    key: 'polygon',
    value: function () {
      var _ref6 = _asyncToGenerator( /*#__PURE__*/_regenerator2.default.mark(function _callee6(points, options) {
        var o, paths, xc, yc, _iteratorNormalCompletion4, _didIteratorError4, _iteratorError4, _iterator4, _step4, p;

        return _regenerator2.default.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                o = this._options(options);
                paths = [];

                if (!o.fill) {
                  _context6.next = 36;
                  break;
                }

                xc = [], yc = [];
                _iteratorNormalCompletion4 = true;
                _didIteratorError4 = false;
                _iteratorError4 = undefined;
                _context6.prev = 7;

                for (_iterator4 = points[Symbol.iterator](); !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                  p = _step4.value;

                  xc.push(p[0]);
                  yc.push(p[1]);
                }
                _context6.next = 15;
                break;

              case 11:
                _context6.prev = 11;
                _context6.t0 = _context6['catch'](7);
                _didIteratorError4 = true;
                _iteratorError4 = _context6.t0;

              case 15:
                _context6.prev = 15;
                _context6.prev = 16;

                if (!_iteratorNormalCompletion4 && _iterator4.return) {
                  _iterator4.return();
                }

              case 18:
                _context6.prev = 18;

                if (!_didIteratorError4) {
                  _context6.next = 21;
                  break;
                }

                throw _iteratorError4;

              case 21:
                return _context6.finish(18);

              case 22:
                return _context6.finish(15);

              case 23:
                if (!(o.fillStyle === 'solid')) {
                  _context6.next = 31;
                  break;
                }

                _context6.t1 = paths;
                _context6.next = 27;
                return this.lib.solidFillShape(xc, yc, o);

              case 27:
                _context6.t2 = _context6.sent;

                _context6.t1.push.call(_context6.t1, _context6.t2);

                _context6.next = 36;
                break;

              case 31:
                _context6.t3 = paths;
                _context6.next = 34;
                return this.lib.hachureFillShape(xc, yc, o);

              case 34:
                _context6.t4 = _context6.sent;

                _context6.t3.push.call(_context6.t3, _context6.t4);

              case 36:
                _context6.t5 = paths;
                _context6.next = 39;
                return this.lib.linearPath(points, true, o);

              case 39:
                _context6.t6 = _context6.sent;

                _context6.t5.push.call(_context6.t5, _context6.t6);

                return _context6.abrupt('return', this._drawable('polygon', paths, o));

              case 42:
              case 'end':
                return _context6.stop();
            }
          }
        }, _callee6, this, [[7, 11, 15, 23], [16,, 18, 22]]);
      }));

      function polygon(_x22, _x23) {
        return _ref6.apply(this, arguments);
      }

      return polygon;
    }()
  }, {
    key: 'arc',
    value: function () {
      var _ref7 = _asyncToGenerator( /*#__PURE__*/_regenerator2.default.mark(function _callee7(x, y, width, height, start, stop, closed, options) {
        var o, paths, shape;
        return _regenerator2.default.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                o = this._options(options);
                paths = [];

                if (!(closed && o.fill)) {
                  _context7.next = 16;
                  break;
                }

                if (!(o.fillStyle === 'solid')) {
                  _context7.next = 11;
                  break;
                }

                _context7.next = 6;
                return this.lib.arc(x, y, width, height, start, stop, true, false, o);

              case 6:
                shape = _context7.sent;

                shape.type = 'fillPath';
                paths.push(shape);
                _context7.next = 16;
                break;

              case 11:
                _context7.t0 = paths;
                _context7.next = 14;
                return this.lib.hachureFillArc(x, y, width, height, start, stop, o);

              case 14:
                _context7.t1 = _context7.sent;

                _context7.t0.push.call(_context7.t0, _context7.t1);

              case 16:
                _context7.t2 = paths;
                _context7.next = 19;
                return this.lib.arc(x, y, width, height, start, stop, closed, true, o);

              case 19:
                _context7.t3 = _context7.sent;

                _context7.t2.push.call(_context7.t2, _context7.t3);

                return _context7.abrupt('return', this._drawable('arc', paths, o));

              case 22:
              case 'end':
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function arc(_x24, _x25, _x26, _x27, _x28, _x29, _x30, _x31) {
        return _ref7.apply(this, arguments);
      }

      return arc;
    }()
  }, {
    key: 'curve',
    value: function () {
      var _ref8 = _asyncToGenerator( /*#__PURE__*/_regenerator2.default.mark(function _callee8(points, options) {
        var o;
        return _regenerator2.default.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                o = this._options(options);
                _context8.t0 = this;
                _context8.next = 4;
                return this.lib.curve(points, o);

              case 4:
                _context8.t1 = _context8.sent;
                _context8.t2 = [_context8.t1];
                _context8.t3 = o;
                return _context8.abrupt('return', _context8.t0._drawable.call(_context8.t0, 'curve', _context8.t2, _context8.t3));

              case 8:
              case 'end':
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function curve(_x32, _x33) {
        return _ref8.apply(this, arguments);
      }

      return curve;
    }()
  }, {
    key: 'path',
    value: function () {
      var _ref9 = _asyncToGenerator( /*#__PURE__*/_regenerator2.default.mark(function _callee9(d, options) {
        var o, paths, shape, size, xc, yc, _shape2;

        return _regenerator2.default.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                o = this._options(options);
                paths = [];

                if (d) {
                  _context9.next = 4;
                  break;
                }

                return _context9.abrupt('return', this._drawable('path', paths, o));

              case 4:
                if (!o.fill) {
                  _context9.next = 20;
                  break;
                }

                if (!(o.fillStyle === 'solid')) {
                  _context9.next = 10;
                  break;
                }

                shape = { type: 'path2Dfill', path: d };

                paths.push(shape);
                _context9.next = 20;
                break;

              case 10:
                size = this._computePathSize(d);
                xc = [0, size[0], size[0], 0];
                yc = [0, 0, size[1], size[1]];
                _context9.next = 15;
                return this.lib.hachureFillShape(xc, yc, o);

              case 15:
                _shape2 = _context9.sent;

                _shape2.type = 'path2Dpattern';
                _shape2.size = size;
                _shape2.path = d;
                paths.push(_shape2);

              case 20:
                _context9.t0 = paths;
                _context9.next = 23;
                return this.lib.svgPath(d, o);

              case 23:
                _context9.t1 = _context9.sent;

                _context9.t0.push.call(_context9.t0, _context9.t1);

                return _context9.abrupt('return', this._drawable('path', paths, o));

              case 26:
              case 'end':
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function path(_x34, _x35) {
        return _ref9.apply(this, arguments);
      }

      return path;
    }()
  }]);

  return RoughGeneratorAsync;
}(RoughGenerator);
});

unwrapExports(generator);
var generator_1 = generator.RoughGeneratorAsync;
var generator_2 = generator.RoughGenerator;

var markTransition = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
var styleTransitionWhitelist = exports.styleTransitionWhitelist = ["strokeOpacity", "fillOpacity", "strokeWidth", "fill", "stroke", "opacity", "strokeDasharray"];

var redrawSketchyList = exports.redrawSketchyList = ["fill", "stroke", "cx", "cy", "x", "y", "d", "height", "width", "x1", "x2", "y1", "y2", "rx", "ry", "r"];

var attributeTransitionWhitelist = exports.attributeTransitionWhitelist = ["transform"].concat(redrawSketchyList, styleTransitionWhitelist);

//TODO find React Everything to everything translater
var reactCSSNameStyleHash = exports.reactCSSNameStyleHash = {
  strokeWidth: "stroke-width",
  fillOpacity: "fill-opacity",
  strokeOpacity: "stroke-opacity",
  strokeDasharray: "stroke-dasharray"
};

var differentD = exports.differentD = function differentD(d, newD) {
  if (!d || !newD) {
    return true;
  }
  var lowerD = d.toLowerCase();
  var lowerNewD = newD.toLowerCase();

  if ((lowerD.match(/m/g) || []).length !== (lowerNewD.match(/m/g) || []).length) {
    return true;
  }

  if ((lowerD.match(/l/g) || []).length !== (lowerNewD.match(/l/g) || []).length) {
    return true;
  }

  if ((lowerD.match(/c/g) || []).length !== (lowerNewD.match(/c/g) || []).length) {
    return true;
  }

  if ((lowerD.match(/a/g) || []).length !== (lowerNewD.match(/a/g) || []).length) {
    return true;
  }

  return false;
};
});

unwrapExports(markTransition);
var markTransition_1 = markTransition.styleTransitionWhitelist;
var markTransition_2 = markTransition.redrawSketchyList;
var markTransition_3 = markTransition.attributeTransitionWhitelist;
var markTransition_4 = markTransition.reactCSSNameStyleHash;
var markTransition_5 = markTransition.differentD;

var Mark_1 = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();



var _react2 = _interopRequireDefault(React$1__default);













var _propTypes2 = _interopRequireDefault(propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function generateSketchyHash(props) {
  var _props$style = props.style,
      style = _props$style === undefined ? {} : _props$style;

  var sketchyHash = "";
  markTransition.redrawSketchyList.forEach(function (d) {
    sketchyHash += "-" + (style[d] || props[d]);
  });
  return sketchyHash;
}

var Mark = function (_React$Component) {
  _inherits(Mark, _React$Component);

  function Mark(props) {
    _classCallCheck(this, Mark);

    var _this = _possibleConstructorReturn(this, (Mark.__proto__ || Object.getPrototypeOf(Mark)).call(this, props));

    _this._mouseup = _this._mouseup.bind(_this);
    _this._mousedown = _this._mousedown.bind(_this);
    _this._mousemove = _this._mousemove.bind(_this);

    _this.state = {
      translate: [0, 0],
      mouseOrigin: [],
      translateOrigin: [0, 0],
      dragging: false,
      uiUpdate: false,
      sketchyFill: undefined,
      sketchyHash: ""
    };
    return _this;
  }

  _createClass(Mark, [{
    key: "componentWillReceiveProps",
    value: function componentWillReceiveProps(nextProps) {
      this.updateSketchy(nextProps);
    }
  }, {
    key: "componentWillMount",
    value: function componentWillMount() {
      this.updateSketchy(this.props);
    }
  }, {
    key: "updateSketchy",
    value: function updateSketchy(nextProps) {
      var renderOptions = nextProps.renderMode !== null && _typeof(nextProps.renderMode) === "object" ? nextProps.renderMode : { renderMode: nextProps.renderMode };

      var sketchyHash = renderOptions.renderMode === "sketchy" && generateSketchyHash(nextProps);
      if (sketchyHash && sketchyHash !== this.state.sketchyHash) {
        var _nextProps$style = nextProps.style,
            style = _nextProps$style === undefined ? {} : _nextProps$style;
        var _renderOptions$simpli = renderOptions.simplification,
            simplification = _renderOptions$simpli === undefined ? 0 : _renderOptions$simpli,
            _renderOptions$curveS = renderOptions.curveStepCount,
            curveStepCount = _renderOptions$curveS === undefined ? 9 : _renderOptions$curveS,
            _renderOptions$fillSt = renderOptions.fillStyle,
            fillStyle = _renderOptions$fillSt === undefined ? "hachure" : _renderOptions$fillSt,
            _renderOptions$roughn = renderOptions.roughness,
            roughness = _renderOptions$roughn === undefined ? 1 : _renderOptions$roughn,
            _renderOptions$bowing = renderOptions.bowing,
            bowing = _renderOptions$bowing === undefined ? 1 : _renderOptions$bowing,
            _renderOptions$fillWe = renderOptions.fillWeight,
            fillWeight = _renderOptions$fillWe === undefined ? 1 : _renderOptions$fillWe,
            _renderOptions$hachur = renderOptions.hachureAngle,
            hachureAngle = _renderOptions$hachur === undefined ? -41 : _renderOptions$hachur;


        var roughGenerator = new generator.RoughGenerator({}, { width: 1000, height: 1000 });
        var drawingInstructions = void 0;
        var roughOptions = {
          fill: style.fill || nextProps.fill,
          stroke: style.stroke || nextProps.stroke,
          strokeWidth: style.strokeWidth || nextProps.strokeWidth,
          fillStyle: fillStyle,
          roughness: roughness,
          bowing: bowing,
          fillWeight: fillWeight,
          hachureAngle: hachureAngle,
          hachureGap: renderOptions.hachureGap || style.fillOpacity && (5 - style.fillOpacity * 5) * fillWeight || fillWeight * 2,
          curveStepCount: curveStepCount,
          simplification: simplification
        };

        switch (nextProps.markType) {
          case "line":
            drawingInstructions = roughGenerator.line(nextProps.x1 || 0, nextProps.y1 || 0, nextProps.x2 || 0, nextProps.y2 || 0, roughOptions);
            break;
          case "rect":
            if (nextProps.rx || nextProps.ry) {
              drawingInstructions = roughGenerator.circle((nextProps.x || 0) + nextProps.width / 2, (nextProps.y || 0) + nextProps.width / 2, nextProps.width, roughOptions);
            } else {
              drawingInstructions = roughGenerator.rectangle(nextProps.x || 0, nextProps.y || 0, nextProps.width, nextProps.height, roughOptions);
            }
            break;
          case "circle":
            drawingInstructions = roughGenerator.circle(nextProps.cx || 0, nextProps.cy || 0, nextProps.r * 2, roughOptions);
            break;
          case "ellipse":
            drawingInstructions = roughGenerator.ellipse(nextProps.x || 0, nextProps.y || 0, nextProps.width, nextProps.height, roughOptions);
            break;
          case "polygon":
            drawingInstructions = roughGenerator.polygon(nextProps.points, roughOptions);
            break;
          case "path":
            drawingInstructions = roughGenerator.path(nextProps.d, roughOptions);
            break;
        }

        var roughPieces = [];
        roughGenerator.toPaths(drawingInstructions).forEach(function (_ref, i) {
          var d = _ref.d,
              fill = _ref.fill,
              stroke = _ref.stroke,
              strokeWidth = _ref.strokeWidth,
              pattern = _ref.pattern;

          if (pattern) {
            var roughRandomID = "rough-" + Math.random();
            roughPieces.push(_react2.default.createElement(
              "pattern",
              {
                key: "pattern-" + i,
                id: roughRandomID,
                x: pattern.x,
                y: pattern.y,
                height: pattern.height,
                width: pattern.width,
                viewBox: pattern.viewBox
              },
              _react2.default.createElement("path", {
                key: "pattern-path-" + i,
                d: pattern.path.d,
                style: {
                  fill: pattern.path.fill,
                  stroke: pattern.path.stroke,
                  strokeWidth: pattern.path.strokeWidth
                }
              })
            ));
            fill = "url(#" + roughRandomID + ")";
          }
          roughPieces.push(_react2.default.createElement("path", {
            key: "path-" + i,
            d: d,
            style: {
              fill: fill,
              stroke: stroke,
              strokeWidth: strokeWidth
            },
            transform: nextProps.transform
          }));
        });

        this.setState({
          sketchyHash: sketchyHash,
          sketchyFill: roughPieces
        });
      }
    }
  }, {
    key: "shouldComponentUpdate",
    value: function shouldComponentUpdate(nextProps) {
      var _this2 = this;

      if (nextProps.renderMode || this.props.renderMode || this.props.markType !== nextProps.markType || this.state.dragging || this.props.forceUpdate || nextProps.forceUpdate || this.props.className !== nextProps.className || this.props.children !== nextProps.children || this.props.customTween && !nextProps.customTween || !this.props.customTween && nextProps.customTween) {
        return true;
      }

      var canvas = this.props.canvas !== true && this.props.canvas || this.context && this.context.canvas;

      var node = this.node;

      var actualSVG = (0, drawing.generateSVG)(nextProps, nextProps.className);
      var cloneProps = actualSVG.props;

      if (!cloneProps) {
        return true;
      }

      var _nextProps$transition = nextProps.transitionDuration,
          transitionDuration = _nextProps$transition === undefined ? {} : _nextProps$transition;

      var isDefault = typeof transitionDuration === "number";
      var defaultDuration = isDefault ? transitionDuration : 1000;
      transitionDuration = isDefault ? { default: defaultDuration } : _extends({ default: defaultDuration }, transitionDuration);

      var newProps = Object.keys(cloneProps).filter(function (d) {
        return d !== "style";
      });
      var oldProps = Object.keys(this.props).filter(function (d) {
        return d !== "style" && !newProps.find(function (p) {
          return p === d;
        });
      });

      var hasTransition = (0, src$2.select)(node).select("*").transition;

      function adjustedPropName(propname) {
        return markTransition.reactCSSNameStyleHash[propname] || propname;
      }

      oldProps.forEach(function (oldProp) {
        if (oldProp !== "style") {
          (0, src$2.select)(node).select("*").attr(adjustedPropName(oldProp), undefined);
        }
      });

      newProps.forEach(function (newProp) {
        if (!hasTransition || !markTransition.attributeTransitionWhitelist.find(function (d) {
          return d === newProp;
        }) || newProp === "d" && (0, markTransition.differentD)(cloneProps.d, _this2.props.d)) {
          if (newProp === "d" && nextProps.customTween) {
            (0, src$2.select)(node).select("*").attr("d", nextProps.customTween.fn(nextProps.customTween.props, nextProps.customTween.props)(1));
          } else {
            (0, src$2.select)(node).select("*").attr(adjustedPropName(newProp), cloneProps[newProp]);
          }
        } else {
          var _transitionDuration = transitionDuration,
              defaultDur = _transitionDuration.default,
              _transitionDuration$n = _transitionDuration[newProp],
              appliedDuration = _transitionDuration$n === undefined ? defaultDur : _transitionDuration$n;


          if (newProp === "d" && nextProps.customTween) {
            var initialTweenProps = _extends({}, _this2.props.customTween.props);
            var nextTweenProps = _extends({}, nextProps.customTween.props);
            (0, src$2.select)(node).select("*").transition(adjustedPropName("d")).duration(appliedDuration).attrTween("d", function () {
              return nextProps.customTween.fn(initialTweenProps, nextTweenProps);
            });
          } else {
            (0, src$2.select)(node).select("*").transition(adjustedPropName(newProp)).duration(appliedDuration).attr(adjustedPropName(newProp), cloneProps[newProp]);
          }
        }
      });

      var newStyleProps = Object.keys(cloneProps.style || {});
      var oldStyleProps = Object.keys(this.props.style || {}).filter(function (d) {
        return !newStyleProps.find(function (p) {
          return p === d;
        });
      });

      oldStyleProps.forEach(function (oldProp) {
        (0, src$2.select)(node).select("*").style(adjustedPropName(oldProp), undefined);
      });

      newStyleProps.forEach(function (newProp) {
        if (!hasTransition) {
          (0, src$2.select)(node).select("*").style(adjustedPropName(newProp), cloneProps.style[newProp]);
        } else {
          var _transitionDuration2 = transitionDuration,
              defaultDur = _transitionDuration2.default,
              _transitionDuration2$ = _transitionDuration2[newProp],
              appliedDuration = _transitionDuration2$ === undefined ? defaultDur : _transitionDuration2$;


          (0, src$2.select)(node).select("*").transition(adjustedPropName(newProp)).duration(appliedDuration).style(adjustedPropName(newProp), cloneProps.style[newProp]);
        }
      });

      return false;
    }
  }, {
    key: "_mouseup",
    value: function _mouseup() {
      document.onmousemove = null;

      var finalTranslate = [0, 0];
      if (!this.props.resetAfter) finalTranslate = this.state.translate;

      this.setState({
        dragging: false,
        translate: finalTranslate,
        uiUpdate: false
      });
      if (this.props.dropFunction && this.props.context && this.props.context.dragSource) {
        this.props.dropFunction(this.props.context.dragSource.props, this.props);
        this.props.updateContext("dragSource", undefined);
      }
    }
  }, {
    key: "_mousedown",
    value: function _mousedown(event) {
      this.setState({
        mouseOrigin: [event.pageX, event.pageY],
        translateOrigin: this.state.translate,
        dragging: true
      });
      document.onmouseup = this._mouseup;
      document.onmousemove = this._mousemove;
    }
  }, {
    key: "_mousemove",
    value: function _mousemove(event) {
      var xAdjust = this.props.freezeX ? 0 : 1;
      var yAdjust = this.props.freezeY ? 0 : 1;

      var adjustedPosition = [event.pageX - this.state.mouseOrigin[0], event.pageY - this.state.mouseOrigin[1]];
      var adjustedTranslate = [(adjustedPosition[0] + this.state.translateOrigin[0]) * xAdjust, (adjustedPosition[1] + this.state.translateOrigin[1]) * yAdjust];
      if (this.props.dropFunction && this.state.uiUpdate === false) {
        this.props.updateContext("dragSource", this);
        this.setState({
          translate: adjustedTranslate,
          uiUpdate: true,
          dragging: true
        });
      } else {
        this.setState({ translate: adjustedTranslate });
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _this3 = this;

      var className = this.props.className || "";

      var mouseIn = null;
      var mouseOut = null;

      var actualSVG = (this.props.renderMode === "sketchy" || this.props.renderMode && this.props.renderMode.renderMode === "sketchy") && this.state.sketchyFill || (0, drawing.generateSVG)(this.props, className);

      if (this.props.draggable) {
        return _react2.default.createElement(
          "g",
          {
            ref: function ref(node) {
              return _this3.node = node;
            },
            className: className,
            onMouseEnter: mouseIn,
            onMouseOut: mouseOut,
            onDoubleClick: this._doubleclick,
            style: {
              pointerEvents: this.props.dropFunction && this.state.dragging ? "none" : "all"
            },
            onMouseDown: this._mousedown,
            onMouseUp: this._mouseup,
            transform: "translate(" + this.state.translate + ")",
            "aria-label": this.props["aria-label"]
          },
          actualSVG
        );
      } else {
        return _react2.default.createElement(
          "g",
          {
            ref: function ref(node) {
              return _this3.node = node;
            },
            className: className,
            onMouseEnter: mouseIn,
            onMouseOut: mouseOut,
            "aria-label": this.props["aria-label"]
          },
          actualSVG
        );
      }
    }
  }]);

  return Mark;
}(_react2.default.Component);

Mark.propTypes = {
  markType: _propTypes2.default.string.isRequired,
  forceUpdate: _propTypes2.default.bool,
  renderMode: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.func, _propTypes2.default.object]),
  draggable: _propTypes2.default.bool,
  dropFunction: _propTypes2.default.func,
  resetAfter: _propTypes2.default.bool,
  freezeX: _propTypes2.default.bool,
  freezeY: _propTypes2.default.bool,
  context: _propTypes2.default.object,
  updateContext: _propTypes2.default.func,
  className: _propTypes2.default.string
};

Mark.contextTypes = {
  canvas: _propTypes2.default.object
};

exports.default = Mark;
module.exports = exports['default'];
});

unwrapExports(Mark_1);

var DraggableMark_1 = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();



var _react2 = _interopRequireDefault(React$1__default);



var _Mark2 = _interopRequireDefault(Mark_1);



var _propTypes2 = _interopRequireDefault(propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var DraggableMark = function (_React$Component) {
  _inherits(DraggableMark, _React$Component);

  function DraggableMark() {
    _classCallCheck(this, DraggableMark);

    return _possibleConstructorReturn(this, (DraggableMark.__proto__ || Object.getPrototypeOf(DraggableMark)).apply(this, arguments));
  }

  _createClass(DraggableMark, [{
    key: "render",
    value: function render() {
      return _react2.default.createElement(_Mark2.default, _extends({
        draggable: true,
        resetAfter: true,
        droppable: true
      }, this.props));
    }
  }]);

  return DraggableMark;
}(_react2.default.Component);

DraggableMark.propTypes = {
  draggable: _propTypes2.default.bool,
  resetAfter: _propTypes2.default.bool,
  droppable: _propTypes2.default.bool
};

exports.default = DraggableMark;
module.exports = exports['default'];
});

unwrapExports(DraggableMark_1);

var MarkContext_1 = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();



var _react2 = _interopRequireDefault(React$1__default);



var _propTypes2 = _interopRequireDefault(propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// components

var MarkContext = function (_React$Component) {
  _inherits(MarkContext, _React$Component);

  function MarkContext(props) {
    _classCallCheck(this, MarkContext);

    var _this = _possibleConstructorReturn(this, (MarkContext.__proto__ || Object.getPrototypeOf(MarkContext)).call(this, props));

    _this.mapElements = _this.mapElements.bind(_this);
    _this.shouldComponentUpdate = _this.shouldComponentUpdate.bind(_this);
    _this.updateContext = _this.updateContext.bind(_this);
    _this.state = { context: {} };
    return _this;
  }

  _createClass(MarkContext, [{
    key: "mapElements",
    value: function mapElements(element, ei) {
      if (!element) return null;

      var props = {
        key: "mc-mark-" + ei
      };

      if (typeof element.type !== "string") {
        props.context = this.state.context;
        props.updateContext = this.updateContext;
      }
      if (Array.isArray(element)) return element.map(this.mapElements);

      return _react2.default.cloneElement(element, props);
    }
  }, {
    key: "shouldComponentUpdate",
    value: function shouldComponentUpdate(nextProps) {
      if (this.props.xyFrameChildren && this.props.renderNumber === nextProps.renderNumber) {
        return false;
      }
      return true;
    }
  }, {
    key: "updateContext",
    value: function updateContext(prop, value) {
      var currentContext = this.state.context;
      currentContext[prop] = value;
      this.setState({ context: currentContext });
    }
  }, {
    key: "render",
    value: function render() {
      var elements = null;

      if (Array.isArray(this.props.children)) elements = this.props.children.map(this.mapElements);else if (_typeof(this.props.children) === "object") elements = this.mapElements(this.props.children);

      var transform = [0, 0];

      transform[0] = this.props.position ? this.props.position[0] : 0;
      transform[1] = this.props.position ? this.props.position[1] : 0;

      return _react2.default.createElement(
        "g",
        { transform: "translate(" + transform.toString() + ")" },
        elements
      );
    }
  }]);

  return MarkContext;
}(_react2.default.Component);

MarkContext.propTypes = {
  position: _propTypes2.default.array,
  xyFrameChildren: _propTypes2.default.bool,
  renderNumber: _propTypes2.default.number
};
exports.default = MarkContext;
module.exports = exports['default'];
});

unwrapExports(MarkContext_1);

var lib = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MarkContext = exports.Mark = exports.DraggableMark = undefined;



var _Mark2 = _interopRequireDefault(Mark_1);



var _DraggableMark2 = _interopRequireDefault(DraggableMark_1);



var _MarkContext2 = _interopRequireDefault(MarkContext_1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  DraggableMark: _DraggableMark2.default,
  Mark: _Mark2.default,
  MarkContext: _MarkContext2.default
};
exports.DraggableMark = _DraggableMark2.default;
exports.Mark = _Mark2.default;
exports.MarkContext = _MarkContext2.default;
});

unwrapExports(lib);
var lib_1 = lib.MarkContext;
var lib_2 = lib.Mark;
var lib_3 = lib.DraggableMark;

const SvgXYAnnotation = ({
  screenCoordinates,
  i,
  d
}) => {
  let inlineStyle;
  if (d.color) inlineStyle = {
    fill: d.color
  };
  const laLine = React$1.createElement(lib_2, {
    className: `annotation ${d.type} ${d.className || ''} `,
    key: `annotationpoint${i}`,
    markType: "circle",
    cx: screenCoordinates[0],
    cy: screenCoordinates[1],
    forceUpdate: true,
    style: inlineStyle,
    fill: "none",
    stroke: "black",
    r: 5
  });
  let laLabel;

  if (d.type === 'xy') {
    laLabel = React$1.createElement(lib_2, {
      markType: "text",
      key: `${d.label}annotationtext${i}`,
      forceUpdate: true,
      x: screenCoordinates[0],
      y: 10 + screenCoordinates[1],
      className: `annotation annotation-xy-label ${d.className || ''} `
    }, d.label);
  }

  return [laLine, laLabel];
};

const BasicReactAnnotation = ({
  screenCoordinates,
  d,
  i
}) => {
  const noteData = Object.assign({
    dx: 0,
    dy: 0,
    note: {
      label: d.label,
      orientation: d.orientation,
      align: d.align
    },
    connector: {
      end: 'arrow'
    }
  }, d, {
    type: d.type,
    screenCoordinates,
    i
  });
  noteData.x = noteData.fixedX ? noteData.fixedX : screenCoordinates[0];
  noteData.y = noteData.fixedY ? noteData.fixedY : screenCoordinates[1];
  return React$1.createElement(InternalAnnotation, {
    key: d.key || `annotation-${i}`,
    noteData: noteData
  });
};

const SvgEncloseAnnotation = ({
  screenCoordinates,
  d,
  i
}) => {
  const circle = packEnclose(screenCoordinates.map(p => ({
    x: p.x,
    y: p.y,
    r: 2
  })));
  const baseProps = {
    d,
    circle,
    i
  };
  return React$1__default.createElement(CircleEnclosure, baseProps);
};

const SvgRectEncloseAnnotation = ({
  d,
  i,
  screenCoordinates
}) => {
  const bboxNodes = screenCoordinates.map(p => {
    return {
      x0: p.x0 = p[0],
      x1: p.x1 = p[0],
      y0: p.y0 = p[1],
      y1: p.y1 = p[1]
    };
  });
  const baseProps = {
    bboxNodes,
    d,
    i
  };
  return React.createElement(RectangleEnclosure, baseProps);
};

const SvgHullEnclosure = ({
  screenCoordinates,
  d,
  i
}) => {
  return HullEnclosure({
    points: screenCoordinates,
    d,
    i
  });
};

var threshold$2 = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});



exports.default = function (_ref) {
  var x1 = _ref.x1,
      x2 = _ref.x2,
      y1 = _ref.y1,
      y2 = _ref.y2,
      x = _ref.x,
      y = _ref.y;

  x1 = (x1 !== undefined ? x1 : x) - x;
  x2 = (x2 !== undefined ? x2 : x) - x;
  y1 = (y1 !== undefined ? y1 : y) - y;
  y2 = (y2 !== undefined ? y2 : y) - y;

  var data = [[x1, y1], [x2, y2]];
  return { components: [(0, Builder.lineBuilder)({ data: data, className: "subject" })] };
};
});

unwrapExports(threshold$2);

var SubjectThreshold_1 = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireDefault(React$1__default);

var _threshold = _interopRequireDefault(threshold$2);

var _Subject2 = _interopRequireDefault(Subject_1);

var _propTypes = _interopRequireDefault(propTypes$1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var SubjectThreshold =
/*#__PURE__*/
function (_Subject) {
  _inherits(SubjectThreshold, _Subject);

  function SubjectThreshold() {
    var _getPrototypeOf2;

    var _this;

    _classCallCheck(this, SubjectThreshold);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(SubjectThreshold)).call.apply(_getPrototypeOf2, [this].concat(args)));

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "name", "SubjectThreshold");

    return _this;
  }

  _createClass(SubjectThreshold, [{
    key: "getComponents",
    value: function getComponents(_ref) {
      var x1 = _ref.x1,
          x2 = _ref.x2,
          y1 = _ref.y1,
          y2 = _ref.y2,
          x = _ref.x,
          y = _ref.y,
          editMode = _ref.editMode;
      return (0, _threshold.default)({
        x1: x1,
        x2: x2,
        y1: y1,
        y2: y2,
        x: x,
        y: y,
        editMode: editMode
      });
    }
  }]);

  return SubjectThreshold;
}(_Subject2.default);

exports.default = SubjectThreshold;
SubjectThreshold.propTypes = {
  x: _propTypes.default.number,
  x1: _propTypes.default.number,
  x2: _propTypes.default.number,
  y: _propTypes.default.number,
  y1: _propTypes.default.number,
  y2: _propTypes.default.number,
  editMode: _propTypes.default.bool
};
});

unwrapExports(SubjectThreshold_1);

var AnnotationXYThreshold_1 = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = AnnotationXYThreshold;

var _SubjectThreshold = _interopRequireDefault(SubjectThreshold_1);

var _ConnectorElbow = _interopRequireDefault(ConnectorElbow_1);

var _classnames = _interopRequireDefault(classnames);

var _Type = _interopRequireDefault(Type);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function AnnotationXYThreshold(props) {
  var className = (0, _classnames.default)("callout xythreshold", props.className);
  return (0, _Type.default)(_objectSpread({}, props, {
    className: className
  }), _ConnectorElbow.default, {
    lineType: "horizontal"
  }, _SubjectThreshold.default);
}
});

var AnnotationXYThreshold = unwrapExports(AnnotationXYThreshold_1);

const SvgXAnnotation = ({
  screenCoordinates,
  d,
  i,
  adjustedSize
}) => {
  const noteData = Object.assign({
    dx: 50,
    dy: 20,
    y: 0,
    note: {
      label: d.label
    },
    connector: {
      end: 'arrow'
    }
  }, d, {
    type: AnnotationXYThreshold,
    x: screenCoordinates[0],
    subject: {
      x: screenCoordinates[0],
      y1: 0,
      y2: adjustedSize[1]
    },
    i
  });
  return React$1.createElement(InternalAnnotation, {
    key: d.key || `annotation-${i}`,
    noteData: noteData
  });
};

const SvgYAnnotation = ({
  screenCoordinates,
  d,
  i,
  adjustedSize,
  adjustedPosition
}) => {
  const xPosition = i * 25;
  const noteData = Object.assign({
    dx: 50,
    dy: -20,
    x: xPosition,
    note: {
      label: d.label
    },
    connector: {
      end: 'arrow'
    }
  }, d, {
    type: AnnotationXYThreshold,
    y: screenCoordinates[1],
    subject: {
      y: screenCoordinates[1],
      x1: 0,
      x2: adjustedSize[0] + adjustedPosition[0]
    },
    i
  });
  return React$1.createElement(InternalAnnotation, {
    key: d.key || `annotation-${i}`,
    noteData: noteData
  });
};

const SvgLineAnnotation = ({
  d,
  i,
  screenCoordinates
}) => {
  const lineGenerator = line$1().x(p => p[0]).y(p => p[1]);
  const lineD = lineGenerator(screenCoordinates);
  const laLine = React$1.createElement(lib_2, {
    key: `${d.label}annotationline${i}`,
    markType: "path",
    d: lineD,
    className: `annotation annotation-line ${d.className || ''} `
  });
  const laLabel = React$1.createElement(lib_2, {
    markType: "text",
    key: `${d.label}annotationlinetext${i}`,
    x: (screenCoordinates[0][0] + screenCoordinates[1][0]) / 2,
    y: (screenCoordinates[0][1] + screenCoordinates[1][1]) / 2,
    className: `annotation annotation-line-label ${d.className || ''} `
  }, d.label);
  return [laLine, laLabel];
};

const findFirstAccessorValue = (accessorArray, data) => {
  for (let i = 0; i < accessorArray.length; i++) {
    const valueCheck = accessorArray[i](data);
    if (valueCheck !== undefined && !Number.isNaN(valueCheck) && valueCheck !== null) return valueCheck;
  }

  return undefined;
};

const SvgBoundsAnnotation = ({
  d,
  i,
  adjustedSize,
  xScale,
  yScale,
  screenCoordinates,
  xAccessors,
  yAccessors
}) => {
  const startXValue = findFirstAccessorValue(xAccessors, d.bounds[0]);
  const startYValue = findFirstAccessorValue(yAccessors, d.bounds[0]);
  const endXValue = findFirstAccessorValue(xAccessors, d.bounds[1]);
  const endYValue = findFirstAccessorValue(yAccessors, d.bounds[1]);
  const x0Position = startXValue ? xScale(startXValue) : 0;
  const y0Position = startYValue ? yScale(startYValue) : adjustedSize[1];
  const x1Position = endXValue ? xScale(endXValue) : adjustedSize[0];
  const y1Position = endYValue ? yScale(endYValue) : 0;
  const noteData = Object.assign({
    dx: 250,
    dy: -20,
    note: {
      label: d.label
    },
    connector: {
      end: 'arrow'
    }
  }, d, {
    type: AnnotationCalloutRect,
    x: Math.min(x0Position, x1Position),
    y: Math.min(y0Position, y1Position),
    subject: {
      width: Math.abs(x1Position - x0Position),
      height: Math.abs(y0Position - y1Position)
    },
    i
  });
  return React$1__default.createElement(InternalAnnotation, {
    key: d.key || `annotation-${i}`,
    noteData: noteData
  });
};

const SvgAreaAnnotation = ({
  d,
  i,
  xScale,
  yScale,
  xAccessors,
  yAccessors,
  annotationLayer
}) => {
  const mappedCoordinates = `M${d.coordinates.map(p => [xScale(findFirstAccessorValue(xAccessors, p)), yScale(findFirstAccessorValue(yAccessors, p))]).join('L')}Z`;
  const xBounds = extent(d.coordinates.map(p => xScale(findFirstAccessorValue(xAccessors, p))));
  const yBounds = extent(d.coordinates.map(p => yScale(findFirstAccessorValue(yAccessors, p))));
  const xCenter = (xBounds[0] + xBounds[1]) / 2;
  const yCenter = (yBounds[0] + yBounds[1]) / 2;
  const laLine = React$1__default.createElement(lib_2, {
    key: `${d.label}-annotation-area-${i}`,
    markType: "path",
    d: mappedCoordinates,
    className: `annotation annotation-area ${d.className || ''} `
  });
  const laLabel = React$1__default.createElement(lib_2, {
    markType: "text",
    key: `${d.label}-annotationtext-${i}`,
    forceUpdate: true,
    x: xCenter,
    y: yCenter,
    transform: `translate(${annotationLayer.position})`,
    className: `annotation annotation-area-label ${d.className || ''} `,
    style: {
      textAnchor: 'middle'
    }
  }, d.label);
  return [laLine, laLabel];
};

const findPoints = (d, xScale, yScale) => {
  const {
    points,
    style
  } = d;
  return points.filter(e => e.x === d.x && e.y === d.y).map((p, q) => {
    const baseStyle = style({ ...p
    });
    const highlightStyle = typeof style === 'function' ? style({ ...p,
      ...p.data
    }, q) : style || {};
    return React$1__default.createElement("circle", {
      key: `highlight-point-${q}`,
      cx: xScale(p.x),
      cy: yScale(p.y),
      r: 5,
      fill: "none",
      stroke: "black",
      strokeWidth: 2,
      style: { ...baseStyle,
        ...highlightStyle
      },
      className: `highlight-annotation ${d.class && typeof d.class === 'function' && d.class({ ...p,
        ...p.data
      }, q) || d.class && d.class || ''}`
    });
  });
};

const SvgHighlight = ({
  d,
  i,
  xScale,
  yScale,
  xyFrameRender
}) => {
  const foundPoints = findPoints(d, xScale, yScale);
  const foundLines = lines.data.filter((p, q) => idAccessor(p, q) === dID).map((p, q) => {
    const baseStyle = xyFrameRender.lines.styleFn(p, q);
    const highlightStyle = typeof d.style === 'function' ? d.style(p, q) : d.style || {};
    return React$1__default.createElement("path", {
      className: `highlight-annotation ${d.class && typeof d.class === 'function' && d.class(p, q) || d.class && d.class || ''}`,
      key: `highlight-summary-${q}`,
      d: lineGenerator(p.data),
      fill: "none",
      stroke: "black",
      strokeWidth: 1,
      style: { ...baseStyle,
        ...highlightStyle
      }
    });
  });
  const foundAreas = summaries.data.filter((p, q) => idAccessor(p, q) === dID).map((p, q) => {
    const baseStyle = xyFrameRender.summaries.styleFn(p, q);
    const highlightStyle = typeof d.style === 'function' ? d.style(p, q) : d.style || {};
    return React$1__default.createElement("path", {
      className: `highlight-annotation ${d.class && typeof d.class === 'function' && d.class(p, q) || d.class && d.class || ''}`,
      key: `highlight-summary-${q}`,
      d: `M${p.coordinates.join('L')}`,
      fill: "none",
      stroke: "black",
      strokeWidth: 1,
      style: { ...baseStyle,
        ...highlightStyle
      }
    });
  });
  return [...foundAreas, ...foundLines, ...foundPoints];
};

const PointsAlong = along => ({
  d,
  lines,
  points,
  xScale,
  yScale,
  pointStyle
}) => {
  const alongScale = along === 'x' ? xScale : yScale;
  along = along === 'yTop' && d.yMiddle ? 'yMiddle' : along;

  if (d && d[along]) {
    const {
      threshold = 1,
      r = () => 4,
      styleFn = pointStyle
    } = d;
    const foundPoints = [];
    const halfThreshold = threshold / 2;

    if (lines && lines.length > 0) {
      lines.forEach(linedata => {
        const linePoints = linedata.data.filter(p => {
          const pAlong = alongScale(p[along]);
          const dAlong = alongScale(d[along]);
          return pAlong <= dAlong + halfThreshold && pAlong >= dAlong - halfThreshold;
        });
        foundPoints.push(...linePoints);
      });
    }

    if (points && points.length > 0) {
      const pointPoints = points.filter(p => {
        const pAlong = alongScale(p[along]);
        const dAlong = alongScale(d[along]);
        return pAlong <= dAlong + halfThreshold && pAlong >= dAlong - halfThreshold;
      });
      foundPoints.push(...pointPoints);
    }

    return foundPoints.map((p, i) => React$1.createElement("circle", {
      key: `found-circle-${i}`,
      r: r(p, i),
      style: styleFn(p, i),
      cx: xScale(p.xMiddle || p.x),
      cy: yScale(p.yMiddle || p.yTop)
    }));
  }

  return null;
};

const SvgHorizontalPointsAnnotation = PointsAlong('yTop');
const SvgVerticalPointsAnnotation = PointsAlong('x');

const TypeHash = {
  'desaturation-layer': DesaturationLayer,
  xy: SvgXYAnnotation,
  'frame-hover': SvgXYAnnotation,
  'react-annotation': BasicReactAnnotation,
  function: BasicReactAnnotation,
  enclose: SvgEncloseAnnotation,
  'enclose-rect': SvgRectEncloseAnnotation,
  'enclose-hull': SvgHullEnclosure,
  x: SvgXAnnotation,
  y: SvgYAnnotation,
  bounds: SvgBoundsAnnotation,
  line: SvgLineAnnotation,
  area: SvgAreaAnnotation,
  'horizontal-points': SvgHorizontalPointsAnnotation,
  'vertical-points': SvgVerticalPointsAnnotation,
  highlight: SvgHighlight
};

const generateXYSVGAnnotations = ({
  frameProps,
  frameData
}) => ({
  d,
  i
}) => {
  let screenCoordinates = [];
  const {
    plotChildren
  } = frameProps;
  const {
    frameXScale: xScale,
    frameYScale: yScale,
    adjustedSize
  } = frameData;
  const xAccessors = plotChildren.map(d => d.props.xAccessor);
  const yAccessors = plotChildren.map(d => d.props.yAccessor);

  if (d.coordinates) {
    if (!Array.isArray(d.coordinates)) {
      const xData = findFirstAccessorValue(xAccessors, d.coordinates);
      const yData = findFirstAccessorValue(yAccessors, d.coordinates);

      if (xData) {
        screenCoordinates[0] = xScale(xData);
      }

      screenCoordinates[1] = yData ? yScale(yData) : adjustedSize[1];
    } else {
      screenCoordinates = d.coordinates.map(e => {
        const xData = findFirstAccessorValue(xAccessors, e);
        const yData = findFirstAccessorValue(yAccessors, e);
        return {
          x: xData ? xScale(xData) : null,
          y: yData ? yScale(yData) : null
        };
      });
    }
  } else {
    screenCoordinates = d.screenCoordinates || [d.x ? d.x : 0, d.y ? adjustedSize[1] - d.y : adjustedSize[1]];
  }

  const widgetProps = { ...d,
    d,
    i,
    x: screenCoordinates[0],
    y: screenCoordinates[1],
    screenCoordinates,
    xAccessors,
    yAccessors,
    xScale,
    yScale,
    adjustedSize,
    adjustedPosition: frameData.adjustedPosition
  };
  const AnnotationType = TypeHash[d.type] || d.type;
  return AnnotationType ? React$1__default.createElement(AnnotationType, widgetProps) : null;
};

const generateXYHtmlAnnotations = ({
  frameProps,
  frameData
}) => ({
  d,
  i,
  voronoiHover
}) => {
  const {
    tooltipContent
  } = frameProps;
  const {
    screenCoordinates
  } = frameData;
  return tooltipContent ? screenCoordinates.filter(e => {
    if (voronoiHover) {
      const hoverObj = Array.isArray(voronoiHover) && voronoiHover.length > 0 ? voronoiHover[0] : Object.assign({}, voronoiHover);

      if (hoverObj.hasOwnProperty('x') && hoverObj.hasOwnProperty('y')) {
        if (typeof hoverObj.x.getMonth === 'function') {
          // is date
          return hoverObj.x.toISOString() === e.x.toISOString() && hoverObj.y === e.y;
        } else {
          return hoverObj.x === e.x && hoverObj.y === e.y;
        }
      } else {
        return false;
      }
    }

    return false;
  }).map((d, i) => {
    const _data = { ...d,
      x: frameXScale(d.x),
      y: frameYScale(d.y)
    };
    return React$1__default.createElement(HTMLTooltipAnnotation, {
      tooltipContent: tooltipContent,
      tooltipContentArgs: _data,
      i: i,
      d: _data,
      useSpans: useSpans
    });
  }) : [];
};

var bracket = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});



//This curly brace function was
//made by Alex Hornbake
//http://bl.ocks.org/alexhornbake/6005176
function makeCurlyBrace(x1, y1, x2, y2, w, q) {
  //Calculate unit vector
  var dx = x1 - x2;
  var dy = y1 - y2;
  var len = Math.sqrt(dx * dx + dy * dy);
  dx = dx / len;
  dy = dy / len;

  //Calculate Control Points of path,
  var qx1 = x1 + q * w * dy;
  var qy1 = y1 - q * w * dx;
  var qx2 = x1 - 0.25 * len * dx + (1 - q) * w * dy;
  var qy2 = y1 - 0.25 * len * dy - (1 - q) * w * dx;
  var tx1 = x1 - 0.5 * len * dx + w * dy;
  var ty1 = y1 - 0.5 * len * dy - w * dx;
  var qx3 = x2 + q * w * dy;
  var qy3 = y2 - q * w * dx;
  var qx4 = x1 - 0.75 * len * dx + (1 - q) * w * dy;
  var qy4 = y1 - 0.75 * len * dy - (1 - q) * w * dx;

  return "M " + x1 + " " + y1 + " Q " + qx1 + " " + qy1 + " " + qx2 + " " + qy2 + " T " + tx1 + " " + ty1 + " M " + x2 + " " + y2 + " Q " + qx3 + " " + qy3 + " " + qx4 + " " + qy4 + " T " + tx1 + " " + ty1;
}

exports.default = function (_ref) {
  var height = _ref.height,
      width = _ref.width,
      depth = _ref.depth,
      type = _ref.type,
      editMode = _ref.editMode;

  var handles = [];
  var data = void 0;
  var bracket = void 0;

  var w = 0,
      h = 0;

  if (height && height > 0) {
    h = height;
  } else if (width && width > 0) {
    w = width;
  }

  if (type === "square") {
    if (h) {
      data = [[0, 0], [depth, 0], [depth, h], [0, h]];
    } else if (w) {
      data = [[0, 0], [0, depth], [w, depth], [w, 0]];
    }
    bracket = (0, Builder.lineBuilder)({ data: data, className: "subject" });
  } else if (type === "curly") {
    bracket = (0, Builder.pathBuilder)({
      d: makeCurlyBrace(0, 0, w, h, h > 0 || w < 0 ? -depth : depth, 0.55),
      className: "subject"
    });
  }

  if (editMode) {
    handles = [{
      x: h ? depth : w / 2,
      y: h ? h / 2 : depth,
      key: "depth",
      type: h ? "X" : "Y"
    }, {
      x: w || 0,
      y: h || 0,
      key: h ? "height" : "width"
    }];
  }

  bracket.attrs["fill-opacity"] = 0.1;
  return { components: [bracket], handles: handles };
};
});

unwrapExports(bracket);

var SubjectBracket_1 = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireDefault(React$1__default);

var _bracket = _interopRequireDefault(bracket);

var _Subject2 = _interopRequireDefault(Subject_1);

var _propTypes = _interopRequireDefault(propTypes$1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var SubjectBracket =
/*#__PURE__*/
function (_Subject) {
  _inherits(SubjectBracket, _Subject);

  function SubjectBracket() {
    var _getPrototypeOf2;

    var _this;

    _classCallCheck(this, SubjectBracket);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(SubjectBracket)).call.apply(_getPrototypeOf2, [this].concat(args)));

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "name", "SubjectBracket");

    return _this;
  }

  _createClass(SubjectBracket, [{
    key: "getComponents",
    value: function getComponents(_ref) {
      var height = _ref.height,
          width = _ref.width,
          _ref$depth = _ref.depth,
          depth = _ref$depth === void 0 ? 20 : _ref$depth,
          _ref$type = _ref.type,
          type = _ref$type === void 0 ? "square" : _ref$type,
          editMode = _ref.editMode;
      var components = (0, _bracket.default)({
        height: height,
        width: width,
        depth: depth,
        type: type,
        editMode: editMode
      });
      var handleKeys = {
        height: height,
        width: width,
        depth: depth
      };

      components.handleFunction = function (h, data) {
        if (h.key === "depth") {
          return {
            depth: depth + data["oDelta".concat(h.type)]
          };
        } else {
          return _defineProperty({}, h.key, handleKeys[h.key] + data[h.key === "width" ? "oDeltaX" : "oDeltaY"]);
        }
      };

      return components;
    }
  }]);

  return SubjectBracket;
}(_Subject2.default);

exports.default = SubjectBracket;
SubjectBracket.propTypes = {
  width: _propTypes.default.number,
  height: _propTypes.default.number,
  depth: _propTypes.default.number,
  editMode: _propTypes.default.bool
};
});

unwrapExports(SubjectBracket_1);

var BracketNote_1 = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = BracketNote;

var _react = _interopRequireDefault(React$1__default);

var _Note = _interopRequireDefault(Note_1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function BracketNote(_ref) {
  var width = _ref.width,
      height = _ref.height,
      depth = _ref.depth,
      rest = _objectWithoutProperties(_ref, ["width", "height", "depth"]);

  var dx = rest.dx,
      orientation,
      align = "middle",
      dy = rest.dy;

  if (height) {
    if (!dy) dy = height / 2;
    if (!dx) dx = depth;
    orientation = "leftRight";
  } else if (width) {
    if (!dx) dx = width / 2;
    if (!dy) dy = depth;
    orientation = "topBottom";
  }

  return _react.default.createElement(_Note.default, _extends({
    align: align,
    orientation: orientation,
    padding: 10
  }, rest, {
    editMode: false,
    dx: dx,
    dy: dy
  }));
}
});

unwrapExports(BracketNote_1);

var AnnotationBracket_1 = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = AnnotationBracket;

var _SubjectBracket = _interopRequireDefault(SubjectBracket_1);

var _BracketNote = _interopRequireDefault(BracketNote_1);

var _classnames = _interopRequireDefault(classnames);

var _Type = _interopRequireDefault(Type);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function AnnotationBracket(props) {
  var className = (0, _classnames.default)("bracket", props.className);
  return (0, _Type.default)(_objectSpread({}, props, {
    disable: ["connector"],
    className: className
  }), null, null, _SubjectBracket.default, {
    depth: 20
  }, _BracketNote.default);
}
});

var AnnotationBracket = unwrapExports(AnnotationBracket_1);

const pointOnArcAtAngle = (center, angle, distance) => {
  const radians = Math.PI * (angle + 0.75) * 2;
  const xPosition = center[0] + distance * Math.cos(radians);
  const yPosition = center[1] + distance * Math.sin(radians);
  return [xPosition, yPosition];
};

const clonedAppliedElement = ({
  tx,
  ty,
  d,
  i,
  markProps,
  styleFn,
  renderFn,
  classFn,
  renderKeyFn,
  baseClass,
  yi
}) => {
  markProps.style = styleFn ? styleFn(d, i, yi) : {};
  markProps.className = baseClass;
  markProps.key = renderKeyFn ? renderKeyFn(d, i, yi) : `${baseClass}-${d.key === undefined ? i : d.key}`;

  if (tx || ty) {
    markProps.transform = `translate(${tx || 0},${ty || 0})`;
  }

  if (classFn) {
    markProps.className = `${baseClass} ${classFn(d, i, yi)}`;
  }

  if (!markProps.markType) {
    const RenderableMark = markProps;
    return React$1__default.createElement(RenderableMark);
  }

  markProps.renderMode = renderFn ? renderFn(d, i, yi) : undefined;
  return React$1__default.createElement(lib_2, markProps);
};

const projectedX = 'x';
const projectedY = 'y';
const projectedYMiddle = 'yMiddle';
const projectedYTop = 'yTop';
const projectedYBottom = 'yBottom';
const projectedXMiddle = 'xMiddle';

const curveHash = {
  step: curveStep,
  stepbefore: stepBefore$1,
  stepafter: stepAfter$1,
  cardinal: curveCardinal,
  basis: curveBasis,
  linear: curveLinear$1,
  catmullrom: curveCatmullRom,
  monotone: monotoneY$1,
  monotonex: monotoneX$1,
  monotoney: monotoneY$1,
  natural: curveNatural
};
function lineGeneratorDecorator({
  generator,
  defined,
  xScale,
  yScale,
  interpolator,
  simpleLine
}) {
  const x = projectedX;
  const y = projectedY;
  const yTop = projectedYTop;
  const yBottom = projectedYBottom;
  generator.x(d => xScale(d[x])).curve(interpolator);

  if (simpleLine) {
    generator.y(d => yScale(d[y]));
  } else {
    generator.y0(d => yScale(d[yBottom])).y1(d => yScale(d[yTop]));
  }

  if (defined) {
    generator.defined((p, q) => defined(p, q));
  } else {
    generator.defined(p => !p._xyFrameUndefined);
  }
}

const toRenderedLines = ({
  xScale,
  yScale,
  data,
  customMark,
  useCanvas,
  styleFn,
  classFn,
  renderMode,
  renderKeyFn,
  type,
  defined,
  baseMarkProps = {},
  ariaLabel,
  axesData = []
}) => {
  const canvasPipeline = [];
  const svgPipeline = [];
  const xAxis = axesData.find(d => d.orient === 'bottom' || d.orient === 'top');
  const yAxis = axesData.find(d => d.orient === 'left' || d.orient === 'right');

  const xAxisFormatter = xAxis && xAxis.tickFormat || (d => d);

  const yAxisFormatter = yAxis && yAxis.tickFormat || (d => d);

  const customLine = typeof type === 'object' ? type : {
    type
  };
  const interpolator = typeof customLine.interpolator === 'string' ? curveHash[customLine.interpolator] : customLine.interpolator || curveLinear$1;

  if (customLine.type === 'area' || customLine.type === 'stackedarea') {
    customLine.simpleLine = false;
  }

  const lineGenerator = customLine.simpleLine ? line$1() : area$1();
  lineGeneratorDecorator({
    defined,
    interpolator,
    generator: lineGenerator,
    xScale,
    yScale,
    simpleLine: customLine.simpleLine
  });

  const dynamicLineGenerator = interpolator.dynamicInterpolator && ((d, i) => {
    const dynLineGenerator = area$1();
    lineGeneratorDecorator({
      defined,
      interpolator: interpolator.dynamicInterpolator(d, i),
      generator: dynLineGenerator,
      xScale,
      yScale,
      simpleLine: customLine.simpleLine
    });
    return dynLineGenerator;
  }) || (() => lineGenerator);

  data.forEach((d, i) => {
    if (customMark && typeof customMark === 'function') {
      //shim to make customLineMark work until Semiotic 2
      const compatibleData = { ...d,
        data: d.data.map(p => ({ ...p.data,
          ...p
        }))
      };
      svgPipeline.push(customMark({
        d: compatibleData,
        i,
        xScale,
        yScale,
        canvasPipeline
      }));
    } else {
      const builtInDisplayProps = {};

      if (customLine.simpleLine) {
        builtInDisplayProps.fill = 'none';
        builtInDisplayProps.stroke = 'black';
      }

      let pathString = dynamicLineGenerator(d, i)(d._xyCoordinates.map(p => Object.assign({}, p.data, p)));

      if (pathString && (!customLine.interpolator || interpolator === curveLinear$1)) {
        //FIX FOR CHROME STRAIGHT LINE BUG
        const splitPath = pathString.split('L').map(d => d.split(','));

        if (splitPath.length > 1) {
          splitPath[0][1] = parseFloat(splitPath[0][1]).toFixed(2);
        }

        pathString = splitPath.map(d => d.join(',')).join('L');
      }

      const _baseMarkProps = Object.assign(baseMarkProps, {
        'aria-label': ariaLabel && ariaLabel.items || 'dataviz-element',
        role: 'img',
        tabIndex: -1
      });

      const markProps = { ...builtInDisplayProps,
        ..._baseMarkProps,
        markType: 'path',
        d: pathString,
        'aria-label': d._xyCoordinates && d._xyCoordinates.length > 0 && `${d._xyCoordinates.length} point ${ariaLabel.items} starting value ${yAxisFormatter(d._xyCoordinates[0].y)} at ${xAxisFormatter(d._xyCoordinates[0].x)} ending value ${yAxisFormatter(d._xyCoordinates[d._xyCoordinates.length - 1].y)} at ${xAxisFormatter(d._xyCoordinates[d._xyCoordinates.length - 1].x)}`
      };

      if (useCanvas === true) {
        const canvasLine = {
          type: 'line',
          baseClass: 'xyframe-line',
          tx: 0,
          ty: 0,
          d,
          i,
          markProps,
          styleFn,
          renderFn: renderMode,
          classFn
        };
        canvasPipeline.push(canvasLine);
      } else {
        svgPipeline.push(clonedAppliedElement({
          baseClass: 'xyframe-line',
          d,
          i,
          markProps,
          styleFn,
          renderFn: renderMode,
          renderKeyFn,
          classFn
        }));
      }
    }
  });

  if (customLine.type === 'difference' && data.length >= 2) {
    //Create the overlay line for the difference chart
    const diffdataA = data[0]._xyCoordinates.map((basedata, baseI) => {
      const linePoint = basedata.yTop > data[1]._xyCoordinates[baseI].yTop ? basedata.yTop : basedata.yBottom;
      return {
        x: basedata.x,
        y: linePoint,
        yBottom: linePoint,
        yTop: linePoint
      };
    });

    const diffdataB = data[0]._xyCoordinates.map((basedata, baseI) => {
      const linePoint = data[1]._xyCoordinates[baseI].yTop > basedata.yTop ? data[1]._xyCoordinates[baseI].yTop : data[1]._xyCoordinates[baseI].yBottom;
      return {
        x: basedata.x,
        y: linePoint,
        yBottom: linePoint,
        yTop: linePoint
      };
    });

    const doClassname = classFn ? `xyframe-line ${classFn(diffdataA)}` : 'xyframe-line';
    const overLine = line$1();
    lineGeneratorDecorator({
      defined,
      interpolator,
      generator: overLine,
      xScale,
      yScale,
      simpleLine: true
    }); //      let baseStyle = props.lineStyle ? props.lineStyle(diffdata, 0) : {}

    const diffOverlayA = React$1__default.createElement(lib_2, {
      key: 'xyline-diff-a',
      className: `${doClassname} difference-overlay-a`,
      markType: "path",
      d: overLine(diffdataA),
      style: {
        fill: 'none',
        pointerEvents: 'none'
      }
    });
    svgPipeline.push(diffOverlayA);
    const diffOverlayB = React$1__default.createElement(lib_2, {
      key: 'xyline-diff-b',
      className: `${doClassname} difference-overlay-b`,
      markType: "path",
      d: overLine(diffdataB),
      style: {
        fill: 'none',
        pointerEvents: 'none'
      }
    });
    svgPipeline.push(diffOverlayB);
  }

  return {
    svgPipeline,
    canvasPipeline
  };
};

const TooltipPositioner = props => {
  const containerRef = React$1.useRef();
  const {
    tooltipContent,
    tooltipContentArgs
  } = props;
  let offset = null;
  let tooltipContainerInitialDimensions = {}; // simple heuristics to check if the tooltip container exceeds the viewport
  // if so, capture the suggested offset

  if (containerRef && containerRef.current) {
    offset = {
      x: 0,
      y: 0
    };
    tooltipContainerInitialDimensions = containerRef.current.getBoundingClientRect();
    const {
      right,
      left,
      top,
      bottom
    } = tooltipContainerInitialDimensions;
    const containerWidth = right - left;
    const containerHeight = bottom - top;

    if (right > window.innerWidth) {
      offset.x = -containerWidth;
    } else if (left < 0) {
      offset.x = containerWidth;
    }

    if (bottom > window.innerHeight) {
      offset.y = -containerHeight;
    } else if (top < 0) {
      offset.y = containerHeight;
    }
  }

  const containerStyle = offset ? {
    transform: `translate(${offset.x}px,${offset.y}px)`
  } : {
    opacity: 0
  };
  const tooltipContainerAttributes = {
    offset: offset || {
      x: 0,
      y: 0
    },
    tooltipContainerInitialDimensions
  };
  return React$1__default.createElement("div", {
    ref: containerRef,
    style: containerStyle
  }, tooltipContent({ ...tooltipContentArgs,
    tooltipContainerAttributes
  }));
};

TooltipPositioner.propTypes = {
  tooltipContent: propTypes.func,
  tooltipContentArgs: propTypes.object
};

function polarToCartesian(centerX, centerY, radius, angleInDegrees) {
  const angleInRadians = (angleInDegrees - 90) * Math.PI / 180.0;
  return {
    x: centerX + radius * Math.cos(angleInRadians),
    y: centerY + radius * Math.sin(angleInRadians)
  };
}

function pieContentGenerator({
  column,
  useSpans
}) {
  return React$1.createElement(SpanOrDiv, {
    span: useSpans,
    className: "tooltip-content"
  }, React$1.createElement("p", {
    key: "or-annotation-1"
  }, column.name), React$1.createElement("p", {
    key: "or-annotation-2"
  }, `${(column.pct * 100).toFixed(0)}%`));
}

function arcBracket({
  x,
  y,
  radius,
  startAngle,
  endAngle,
  inset,
  outset,
  curly = true
}) {
  const start = polarToCartesian(x, y, radius + outset, endAngle);
  const end = polarToCartesian(x, y, radius + outset, startAngle);
  const innerStart = polarToCartesian(x, y, radius + outset - inset, endAngle);
  const innerEnd = polarToCartesian(x, y, radius + outset - inset, startAngle);
  const angleSize = endAngle - startAngle;
  const largeArcFlag = angleSize <= 180 ? '0' : '1';
  let d;

  if (curly) {
    const curlyOffset = Math.min(10, angleSize / 4);
    const middleLeft = polarToCartesian(x, y, radius + outset, (startAngle + endAngle) / 2 + curlyOffset);
    const middle = polarToCartesian(x, y, radius + outset + 10, (startAngle + endAngle) / 2);
    const middleRight = polarToCartesian(x, y, radius + outset, (startAngle + endAngle) / 2 - curlyOffset);
    d = ['M', innerStart.x, innerStart.y, 'L', start.x, start.y, 'A', radius + outset, radius + outset, 0, 0, 0, middleLeft.x, middleLeft.y, 'A', radius + outset, radius + outset, 1, 0, 1, middle.x, middle.y, 'A', radius + outset, radius + outset, 1, 0, 1, middleRight.x, middleRight.y, 'A', radius + outset, radius + outset, 0, 0, 0, end.x, end.y, 'L', innerEnd.x, innerEnd.y].join(' ');
  } else {
    d = ['M', innerStart.x, innerStart.y, 'L', start.x, start.y, 'A', radius + outset, radius + outset, 0, largeArcFlag, 0, end.x, end.y, 'L', innerEnd.x, innerEnd.y].join(' ');
  }

  const midAngle = (startAngle + endAngle) / 2;
  let textOffset, largeTextArcFlag, finalTextEnd, finalTextStart, arcFlip;
  const lowerArc = midAngle > 90 && midAngle < 270;

  if (lowerArc) {
    textOffset = 12;
    largeTextArcFlag = endAngle - startAngle <= 180 ? '0' : '1';
    arcFlip = 0;
  } else {
    largeTextArcFlag = endAngle - startAngle <= 180 ? '0' : '1';
    textOffset = 5;
    arcFlip = 1;
  }

  textOffset += curly ? 10 : 0;
  const textStart = polarToCartesian(x, y, radius + outset + textOffset, endAngle);
  const textEnd = polarToCartesian(x, y, radius + outset + textOffset, startAngle);

  if (lowerArc) {
    finalTextStart = textStart;
    finalTextEnd = textEnd;
  } else {
    finalTextStart = textEnd;
    finalTextEnd = textStart;
  }

  const textD = ['M', finalTextStart.x, finalTextStart.y, 'A', radius + outset + textOffset, radius + outset + textOffset, arcFlip, largeTextArcFlag, arcFlip, finalTextEnd.x, finalTextEnd.y].join(' ');
  return {
    arcPath: d,
    textArcPath: textD
  };
}

const getColumnScreenCoordinates = ({
  d,
  projectedColumns,
  oAccessor,
  summaryType,
  type,
  projection,
  adjustedPosition,
  adjustedSize
}) => {
  const column = d.column || projectedColumns[d.facetColumn] || projectedColumns[findFirstAccessorValue(oAccessor, d)];

  if (!column) {
    return {
      coordinates: [0, 0],
      pieces: undefined,
      column: undefined
    };
  }

  const pieces = column.pieceData || column.pieces;
  const positionValue = summaryType.type && summaryType.type !== 'none' || ['swarm', 'ordinalpoint', 'clusterbar'].find(p => p === type.type) ? max(pieces.map(p => p.scaledValue)) : projection === 'horizontal' ? max(pieces.map(p => p.value >= 0 ? p.scaledValue + p.bottom : p.bottom)) : min(pieces.map(p => p.value >= 0 ? p.bottom - p.scaledValue : p.bottom));
  let xPosition = column.middle + adjustedPosition[0];
  let yPosition = projection === 'horizontal' ? adjustedSize[0] - positionValue : summaryType.type && summaryType.type !== 'none' || ['swarm', 'ordinalpoint', 'clusterbar'].find(p => p === type.type) ? adjustedSize[1] - positionValue : positionValue;
  yPosition += 10;

  if (projection === 'horizontal') {
    yPosition = column.middle;
    xPosition = positionValue + adjustedPosition[0];
  } else if (projection === 'radial') {
    [xPosition, yPosition] = pointOnArcAtAngle([d.arcAngles.translate[0], d.arcAngles.translate[1]], d.arcAngles.midAngle, d.arcAngles.length);
    yPosition += 10;
  }

  return {
    coordinates: [xPosition, yPosition],
    pieces,
    column
  };
};
const svgHighlightRule$1 = ({
  d,
  pieceIDAccessor,
  orFrameRender,
  oAccessor
}) => {
  const thisID = pieceIDAccessor(d);
  const thisO = findFirstAccessorValue(oAccessor, d);
  const {
    pieces
  } = orFrameRender;
  const {
    styleFn
  } = pieces;
  const foundPieces = pieces && pieces.data.filter(p => {
    return (thisID === undefined || pieceIDAccessor({ ...p.piece,
      ...p.piece.data
    }) === thisID) && (thisO === undefined || findFirstAccessorValue(oAccessor, p.piece.data) === thisO);
  }).map((p, q) => {
    let styleObject = {
      style: styleFn({ ...p.piece,
        ...p.piece.data
      })
    };

    if (d.style && typeof d.style === 'function') {
      styleObject = {
        style: { ...styleObject,
          ...d.style({ ...p.piece,
            ...p.piece.data
          })
        }
      };
    } else if (d.style) {
      styleObject = {
        style: { ...styleObject,
          ...d.style
        }
      };
    }

    const styledD = { ...p.renderElement,
      ...styleObject
    };
    const className = `highlight-annotation ${d.class && typeof d.class === 'function' && d.class(p.piece.data, q) || d.class && d.class || ''}`;

    if (React$1.isValidElement(p.renderElement)) {
      return React$1.cloneElement(p.renderElement, { ...styleObject,
        className
      });
    }

    return React$1.createElement(lib_2, _extends({
      fill: "none",
      stroke: "black",
      strokeWidth: "2px",
      key: `highlight-piece-${q}`
    }, styledD, {
      className: className
    }));
  }) || [];
  return [...foundPieces];
};
const findIDPiece = (pieceIDAccessor, oColumn, d) => {
  const foundIDValue = pieceIDAccessor(d);
  const pieceID = foundIDValue === '' && d.rName ? d.rName : foundIDValue;
  const basePieces = oColumn && oColumn.pieceData.filter(r => r.rName === pieceID || pieceIDAccessor(r.data) === pieceID);
  if (pieceID === '' || basePieces === undefined || basePieces === false || basePieces.length !== 1) return d;
  const basePiece = basePieces[0];
  const reactAnnotationProps = ['type', 'label', 'note', 'connector', 'disabled', 'color', 'subject'];

  if (basePiece) {
    reactAnnotationProps.forEach(prop => {
      if (d[prop]) basePiece[prop] = d[prop];
    });
  }

  return basePiece;
};
const screenProject = ({
  p,
  adjustedSize,
  rScale,
  oColumn,
  rAccessor,
  idPiece,
  projection,
  rScaleType
}) => {
  const pValue = findFirstAccessorValue(rAccessor, p) || p.value;
  let o;

  if (oColumn) {
    o = oColumn.middle;
  } else {
    o = 0;
  }

  if (oColumn && projection === 'radial') {
    return pointOnArcAtAngle([adjustedSize[0] / 2, adjustedSize[1] / 2], oColumn.pct_middle, idPiece && (idPiece.x || idPiece.scaledValue) ? idPiece.x / 2 || (idPiece.bottom + idPiece.scaledValue / 2) / 2 : pValue / 2);
  }

  if (projection === 'horizontal') {
    return [idPiece && (idPiece.x || idPiece.scaledValue) ? idPiece.x === undefined ? idPiece.x : idPiece.value >= 0 ? idPiece.bottom + idPiece.scaledValue / 2 : idPiece.bottom : rScale(pValue), o];
  }

  const newScale = rScaleType.copy().domain(rScale.domain()).range(rScale.range().reverse());
  return [o, idPiece && (idPiece.x || idPiece.scaledValue) ? idPiece.y === undefined ? idPiece.value >= 0 ? idPiece.bottom - idPiece.scaledValue : idPiece.bottom : idPiece.y : newScale(pValue)];
};
const svgORRule = ({
  d,
  i,
  screenCoordinates,
  projection
}) => {
  return React$1.createElement(lib_2, {
    markType: "text",
    key: `${d.label}annotationtext${i}`,
    forceUpdate: true,
    x: screenCoordinates[0] + (projection === 'horizontal' ? 10 : 0),
    y: screenCoordinates[1] + (projection === 'vertical' ? 10 : 0),
    className: `annotation annotation-or-label ${d.className || ''}`,
    textAnchor: "middle"
  }, d.label);
};
const basicReactAnnotationRule = ({
  d,
  i,
  screenCoordinates
}) => {
  const noteData = Object.assign({
    dx: 0,
    dy: 0,
    note: {
      label: d.label,
      orientation: d.orientation,
      align: d.align
    },
    connector: {
      end: 'arrow'
    }
  }, d, {
    x: screenCoordinates[0],
    y: screenCoordinates[1],
    type: typeof d.type === 'function' ? d.type : undefined,
    screenCoordinates
  });
  if (d.fixedX) noteData.x = d.fixedX;
  if (d.fixedY) noteData.y = d.fixedY;
  return React$1.createElement(Annotation, {
    key: d.key || `annotation-${i}`,
    noteData: noteData
  });
};
const svgEncloseRule$1 = ({
  d,
  i,
  screenCoordinates
}) => {
  const circle = packEnclose(screenCoordinates.map(p => ({
    x: p[0],
    y: p[1],
    r: 2
  })));
  return CircleEnclosure({
    d,
    i,
    circle
  });
};
const svgRRule = ({
  d,
  i,
  screenCoordinates,
  rScale,
  rAccessor,
  adjustedSize,
  adjustedPosition,
  projection
}) => {
  let x, y, xPosition, yPosition, subject, dx, dy;

  if (projection === 'radial') {
    return React$1.createElement(Annotation, {
      key: d.key || `annotation-${i}`,
      noteData: Object.assign({
        dx: 50,
        dy: 50,
        note: {
          label: d.label
        },
        connector: {
          end: 'arrow'
        }
      }, d, {
        type: AnnotationCalloutCircle,
        subject: {
          radius: rScale(findFirstAccessorValue(rAccessor, d)) / 2,
          radiusPadding: 0
        },
        x: adjustedSize[0] / 2,
        y: adjustedSize[1] / 2
      })
    });
  } else if (projection === 'horizontal') {
    dx = 50;
    dy = 50;
    yPosition = d.offset || i * 25;
    x = screenCoordinates[0];
    y = yPosition;
    subject = {
      x,
      y1: 0,
      y2: adjustedSize[1] + adjustedPosition[1]
    };
  } else {
    dx = 50;
    dy = -20;
    xPosition = d.offset || i * 25;
    y = screenCoordinates[1];
    x = xPosition;
    subject = {
      y,
      x1: 0,
      x2: adjustedSize[0] + adjustedPosition[0]
    };
  }

  const noteData = Object.assign({
    dx,
    dy,
    note: {
      label: d.label
    },
    connector: {
      end: 'arrow'
    }
  }, d, {
    type: AnnotationXYThreshold,
    x,
    y,
    subject
  });
  return React$1.createElement(Annotation, {
    key: d.key || `annotation-${i}`,
    noteData: noteData
  });
};
const svgCategoryRule = ({
  projection,
  d,
  i,
  categories,
  adjustedSize
}) => {
  const {
    bracketType = 'curly',
    position = projection === 'vertical' ? 'top' : 'left',
    depth = 30,
    offset = 0,
    padding = 0
  } = d;
  const actualCategories = Array.isArray(d.categories) ? d.categories : [d.categories];
  const cats = actualCategories.map(c => categories[c]);

  if (projection === 'radial') {
    const arcPadding = padding / adjustedSize[1];
    const leftX = min(cats.map(p => p.pct_start + p.pct_padding / 2 + arcPadding / 2));
    const rightX = max(cats.map(p => p.pct_start + p.pct - p.pct_padding / 2 - arcPadding / 2));
    const chartSize = Math.min(adjustedSize[0], adjustedSize[1]) / 2;
    const centerX = adjustedSize[0] / 2;
    const centerY = adjustedSize[1] / 2;
    const {
      arcPath,
      textArcPath
    } = arcBracket({
      x: 0,
      y: 0,
      radius: chartSize,
      startAngle: leftX * 360,
      endAngle: rightX * 360,
      inset: depth,
      outset: offset,
      curly: bracketType === 'curly'
    });
    const textPathID = `text-path-${i}-${Math.random()}`;
    return React$1.createElement("g", {
      className: "category-annotation annotation",
      transform: `translate(${centerX},${centerY})`
    }, React$1.createElement("path", {
      d: arcPath,
      fill: "none",
      stroke: "black"
    }), React$1.createElement("path", {
      id: textPathID,
      d: textArcPath,
      style: {
        display: 'none'
      }
    }), React$1.createElement("text", {
      "font-size": "12.5"
    }, React$1.createElement("textPath", {
      startOffset: '50%',
      textAnchor: 'middle',
      xlinkHref: `#${textPathID}`
    }, d.label)));
  } else {
    const leftX = min(cats.map(p => p.x));
    const rightX = max(cats.map(p => p.x + p.width));

    if (projection === 'vertical') {
      let yPosition = position === 'top' ? 0 : adjustedSize[1];
      yPosition += position === 'top' ? -offset : offset;
      const noteData = {
        type: AnnotationBracket,
        y: yPosition,
        x: leftX - padding,
        note: {
          title: d.title || d.label,
          label: d.title ? d.label : undefined
        },
        subject: {
          type: bracketType,
          width: rightX - leftX + padding * 2,
          depth: position === 'top' ? -depth : depth
        }
      };
      return React$1.createElement(Annotation, {
        key: d.key || `annotation-${i}`,
        noteData: noteData
      });
    } else if (projection === 'horizontal') {
      let yPosition = position === 'left' ? 0 : adjustedSize[0];
      yPosition += position === 'left' ? -offset : offset;
      const noteData = {
        type: AnnotationBracket,
        x: yPosition,
        y: leftX - padding,
        note: {
          title: d.title || d.label,
          label: d.title ? d.label : undefined
        },
        subject: {
          type: bracketType,
          height: rightX - leftX + padding * 2,
          depth: position === 'left' ? -depth : depth
        }
      };
      return React$1.createElement(Annotation, {
        key: d.key || `annotation-${i}`,
        noteData: noteData
      });
    }
  }
};
const htmlFrameHoverRule$1 = ({
  d,
  i,
  rAccessor,
  oAccessor,
  projection,
  tooltipContent,
  optimizeCustomTooltipPosition,
  useSpans,
  pieceIDAccessor,
  projectedColumns,
  adjustedSize,
  rScale,
  type,
  rScaleType
}) => {
  tooltipContent = tooltipContent === 'pie' ? () => pieContentGenerator({
    column: d.column,
    useSpans
  }) : tooltipContent; //To string because React gives a DOM error if it gets a date

  let contentFill;
  const pO = findFirstAccessorValue(oAccessor, d) || d.column;
  const oColumn = projectedColumns[pO];
  const idPiece = findIDPiece(pieceIDAccessor, oColumn, d);

  if (!idPiece) {
    return null;
  }

  const screenCoordinates = (type.type === 'clusterbar' || type.type === 'ordinalpoint' || type.type === 'swarm') && d.x !== undefined && d.y !== undefined || d.isSummaryData ? [d.x, d.y] : screenProject({
    p: d,
    adjustedSize,
    rScale,
    oColumn,
    rAccessor,
    idPiece,
    projection,
    rScaleType
  });

  if (d.isSummaryData) {
    let summaryContent = d.label;

    if (d.pieces && d.pieces.length !== 0) {
      if (d.pieces.length === 1) {
        summaryContent = [];
        rAccessor.forEach(actualRAccessor => {
          summaryContent.push(actualRAccessor(d.pieces[0].data));
        });
      } else {
        summaryContent = [];
        rAccessor.forEach(actualRAccessor => {
          const pieceData = extent(d.pieces.map(p => p.data).map(actualRAccessor));
          summaryContent.push(`From ${pieceData[0]} to ${pieceData[1]}`);
        });
      }
    }

    const summaryLabel = React$1.createElement("p", {
      key: "html-annotation-content-2"
    }, summaryContent);
    contentFill = [React$1.createElement("p", {
      key: "html-annotation-content-1"
    }, d.key), summaryLabel, React$1.createElement("p", {
      key: "html-annotation-content-3"
    }, d.value)];
  } else if (d.data) {
    contentFill = [];
    oAccessor.forEach((actualOAccessor, i) => {
      if (actualOAccessor(idPiece.data)) contentFill.push(React$1.createElement("p", {
        key: `html-annotation-content-o-${i}`
      }, actualOAccessor(idPiece.data).toString()));
    });
    rAccessor.forEach((actualRAccessor, i) => {
      if (actualRAccessor(idPiece.data)) contentFill.push(React$1.createElement("p", {
        key: `html-annotation-content-r-${i}`
      }, actualRAccessor(idPiece.data).toString()));
    });
  } else if (d.label) {
    contentFill = d.label;
  }

  let content = React$1.createElement(SpanOrDiv, {
    span: useSpans,
    className: "tooltip-content"
  }, contentFill);

  if (d.type === 'frame-hover' && tooltipContent && idPiece) {
    const tooltipContentArgs = { ...idPiece,
      ...idPiece.data
    };
    content = optimizeCustomTooltipPosition ? React$1.createElement(TooltipPositioner, {
      tooltipContent: tooltipContent,
      tooltipContentArgs: tooltipContentArgs
    }) : tooltipContent(tooltipContentArgs);
  }

  return React$1.createElement(SpanOrDiv, {
    span: useSpans,
    key: `xylabel-${i}`,
    className: `annotation annotation-or-label ${projection} ${d.className || ''}`,
    style: {
      position: 'absolute',
      top: `${screenCoordinates[1]}px`,
      left: `${screenCoordinates[0]}px`
    }
  }, content);
};
const htmlColumnHoverRule = ({
  d,
  i,
  summaryType,
  oAccessor,
  type,
  adjustedPosition,
  adjustedSize,
  projection,
  tooltipContent,
  optimizeCustomTooltipPosition,
  useSpans,
  projectedColumns
}) => {
  //we need to ignore negative pieces to make sure the hover behavior populates on top of the positive bar
  const {
    coordinates: [xPosition, yPosition],
    pieces,
    column
  } = getColumnScreenCoordinates({
    d,
    projectedColumns,
    oAccessor,
    summaryType,
    type,
    projection,
    adjustedPosition,
    adjustedSize
  });

  if (column === undefined) {
    return null;
  } //To string because React gives a DOM error if it gets a date


  const oContent = [];
  oAccessor.forEach((actualOAccessor, i) => {
    if (pieces[0].data) oContent.push(React$1.createElement("p", {
      key: `or-annotation-o-${i}`
    }, actualOAccessor(pieces[0].data).toString()));
  });
  let content = React$1.createElement(SpanOrDiv, {
    span: useSpans,
    className: "tooltip-content"
  }, oContent, React$1.createElement("p", {
    key: "or-annotation-2"
  }, sum(pieces.map(p => p.value).filter(p => p > 0))));

  if (d.type === 'column-hover' && tooltipContent) {
    if (tooltipContent === 'pie') {
      tooltipContent = pieContentGenerator;
    }

    const tooltipContentArgs = { ...d,
      pieces: pieces.map(p => p.data),
      column,
      oAccessor
    };
    content = optimizeCustomTooltipPosition ? React$1.createElement(TooltipPositioner, {
      tooltipContent: tooltipContent,
      tooltipContentArgs: tooltipContentArgs
    }) : tooltipContent(tooltipContentArgs);
  } else if (d.label) {
    content = React$1.createElement(SpanOrDiv, {
      span: useSpans,
      className: "tooltip-content"
    }, d.label);
  }

  return React$1.createElement(SpanOrDiv, {
    span: useSpans,
    key: `orlabel-${i}`,
    className: `annotation annotation-or-label ${projection} ${d.className || ''}`,
    style: {
      position: 'absolute',
      top: `${yPosition}px`,
      left: `${xPosition}px`
    }
  }, content);
};
const svgRectEncloseRule$1 = ({
  d,
  i,
  screenCoordinates
}) => {
  const bboxNodes = screenCoordinates.map(p => {
    return {
      x0: p.x0 = p[0],
      x1: p.x1 = p[0],
      y0: p.y0 = p[1],
      y1: p.y1 = p[1]
    };
  });
  return RectangleEnclosure({
    bboxNodes,
    d,
    i
  });
};
const svgOrdinalLine = ({
  screenCoordinates,
  d,
  voronoiHover
}) => {
  const lineGenerator = line$1().x(d => d[0]).y(d => d[1]);

  if (d.curve) {
    const interpolator = curveHash[d.curve] || d.curve;
    lineGenerator.curve(interpolator);
  }

  const lineStyle = typeof d.lineStyle === 'function' ? d.lineStyle(d) : d.lineStyle || {};
  return React$1.createElement("g", null, React$1.createElement("path", {
    stroke: "black",
    fill: "none",
    style: lineStyle,
    d: lineGenerator(screenCoordinates)
  }), (d.points || d.interactive) && screenCoordinates.map((p, q) => {
    const pointStyle = typeof d.pointStyle === 'function' ? d.pointStyle(d.coordinates[q], q) : d.pointStyle || {};
    return React$1.createElement("g", {
      transform: `translate(${p[0]},${p[1]})`,
      key: `ordinal-line-point-${q}`
    }, d.points && React$1.createElement("circle", {
      style: pointStyle,
      r: d.radius || 5,
      fill: "black"
    }), d.interactive && React$1.createElement("circle", {
      style: {
        pointerEvents: 'all'
      },
      r: d.hoverRadius || 15,
      fill: "pink",
      opacity: 0,
      onMouseEnter: () => voronoiHover({
        type: 'frame-hover',
        ...d.coordinates[q],
        data: d.coordinates[q]
      }),
      onMouseOut: () => voronoiHover()
    }), "}");
  }));
};

const generateOrdinalSVGAnnotations = ({
  frameProps,
  frameData
}) => ({
  d,
  i,
  voronoiHover
}) => {
  const {
    projection
  } = frameProps;
  const {
    adjustedPosition,
    adjustedSize,
    oAccessor,
    rAccessor,
    oScale,
    rScale,
    projectedColumns,
    orFrameRender,
    pieceIDAccessor,
    rScaleType
  } = frameData;
  let screenCoordinates = [0, 0]; //TODO: Support radial??

  if (d.coordinates || d.type === 'enclose' && d.neighbors) {
    screenCoordinates = (d.coordinates || d.neighbors).map(p => {
      const pO = findFirstAccessorValue(oAccessor, p) || p.column;
      const oColumn = projectedColumns[pO];
      const idPiece = findIDPiece(pieceIDAccessor, oColumn, p);
      return screenProject({
        p,
        adjustedSize,
        rScale,
        rAccessor,
        idPiece,
        projection,
        oColumn,
        rScaleType
      });
    });
  } else {
    const pO = findFirstAccessorValue(oAccessor, d) || d.column;
    const oColumn = projectedColumns[pO];
    const idPiece = findIDPiece(pieceIDAccessor, oColumn, d);
    screenCoordinates = screenProject({
      p: d,
      adjustedSize,
      rScale,
      rAccessor,
      idPiece,
      projection,
      oColumn,
      rScaleType
    });
  }

  if (d.type === 'desaturation-layer') {
    return DesaturationLayer({
      style: d.style instanceof Function ? d.style(d, i) : d.style,
      size: adjustedSize,
      i,
      key: d.key
    });
  } else if (d.type === 'ordinal-line') {
    return svgOrdinalLine({
      d,
      screenCoordinates,
      voronoiHover
    });
  } else if (d.type === 'or') {
    return svgORRule({
      d,
      i,
      screenCoordinates,
      projection
    });
  } else if (d.type === 'highlight') {
    return svgHighlightRule$1({
      d,
      pieceIDAccessor,
      orFrameRender,
      oAccessor
    });
  } else if (d.type === 'react-annotation' || typeof d.type === 'function') {
    return basicReactAnnotationRule({
      d,
      i,
      screenCoordinates
    });
  } else if (d.type === 'enclose') {
    return svgEncloseRule$1({
      d,
      i,
      screenCoordinates
    });
  } else if (d.type === 'enclose-rect') {
    return svgRectEncloseRule$1({
      d,
      screenCoordinates,
      i
    });
  } else if (d.type === 'r') {
    return svgRRule({
      d,
      i,
      screenCoordinates,
      rScale,
      rAccessor,
      projection,
      adjustedSize,
      adjustedPosition
    });
  } else if (d.type === 'category') {
    return svgCategoryRule({
      projection,
      d,
      i,
      categories: frameData.projectedColumns,
      adjustedSize
    });
  }

  return null;
};

const generateOrdinalHTMLAnnotations = ({
  frameProps,
  frameData
}) => ({
  d,
  i,
  voronoiHover
}) => {
  const {
    adjustedPosition,
    adjustedSize,
    oAccessor,
    rAccessor,
    oScale,
    rScale,
    projectedColumns,
    summaryType,
    type,
    pieceIDAccessor,
    rScaleType
  } = frameData;
  const {
    tooltipContent,
    optimizeCustomTooltipPosition,
    projection,
    size,
    useSpans
  } = frameProps;
  let screenCoordinates = [0, 0];

  if (d.coordinates || d.type === 'enclose' && d.neighbors) {
    screenCoordinates = (d.coordinates || d.neighbors).map(p => {
      const pO = findFirstAccessorValue(oAccessor, p) || p.column;
      const oColumn = projectedColumns[pO];
      const idPiece = findIDPiece(pieceIDAccessor, oColumn, p);
      return screenProject({
        p,
        adjustedSize,
        rScale,
        rAccessor,
        idPiece,
        projection,
        oColumn,
        rScaleType
      });
    });
  } else if (d.type === 'column-hover') {
    const {
      coordinates: [xPosition, yPosition]
    } = getColumnScreenCoordinates({
      d,
      projectedColumns,
      oAccessor,
      summaryType,
      type,
      projection,
      adjustedPosition,
      adjustedSize
    });
    screenCoordinates = [xPosition, yPosition];
  } else {
    const pO = findFirstAccessorValue(oAccessor, d) || d.column;
    const oColumn = projectedColumns[pO];
    const idPiece = findIDPiece(pieceIDAccessor, oColumn, d);
    screenCoordinates = screenProject({
      p: d,
      adjustedSize,
      rScale,
      rAccessor,
      idPiece,
      projection,
      oColumn,
      rScaleType
    });
  }

  if (d.type === 'frame-hover') {
    return htmlFrameHoverRule$1({
      d,
      i,
      rAccessor,
      oAccessor,
      projection,
      tooltipContent,
      optimizeCustomTooltipPosition,
      projectedColumns,
      useSpans,
      pieceIDAccessor,
      adjustedSize,
      rScale,
      type,
      rScaleType
    });
  } else if (d.type === 'column-hover') {
    return htmlColumnHoverRule({
      d,
      i,
      summaryType,
      oAccessor,
      projectedColumns,
      type,
      adjustedPosition,
      adjustedSize,
      projection,
      tooltipContent,
      optimizeCustomTooltipPosition,
      useSpans
    });
  }

  return null;
};

var thirdPi = Math.PI / 3,
    angles = [0, thirdPi, 2 * thirdPi, 3 * thirdPi, 4 * thirdPi, 5 * thirdPi];

function pointX(d) {
  return d[0];
}

function pointY(d) {
  return d[1];
}

function hexbin() {
  var x0 = 0,
      y0 = 0,
      x1 = 1,
      y1 = 1,
      x = pointX,
      y = pointY,
      r,
      dx,
      dy;

  function hexbin(points) {
    var binsById = {}, bins = [], i, n = points.length;

    for (i = 0; i < n; ++i) {
      if (isNaN(px = +x.call(null, point = points[i], i, points))
          || isNaN(py = +y.call(null, point, i, points))) continue;

      var point,
          px,
          py,
          pj = Math.round(py = py / dy),
          pi = Math.round(px = px / dx - (pj & 1) / 2),
          py1 = py - pj;

      if (Math.abs(py1) * 3 > 1) {
        var px1 = px - pi,
            pi2 = pi + (px < pi ? -1 : 1) / 2,
            pj2 = pj + (py < pj ? -1 : 1),
            px2 = px - pi2,
            py2 = py - pj2;
        if (px1 * px1 + py1 * py1 > px2 * px2 + py2 * py2) pi = pi2 + (pj & 1 ? 1 : -1) / 2, pj = pj2;
      }

      var id = pi + "-" + pj, bin = binsById[id];
      if (bin) bin.push(point);
      else {
        bins.push(bin = binsById[id] = [point]);
        bin.x = (pi + (pj & 1) / 2) * dx;
        bin.y = pj * dy;
      }
    }

    return bins;
  }

  function hexagon(radius) {
    var x0 = 0, y0 = 0;
    return angles.map(function(angle) {
      var x1 = Math.sin(angle) * radius,
          y1 = -Math.cos(angle) * radius,
          dx = x1 - x0,
          dy = y1 - y0;
      x0 = x1, y0 = y1;
      return [dx, dy];
    });
  }

  hexbin.hexagon = function(radius) {
    return "m" + hexagon(radius == null ? r : +radius).join("l") + "z";
  };

  hexbin.centers = function() {
    var centers = [],
        j = Math.round(y0 / dy),
        i = Math.round(x0 / dx);
    for (var y = j * dy; y < y1 + r; y += dy, ++j) {
      for (var x = i * dx + (j & 1) * dx / 2; x < x1 + dx / 2; x += dx) {
        centers.push([x, y]);
      }
    }
    return centers;
  };

  hexbin.mesh = function() {
    var fragment = hexagon(r).slice(0, 4).join("l");
    return hexbin.centers().map(function(p) { return "M" + p + "m" + fragment; }).join("");
  };

  hexbin.x = function(_) {
    return arguments.length ? (x = _, hexbin) : x;
  };

  hexbin.y = function(_) {
    return arguments.length ? (y = _, hexbin) : y;
  };

  hexbin.radius = function(_) {
    return arguments.length ? (r = +_, dx = r * 2 * Math.sin(thirdPi), dy = r * 1.5, hexbin) : r;
  };

  hexbin.size = function(_) {
    return arguments.length ? (x0 = y0 = 0, x1 = +_[0], y1 = +_[1], hexbin) : [x1 - x0, y1 - y0];
  };

  hexbin.extent = function(_) {
    return arguments.length ? (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1], hexbin) : [[x0, y0], [x1, y1]];
  };

  return hexbin.radius(1);
}

const DEFAULT_SERIES = 'default';

const groupData = ({
  data,
  xAccessor,
  yAccessor,
  sAccessor,
  showPoints
}) => {
  let projectedPoints = [];
  let groupedMap = new Map();

  if (sAccessor) {
    groupedMap = group(data, sAccessor);
  } else {
    groupedMap.set(DEFAULT_SERIES, data);
  }

  const groupedData = Array.from(groupedMap.keys()).map(d => ({
    s: d,
    _xyCoordinates: groupedMap.get(d).map(e => ({
      x: xAccessor(e),
      y: yAccessor(e),
      yTop: yAccessor(e),
      yBottom: 0,
      data: e
    })),
    _baseData: groupedMap.get(d)
  }));

  if (showPoints === true) {
    projectedPoints = data.map(d => ({
      parentSummary: groupedData.find(e => sAccessor ? e.s === sAccessor(d) : e.s === DEFAULT_SERIES),
      _data: d,
      x: xAccessor(d),
      y: yAccessor(d),
      yTop: yAccessor(d),
      yBottom: 0
    }));
  }

  return {
    groupedData,
    projectedPoints
  };
};

const hexbinProjection = ({
  bins,
  cellPx,
  binValue,
  binMax,
  customMark,
  frameXScale,
  frameYScale,
  size,
  data,
  xAccessor,
  yAccessor,
  sAccessor,
  showPoints
}) => {
  let projectedAreas = [];
  const {
    groupedData,
    projectedPoints
  } = groupData({
    data,
    xAccessor,
    yAccessor,
    sAccessor,
    showPoints
  });
  const hexBinXScale = linear$1().domain(frameXScale.domain()).range([0, size[0]]);
  const hexBinYScale = linear$1().domain(frameYScale.domain()).range([0, size[1]]);
  const actualResolution = cellPx && cellPx / 2 || (bins > 1 ? 1 / bins : bins) * size[0] / 2;
  const hexbinner = hexbin().x(d => hexBinXScale(d._xyPoint.x)).y(d => hexBinYScale(d._xyPoint.y)).radius(actualResolution).size(size);
  let hexMax;
  const allHexes = hexbinner.centers();
  groupedData.forEach(hexbinData => {
    hexMax = 0;
    const hexes = hexbinner(hexbinData._xyCoordinates.map((d, i) => ({
      _xyPoint: d,
      ...hexbinData._baseData[i]
    })));
    const centerHash = {};
    hexes.forEach(d => {
      centerHash[`${parseInt(d.x)}-${parseInt(d.y)}`] = true;
    });
    allHexes.forEach(hexCenter => {
      if (!centerHash[`${parseInt(hexCenter[0])}-${parseInt(hexCenter[1])}`]) {
        const newHex = [];
        newHex.x = hexCenter[0];
        newHex.y = hexCenter[1];
        hexes.push(newHex);
      }
    });
    hexMax = Math.max(...hexes.map(d => binValue(d)));

    if (binMax) {
      binMax(hexMax);
    } //Option for blank hexe


    const hexBase = [[0, -1], [0.866, -0.5], [0.866, 0.5], [0, 1], [-0.866, 0.5], [-0.866, -0.5]];
    const hexWidth = hexBinXScale.invert(actualResolution) - frameXScale.domain()[0];
    const hexHeight = hexBinYScale.invert(actualResolution) - frameYScale.domain()[0];
    const hexacoordinates = hexBase.map(d => [d[0] * hexWidth, d[1] * hexHeight]);
    const hexbinProjectedAreas = hexes.map(d => {
      const hexValue = binValue(d);
      const gx = d.x;
      const gy = d.y;
      d.x = hexBinXScale.invert(d.x);
      d.y = hexBinYScale.invert(d.y);
      const percent = hexValue / hexMax;
      return {
        customMark: customMark && React.createElement("g", {
          transform: `translate(${gx},${size[1] - gy})`
        }, customMark({
          d: { ...d,
            binItems: d,
            percent,
            value: hexValue,
            radius: actualResolution,
            hexCoordinates: hexBase.map(d => [d[0] * actualResolution, d[1] * actualResolution])
          },
          baseMarkProps,
          margin,
          styleFn,
          classFn,
          renderFn,
          chartSize,
          adjustedSize: size
        })),
        _xyCoordinates: hexacoordinates.map(p => [p[0] + d.x, p[1] + d.y]),
        value: hexValue,
        percent,
        data: d,
        parentSummary: hexbinData,
        centroid: true
      };
    });
    projectedAreas = [...projectedAreas, ...hexbinProjectedAreas];
  });
  return {
    projectedAreas,
    projectedPoints,
    projectedLines: []
  };
};

const Plot = props => {
  return null;
};

Plot.propTypes = {
  projection: propTypes.func,
  data: propTypes.array,
  lineStyle: propTypes.oneOfType([propTypes.object, propTypes.func]),
  lineClass: propTypes.oneOfType([propTypes.object, propTypes.func]),
  lineRenderMode: propTypes.oneOfType([propTypes.object, propTypes.func]),
  lineCustomMarks: propTypes.oneOfType([propTypes.node, propTypes.func]),
  lineUseCanvas: propTypes.bool,
  areaStyle: propTypes.oneOfType([propTypes.object, propTypes.func]),
  areaClass: propTypes.oneOfType([propTypes.object, propTypes.func]),
  areaRenderMode: propTypes.oneOfType([propTypes.object, propTypes.func]),
  areaCustomMarks: propTypes.oneOfType([propTypes.node, propTypes.func]),
  areaUseCanvas: propTypes.bool,
  pointStyle: propTypes.oneOfType([propTypes.object, propTypes.func]),
  pointClass: propTypes.oneOfType([propTypes.object, propTypes.func]),
  pointRenderMode: propTypes.oneOfType([propTypes.object, propTypes.func]),
  pointCustomMarks: propTypes.oneOfType([propTypes.node, propTypes.func]),
  pointUseCanvas: propTypes.bool,
  showPoints: propTypes.bool,
  xExtent: propTypes.array,
  yExtent: propTypes.array,
  xAccessor: propTypes.oneOfType([propTypes.string, propTypes.func]),
  yAccessor: propTypes.oneOfType([propTypes.string, propTypes.func]),
  sAccessor: propTypes.oneOfType([propTypes.string, propTypes.func])
};
Plot.defaultProps = {
  showPoints: true,
  pointUseCanvas: true,
  lineUseCanvas: true,
  areaUseCanvas: true
};

const Hexbin = props => {
  return React$1__default.createElement(Plot, props);
};

Hexbin.propTypes = { ...Plot.propTypes,
  bins: propTypes.number,
  cellPx: propTypes.number,
  binValue: propTypes.func,
  binMax: propTypes.number
};
Hexbin.defaultProps = { ...Plot.defaultProps,
  bins: 0.05,
  binValue: d => d.length,
  projection: hexbinProjection
};

function ascending$5(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}

function bisector$2(compare) {
  if (compare.length === 1) compare = ascendingComparator$2(compare);
  return {
    left: function(a, x, lo, hi) {
      if (lo == null) lo = 0;
      if (hi == null) hi = a.length;
      while (lo < hi) {
        var mid = lo + hi >>> 1;
        if (compare(a[mid], x) < 0) lo = mid + 1;
        else hi = mid;
      }
      return lo;
    },
    right: function(a, x, lo, hi) {
      if (lo == null) lo = 0;
      if (hi == null) hi = a.length;
      while (lo < hi) {
        var mid = lo + hi >>> 1;
        if (compare(a[mid], x) > 0) hi = mid;
        else lo = mid + 1;
      }
      return lo;
    }
  };
}

function ascendingComparator$2(f) {
  return function(d, x) {
    return ascending$5(f(d), x);
  };
}

var ascendingBisect$2 = bisector$2(ascending$5);

function extent$1(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      min,
      max;

  if (valueof == null) {
    while (++i < n) { // Find the first comparable value.
      if ((value = values[i]) != null && value >= value) {
        min = max = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = values[i]) != null) {
            if (min > value) min = value;
            if (max < value) max = value;
          }
        }
      }
    }
  }

  else {
    while (++i < n) { // Find the first comparable value.
      if ((value = valueof(values[i], i, values)) != null && value >= value) {
        min = max = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = valueof(values[i], i, values)) != null) {
            if (min > value) min = value;
            if (max < value) max = value;
          }
        }
      }
    }
  }

  return [min, max];
}

function range(start, stop, step) {
  start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;

  var i = -1,
      n = Math.max(0, Math.ceil((stop - start) / step)) | 0,
      range = new Array(n);

  while (++i < n) {
    range[i] = start + i * step;
  }

  return range;
}

var e10$2 = Math.sqrt(50),
    e5$2 = Math.sqrt(10),
    e2$2 = Math.sqrt(2);

function tickStep$2(start, stop, count) {
  var step0 = Math.abs(stop - start) / Math.max(0, count),
      step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)),
      error = step0 / step1;
  if (error >= e10$2) step1 *= 10;
  else if (error >= e5$2) step1 *= 5;
  else if (error >= e2$2) step1 *= 2;
  return stop < start ? -step1 : step1;
}

function thresholdSturges(values) {
  return Math.ceil(Math.log(values.length) / Math.LN2) + 1;
}

function max$4(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      max;

  if (valueof == null) {
    while (++i < n) { // Find the first comparable value.
      if ((value = values[i]) != null && value >= value) {
        max = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = values[i]) != null && value > max) {
            max = value;
          }
        }
      }
    }
  }

  else {
    while (++i < n) { // Find the first comparable value.
      if ((value = valueof(values[i], i, values)) != null && value >= value) {
        max = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = valueof(values[i], i, values)) != null && value > max) {
            max = value;
          }
        }
      }
    }
  }

  return max;
}

var array$2 = Array.prototype;

var slice$5 = array$2.slice;

function ascending$6(a, b) {
  return a - b;
}

function area$2(ring) {
  var i = 0, n = ring.length, area = ring[n - 1][1] * ring[0][0] - ring[n - 1][0] * ring[0][1];
  while (++i < n) area += ring[i - 1][1] * ring[i][0] - ring[i - 1][0] * ring[i][1];
  return area;
}

function constant$8(x) {
  return function() {
    return x;
  };
}

function contains(ring, hole) {
  var i = -1, n = hole.length, c;
  while (++i < n) if (c = ringContains(ring, hole[i])) return c;
  return 0;
}

function ringContains(ring, point) {
  var x = point[0], y = point[1], contains = -1;
  for (var i = 0, n = ring.length, j = n - 1; i < n; j = i++) {
    var pi = ring[i], xi = pi[0], yi = pi[1], pj = ring[j], xj = pj[0], yj = pj[1];
    if (segmentContains(pi, pj, point)) return 0;
    if (((yi > y) !== (yj > y)) && ((x < (xj - xi) * (y - yi) / (yj - yi) + xi))) contains = -contains;
  }
  return contains;
}

function segmentContains(a, b, c) {
  var i; return collinear(a, b, c) && within(a[i = +(a[0] === b[0])], c[i], b[i]);
}

function collinear(a, b, c) {
  return (b[0] - a[0]) * (c[1] - a[1]) === (c[0] - a[0]) * (b[1] - a[1]);
}

function within(p, q, r) {
  return p <= q && q <= r || r <= q && q <= p;
}

function noop$3() {}

var cases = [
  [],
  [[[1.0, 1.5], [0.5, 1.0]]],
  [[[1.5, 1.0], [1.0, 1.5]]],
  [[[1.5, 1.0], [0.5, 1.0]]],
  [[[1.0, 0.5], [1.5, 1.0]]],
  [[[1.0, 1.5], [0.5, 1.0]], [[1.0, 0.5], [1.5, 1.0]]],
  [[[1.0, 0.5], [1.0, 1.5]]],
  [[[1.0, 0.5], [0.5, 1.0]]],
  [[[0.5, 1.0], [1.0, 0.5]]],
  [[[1.0, 1.5], [1.0, 0.5]]],
  [[[0.5, 1.0], [1.0, 0.5]], [[1.5, 1.0], [1.0, 1.5]]],
  [[[1.5, 1.0], [1.0, 0.5]]],
  [[[0.5, 1.0], [1.5, 1.0]]],
  [[[1.0, 1.5], [1.5, 1.0]]],
  [[[0.5, 1.0], [1.0, 1.5]]],
  []
];

function contours() {
  var dx = 1,
      dy = 1,
      threshold = thresholdSturges,
      smooth = smoothLinear;

  function contours(values) {
    var tz = threshold(values);

    // Convert number of thresholds into uniform thresholds.
    if (!Array.isArray(tz)) {
      var domain = extent$1(values), start = domain[0], stop = domain[1];
      tz = tickStep$2(start, stop, tz);
      tz = range(Math.floor(start / tz) * tz, Math.floor(stop / tz) * tz, tz);
    } else {
      tz = tz.slice().sort(ascending$6);
    }

    return tz.map(function(value) {
      return contour(values, value);
    });
  }

  // Accumulate, smooth contour rings, assign holes to exterior rings.
  // Based on https://github.com/mbostock/shapefile/blob/v0.6.2/shp/polygon.js
  function contour(values, value) {
    var polygons = [],
        holes = [];

    isorings(values, value, function(ring) {
      smooth(ring, values, value);
      if (area$2(ring) > 0) polygons.push([ring]);
      else holes.push(ring);
    });

    holes.forEach(function(hole) {
      for (var i = 0, n = polygons.length, polygon; i < n; ++i) {
        if (contains((polygon = polygons[i])[0], hole) !== -1) {
          polygon.push(hole);
          return;
        }
      }
    });

    return {
      type: "MultiPolygon",
      value: value,
      coordinates: polygons
    };
  }

  // Marching squares with isolines stitched into rings.
  // Based on https://github.com/topojson/topojson-client/blob/v3.0.0/src/stitch.js
  function isorings(values, value, callback) {
    var fragmentByStart = new Array,
        fragmentByEnd = new Array,
        x, y, t0, t1, t2, t3;

    // Special case for the first row (y = -1, t2 = t3 = 0).
    x = y = -1;
    t1 = values[0] >= value;
    cases[t1 << 1].forEach(stitch);
    while (++x < dx - 1) {
      t0 = t1, t1 = values[x + 1] >= value;
      cases[t0 | t1 << 1].forEach(stitch);
    }
    cases[t1 << 0].forEach(stitch);

    // General case for the intermediate rows.
    while (++y < dy - 1) {
      x = -1;
      t1 = values[y * dx + dx] >= value;
      t2 = values[y * dx] >= value;
      cases[t1 << 1 | t2 << 2].forEach(stitch);
      while (++x < dx - 1) {
        t0 = t1, t1 = values[y * dx + dx + x + 1] >= value;
        t3 = t2, t2 = values[y * dx + x + 1] >= value;
        cases[t0 | t1 << 1 | t2 << 2 | t3 << 3].forEach(stitch);
      }
      cases[t1 | t2 << 3].forEach(stitch);
    }

    // Special case for the last row (y = dy - 1, t0 = t1 = 0).
    x = -1;
    t2 = values[y * dx] >= value;
    cases[t2 << 2].forEach(stitch);
    while (++x < dx - 1) {
      t3 = t2, t2 = values[y * dx + x + 1] >= value;
      cases[t2 << 2 | t3 << 3].forEach(stitch);
    }
    cases[t2 << 3].forEach(stitch);

    function stitch(line) {
      var start = [line[0][0] + x, line[0][1] + y],
          end = [line[1][0] + x, line[1][1] + y],
          startIndex = index(start),
          endIndex = index(end),
          f, g;
      if (f = fragmentByEnd[startIndex]) {
        if (g = fragmentByStart[endIndex]) {
          delete fragmentByEnd[f.end];
          delete fragmentByStart[g.start];
          if (f === g) {
            f.ring.push(end);
            callback(f.ring);
          } else {
            fragmentByStart[f.start] = fragmentByEnd[g.end] = {start: f.start, end: g.end, ring: f.ring.concat(g.ring)};
          }
        } else {
          delete fragmentByEnd[f.end];
          f.ring.push(end);
          fragmentByEnd[f.end = endIndex] = f;
        }
      } else if (f = fragmentByStart[endIndex]) {
        if (g = fragmentByEnd[startIndex]) {
          delete fragmentByStart[f.start];
          delete fragmentByEnd[g.end];
          if (f === g) {
            f.ring.push(end);
            callback(f.ring);
          } else {
            fragmentByStart[g.start] = fragmentByEnd[f.end] = {start: g.start, end: f.end, ring: g.ring.concat(f.ring)};
          }
        } else {
          delete fragmentByStart[f.start];
          f.ring.unshift(start);
          fragmentByStart[f.start = startIndex] = f;
        }
      } else {
        fragmentByStart[startIndex] = fragmentByEnd[endIndex] = {start: startIndex, end: endIndex, ring: [start, end]};
      }
    }
  }

  function index(point) {
    return point[0] * 2 + point[1] * (dx + 1) * 4;
  }

  function smoothLinear(ring, values, value) {
    ring.forEach(function(point) {
      var x = point[0],
          y = point[1],
          xt = x | 0,
          yt = y | 0,
          v0,
          v1 = values[yt * dx + xt];
      if (x > 0 && x < dx && xt === x) {
        v0 = values[yt * dx + xt - 1];
        point[0] = x + (value - v0) / (v1 - v0) - 0.5;
      }
      if (y > 0 && y < dy && yt === y) {
        v0 = values[(yt - 1) * dx + xt];
        point[1] = y + (value - v0) / (v1 - v0) - 0.5;
      }
    });
  }

  contours.contour = contour;

  contours.size = function(_) {
    if (!arguments.length) return [dx, dy];
    var _0 = Math.ceil(_[0]), _1 = Math.ceil(_[1]);
    if (!(_0 > 0) || !(_1 > 0)) throw new Error("invalid size");
    return dx = _0, dy = _1, contours;
  };

  contours.thresholds = function(_) {
    return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? constant$8(slice$5.call(_)) : constant$8(_), contours) : threshold;
  };

  contours.smooth = function(_) {
    return arguments.length ? (smooth = _ ? smoothLinear : noop$3, contours) : smooth === smoothLinear;
  };

  return contours;
}

// TODO Optimize edge cases.
// TODO Optimize index calculation.
// TODO Optimize arguments.
function blurX(source, target, r) {
  var n = source.width,
      m = source.height,
      w = (r << 1) + 1;
  for (var j = 0; j < m; ++j) {
    for (var i = 0, sr = 0; i < n + r; ++i) {
      if (i < n) {
        sr += source.data[i + j * n];
      }
      if (i >= r) {
        if (i >= w) {
          sr -= source.data[i - w + j * n];
        }
        target.data[i - r + j * n] = sr / Math.min(i + 1, n - 1 + w - i, w);
      }
    }
  }
}

// TODO Optimize edge cases.
// TODO Optimize index calculation.
// TODO Optimize arguments.
function blurY(source, target, r) {
  var n = source.width,
      m = source.height,
      w = (r << 1) + 1;
  for (var i = 0; i < n; ++i) {
    for (var j = 0, sr = 0; j < m + r; ++j) {
      if (j < m) {
        sr += source.data[i + j * n];
      }
      if (j >= r) {
        if (j >= w) {
          sr -= source.data[i + (j - w) * n];
        }
        target.data[i + (j - r) * n] = sr / Math.min(j + 1, m - 1 + w - j, w);
      }
    }
  }
}

function defaultX(d) {
  return d[0];
}

function defaultY(d) {
  return d[1];
}

function defaultWeight() {
  return 1;
}

function contourDensity() {
  var x = defaultX,
      y = defaultY,
      weight = defaultWeight,
      dx = 960,
      dy = 500,
      r = 20, // blur radius
      k = 2, // log2(grid cell size)
      o = r * 3, // grid offset, to pad for blur
      n = (dx + o * 2) >> k, // grid width
      m = (dy + o * 2) >> k, // grid height
      threshold = constant$8(20);

  function density(data) {
    var values0 = new Float32Array(n * m),
        values1 = new Float32Array(n * m);

    data.forEach(function(d, i, data) {
      var xi = (+x(d, i, data) + o) >> k,
          yi = (+y(d, i, data) + o) >> k,
          wi = +weight(d, i, data);
      if (xi >= 0 && xi < n && yi >= 0 && yi < m) {
        values0[xi + yi * n] += wi;
      }
    });

    // TODO Optimize.
    blurX({width: n, height: m, data: values0}, {width: n, height: m, data: values1}, r >> k);
    blurY({width: n, height: m, data: values1}, {width: n, height: m, data: values0}, r >> k);
    blurX({width: n, height: m, data: values0}, {width: n, height: m, data: values1}, r >> k);
    blurY({width: n, height: m, data: values1}, {width: n, height: m, data: values0}, r >> k);
    blurX({width: n, height: m, data: values0}, {width: n, height: m, data: values1}, r >> k);
    blurY({width: n, height: m, data: values1}, {width: n, height: m, data: values0}, r >> k);

    var tz = threshold(values0);

    // Convert number of thresholds into uniform thresholds.
    if (!Array.isArray(tz)) {
      var stop = max$4(values0);
      tz = tickStep$2(0, stop, tz);
      tz = range(0, Math.floor(stop / tz) * tz, tz);
      tz.shift();
    }

    return contours()
        .thresholds(tz)
        .size([n, m])
      (values0)
        .map(transform);
  }

  function transform(geometry) {
    geometry.value *= Math.pow(2, -2 * k); // Density in points per square pixel.
    geometry.coordinates.forEach(transformPolygon);
    return geometry;
  }

  function transformPolygon(coordinates) {
    coordinates.forEach(transformRing);
  }

  function transformRing(coordinates) {
    coordinates.forEach(transformPoint);
  }

  // TODO Optimize.
  function transformPoint(coordinates) {
    coordinates[0] = coordinates[0] * Math.pow(2, k) - o;
    coordinates[1] = coordinates[1] * Math.pow(2, k) - o;
  }

  function resize() {
    o = r * 3;
    n = (dx + o * 2) >> k;
    m = (dy + o * 2) >> k;
    return density;
  }

  density.x = function(_) {
    return arguments.length ? (x = typeof _ === "function" ? _ : constant$8(+_), density) : x;
  };

  density.y = function(_) {
    return arguments.length ? (y = typeof _ === "function" ? _ : constant$8(+_), density) : y;
  };

  density.weight = function(_) {
    return arguments.length ? (weight = typeof _ === "function" ? _ : constant$8(+_), density) : weight;
  };

  density.size = function(_) {
    if (!arguments.length) return [dx, dy];
    var _0 = Math.ceil(_[0]), _1 = Math.ceil(_[1]);
    if (!(_0 >= 0) && !(_0 >= 0)) throw new Error("invalid size");
    return dx = _0, dy = _1, resize();
  };

  density.cellSize = function(_) {
    if (!arguments.length) return 1 << k;
    if (!((_ = +_) >= 1)) throw new Error("invalid cell size");
    return k = Math.floor(Math.log(_) / Math.LN2), resize();
  };

  density.thresholds = function(_) {
    return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? constant$8(slice$5.call(_)) : constant$8(_), density) : threshold;
  };

  density.bandwidth = function(_) {
    if (!arguments.length) return Math.sqrt(r * (r + 1));
    if (!((_ = +_) >= 0)) throw new Error("invalid bandwidth");
    return r = Math.round((Math.sqrt(4 * _ * _ + 1) - 1) / 2), resize();
  };

  return density;
}

var polylabel_1 = polylabel;
var default_1$1 = polylabel;

function polylabel(polygon, precision, debug) {
    precision = precision || 1.0;

    // find the bounding box of the outer ring
    var minX, minY, maxX, maxY;
    for (var i = 0; i < polygon[0].length; i++) {
        var p = polygon[0][i];
        if (!i || p[0] < minX) minX = p[0];
        if (!i || p[1] < minY) minY = p[1];
        if (!i || p[0] > maxX) maxX = p[0];
        if (!i || p[1] > maxY) maxY = p[1];
    }

    var width = maxX - minX;
    var height = maxY - minY;
    var cellSize = Math.min(width, height);
    var h = cellSize / 2;

    // a priority queue of cells in order of their "potential" (max distance to polygon)
    var cellQueue = new tinyqueue(null, compareMax);

    if (cellSize === 0) return [minX, minY];

    // cover polygon with initial cells
    for (var x = minX; x < maxX; x += cellSize) {
        for (var y = minY; y < maxY; y += cellSize) {
            cellQueue.push(new Cell(x + h, y + h, h, polygon));
        }
    }

    // take centroid as the first best guess
    var bestCell = getCentroidCell(polygon);

    // special case for rectangular polygons
    var bboxCell = new Cell(minX + width / 2, minY + height / 2, 0, polygon);
    if (bboxCell.d > bestCell.d) bestCell = bboxCell;

    var numProbes = cellQueue.length;

    while (cellQueue.length) {
        // pick the most promising cell from the queue
        var cell = cellQueue.pop();

        // update the best cell if we found a better one
        if (cell.d > bestCell.d) {
            bestCell = cell;
            if (debug) console.log('found best %d after %d probes', Math.round(1e4 * cell.d) / 1e4, numProbes);
        }

        // do not drill down further if there's no chance of a better solution
        if (cell.max - bestCell.d <= precision) continue;

        // split the cell into four cells
        h = cell.h / 2;
        cellQueue.push(new Cell(cell.x - h, cell.y - h, h, polygon));
        cellQueue.push(new Cell(cell.x + h, cell.y - h, h, polygon));
        cellQueue.push(new Cell(cell.x - h, cell.y + h, h, polygon));
        cellQueue.push(new Cell(cell.x + h, cell.y + h, h, polygon));
        numProbes += 4;
    }

    if (debug) {
        console.log('num probes: ' + numProbes);
        console.log('best distance: ' + bestCell.d);
    }

    return [bestCell.x, bestCell.y];
}

function compareMax(a, b) {
    return b.max - a.max;
}

function Cell(x, y, h, polygon) {
    this.x = x; // cell center x
    this.y = y; // cell center y
    this.h = h; // half the cell size
    this.d = pointToPolygonDist(x, y, polygon); // distance from cell center to polygon
    this.max = this.d + this.h * Math.SQRT2; // max distance to polygon within a cell
}

// signed distance from point to polygon outline (negative if point is outside)
function pointToPolygonDist(x, y, polygon) {
    var inside = false;
    var minDistSq = Infinity;

    for (var k = 0; k < polygon.length; k++) {
        var ring = polygon[k];

        for (var i = 0, len = ring.length, j = len - 1; i < len; j = i++) {
            var a = ring[i];
            var b = ring[j];

            if ((a[1] > y !== b[1] > y) &&
                (x < (b[0] - a[0]) * (y - a[1]) / (b[1] - a[1]) + a[0])) inside = !inside;

            minDistSq = Math.min(minDistSq, getSegDistSq(x, y, a, b));
        }
    }

    return (inside ? 1 : -1) * Math.sqrt(minDistSq);
}

// get polygon centroid
function getCentroidCell(polygon) {
    var area = 0;
    var x = 0;
    var y = 0;
    var points = polygon[0];

    for (var i = 0, len = points.length, j = len - 1; i < len; j = i++) {
        var a = points[i];
        var b = points[j];
        var f = a[0] * b[1] - b[0] * a[1];
        x += (a[0] + b[0]) * f;
        y += (a[1] + b[1]) * f;
        area += f * 3;
    }
    if (area === 0) return new Cell(points[0][0], points[0][1], 0, polygon);
    return new Cell(x / area, y / area, 0, polygon);
}

// get squared distance from a point to a segment
function getSegDistSq(px, py, a, b) {

    var x = a[0];
    var y = a[1];
    var dx = b[0] - x;
    var dy = b[1] - y;

    if (dx !== 0 || dy !== 0) {

        var t = ((px - x) * dx + (py - y) * dy) / (dx * dx + dy * dy);

        if (t > 1) {
            x = b[0];
            y = b[1];

        } else if (t > 0) {
            x += dx * t;
            y += dy * t;
        }
    }

    dx = px - x;
    dy = py - y;

    return dx * dx + dy * dy;
}
polylabel_1.default = default_1$1;

const shapeBounds$1 = coordinates => {
  let left = [Infinity, 0];
  let right = [-Infinity, 0];
  let top = [0, Infinity];
  let bottom = [0, -Infinity];
  coordinates.forEach(d => {
    left = d[0] < left[0] ? d : left;
    right = d[0] > right[0] ? d : right;
    bottom = d[1] > bottom[1] ? d : bottom;
    top = d[1] < top[1] ? d : top;
  });
  return {
    center: polylabel_1([coordinates]),
    top,
    left,
    right,
    bottom
  };
};

const contouringProjection = ({
  threshold,
  resolution,
  bandWidth,
  neighborhood,
  frameXScale,
  frameYScale,
  data,
  xAccessor,
  yAccessor,
  sAccessor,
  showPoints
}) => {
  let projectedAreas = [];
  const {
    groupedData,
    projectedPoints
  } = groupData({
    data,
    xAccessor,
    yAccessor,
    sAccessor,
    showPoints
  });
  const xScale = linear$1().domain(frameXScale.domain()).rangeRound([0, resolution]).nice();
  const yScale = linear$1().domain(frameYScale.domain()).rangeRound([resolution, 0]).nice();
  groupedData.forEach(contourData => {
    let contourProjectedAreas = contourDensity().size([resolution, resolution]).x(d => xScale(d.x)).y(d => yScale(d.y)).thresholds(threshold).bandwidth(bandWidth)(contourData._xyCoordinates);

    if (neighborhood) {
      contourProjectedAreas = [contourProjectedAreas[0]];
    }

    const max = Math.max(...contourProjectedAreas.map(d => d.value));
    contourProjectedAreas.forEach((area, i) => {
      area._data = contourData._baseData[i];
      area.parentSummary = contourData;
      area.bounds = [];
      area.percent = area.value / max;
      area.coordinates.forEach(poly => {
        poly.forEach((subpoly, i) => {
          poly[i] = subpoly.map(coordpair => {
            coordpair = [xScale.invert(coordpair[0]), yScale.invert(coordpair[1])];
            return coordpair;
          }); //Only push bounds for the main poly, not its interior rings, otherwise you end up labeling interior cutouts

          if (i === 0) {
            area.bounds.push(shapeBounds$1(poly[i]));
          }
        });
      });
    });
    projectedAreas = [...projectedAreas, ...contourProjectedAreas];
  });
  return {
    projectedAreas,
    projectedPoints,
    projectedLines: []
  };
};

const Contour = props => {
  return React$1__default.createElement(Plot, props);
};

Contour.propTypes = { ...Plot.propTypes,
  resolution: propTypes.number,
  threshold: propTypes.number,
  bandWidth: propTypes.number,
  neighborhood: propTypes.bool
};
Contour.defaultProps = { ...Plot.defaultProps,
  resolution: 500,
  threshold: 10,
  bandWidth: 20,
  projection: contouringProjection
};

const heatmapProjection = ({
  xBins,
  yBins,
  xCellPx,
  yCellPx,
  binMax,
  binValue,
  customMark,
  frameXScale,
  frameYScale,
  adjustedSize,
  data,
  xAccessor,
  yAccessor,
  sAccessor,
  showPoints
}) => {
  let projectedAreas = [];
  const {
    groupedData,
    projectedPoints
  } = groupData({
    data,
    xAccessor,
    yAccessor,
    sAccessor,
    showPoints
  });
  const size = adjustedSize;
  const xBinPercent = xBins < 1 ? xBins : 1 / xBins;
  const yBinPercent = yBins < 1 ? yBins : 1 / yBins;
  const heatmapBinXScale = linear$1().domain(frameXScale.domain()).range([0, size[0]]);
  const heatmapBinYScale = linear$1().domain(frameYScale.domain()).range([size[1], 0]);
  const actualResolution = [Math.ceil((xCellPx && xCellPx / size[0] || xBinPercent) * size[0] * 10) / 10, Math.ceil((yCellPx && yCellPx / size[1] || yBinPercent) * size[1] * 10) / 10];
  let maxValue = -Infinity;
  groupedData.forEach(heatmapData => {
    const grid = [];
    const flatGrid = [];
    let cell;
    let gridColumn;

    for (let i = 0; i < size[0]; i += actualResolution[0]) {
      const x = heatmapBinXScale.invert(i);
      const x1 = heatmapBinXScale.invert(i + actualResolution[0]);
      gridColumn = [];
      grid.push(gridColumn);

      for (let j = 0; j < size[1]; j += actualResolution[1]) {
        const y = heatmapBinYScale.invert(j);
        const y1 = heatmapBinYScale.invert(j + actualResolution[1]);
        cell = {
          gx: i,
          gy: j,
          gw: actualResolution[0],
          gh: actualResolution[1],
          x: (x + x1) / 2,
          y: (y + y1) / 2,
          binItems: [],
          value: 0,
          _xyCoordinates: [[x, y], [x1, y], [x1, y1], [x, y1]],
          parentSummary: heatmapData
        };
        gridColumn.push(cell);
        flatGrid.push(cell);
      }

      gridColumn.push(cell);
    }

    grid.push(gridColumn);

    heatmapData._xyCoordinates.forEach((d, di) => {
      const xCoordinate = Math.floor(heatmapBinXScale(d.x) / actualResolution[0]);
      const yCoordinate = Math.floor(heatmapBinYScale(d.y) / actualResolution[1]);
      grid[xCoordinate][yCoordinate].binItems.push(heatmapData._baseData[di]);
    });

    flatGrid.forEach(d => {
      d.value = binValue(d.binItems);
      maxValue = Math.max(maxValue, d.value);
    });
    flatGrid.forEach(d => {
      d.percent = d.value / maxValue;
      d.customMark = customMark && React.createElement("g", {
        transform: `translate(${d.gx},${d.gy})`
      }, customMark({
        d,
        baseMarkProps,
        margin,
        styleFn,
        classFn,
        renderFn,
        chartSize,
        adjustedSize: size
      }));
    });
    projectedAreas = [...projectedAreas, ...flatGrid];
  });

  if (binMax) {
    binMax(maxValue);
  }

  return {
    projectedAreas,
    projectedPoints,
    projectedLines: []
  };
};

const Heatmap = props => {
  return React$1__default.createElement(Plot, props);
};

Heatmap.propTypes = { ...Plot.propTypes,
  cellPx: propTypes.number,
  xBins: propTypes.number,
  yBins: propTypes.number,
  xCellPx: propTypes.number,
  yCellPx: propTypes.number,
  binMax: propTypes.number,
  binValue: propTypes.func
};
Heatmap.defaultProps = { ...Plot.defaultProps,
  binValue: d => d.length,
  xBins: 0.05,
  yBins: 0.05,
  projection: heatmapProjection
};

const datesForUnique = d => d instanceof Date ? d.getTime() : d;

const stackedArea = ({
  type = 'stackedarea',
  data,
  sort
}) => {
  const uniqXValues = data.map(d => d._xyCoordinates.map(p => datesForUnique(p.x))).reduce((a, b) => a.concat(b), []).reduce((p, c) => {
    if (p.indexOf(c) === -1) {
      p.push(c);
    }

    return p;
  }, []);

  let stackSort = (a, b) => sum(b._xyCoordinates.map(p => p.y)) - sum(a._xyCoordinates.map(p => p.y));

  if (type === 'stackedpercent-invert' || type === 'stackedarea-invert') {
    stackSort = (a, b) => sum(a._xyCoordinates.map(p => p.y)) - sum(b._xyCoordinates.map(p => p.y));
  }

  sort = sort === undefined ? stackSort : sort;

  if (sort !== null) {
    data = data.sort(sort);
  }

  uniqXValues.forEach(xValue => {
    let negativeOffset = 0;
    let positiveOffset = 0;
    const stepValues = data.map(d => d._xyCoordinates.filter(p => datesForUnique(p.x) === xValue)).reduce((a, b) => a.concat(b), []);
    const positiveStepTotal = sum(stepValues.map(d => d.y > 0 ? d.y : 0));
    const negativeStepTotal = sum(stepValues.map(d => d.y < 0 ? d.y : 0));
    stepValues.forEach(l => {
      if (l.y < 0) {
        if (type === 'linepercent' || type === 'stackedpercent' || type === 'stackedpercent-invert') {
          const percent = l.y / negativeStepTotal;
          l.percent = percent;

          if (type === 'linepercent') {
            l.yBottom = l.yBottom = l.yTop = l.yMiddle = percent;
          } else {
            const adjustment = negativeStepTotal >= 0 ? 0 : percent;
            l.yBottom = negativeStepTotal === 0 ? 0 : -(negativeOffset / negativeStepTotal);
            l.yTop = l.yBottom - adjustment;
            l.yMiddle = l.yBottom - adjustment / 2;
          }
        } else {
          l.yBottom = negativeOffset;
          l.yTop = negativeOffset + l.y;
          l.yMiddle = negativeOffset + l.y / 2;
        }

        negativeOffset += l.y;
      } else {
        if (type === 'linepercent' || type === 'stackedpercent' || type === 'stackedpercent-invert') {
          const percent = l.y / positiveStepTotal;
          l.percent = percent;

          if (type === 'linepercent') {
            l.yBottom = l.yTop = l.yMiddle = percent;
          } else {
            const adjustment = positiveStepTotal <= 0 ? 0 : percent;
            l.yBottom = positiveStepTotal === 0 ? 0 : positiveOffset / positiveStepTotal;
            l.yTop = l.yBottom + adjustment;
            l.yMiddle = l.yBottom + adjustment / 2;
          }
        } else {
          l.yBottom = positiveOffset;
          l.yTop = positiveOffset + l.y;
          l.yMiddle = positiveOffset + l.y / 2;
        }

        positiveOffset += l.y;
      }
    });
  });
  return data;
};

const differenceLine = ({
  data
}) => {
  data.forEach((l, i) => {
    l._xyCoordinates.forEach((point, q) => {
      const otherLine = i === 0 ? 1 : 0;

      if (point.y > data[otherLine]._xyCoordinates[q].y) {
        point.yBottom = data[otherLine]._xyCoordinates[q].y;
        point.yTop = point.y;
      } else {
        point.yTop = point.y;
        point.yBottom = point.y;
      }
    });
  });
  return data;
};

const datesForUnique$1 = d => d instanceof Date ? d.getTime() : d;

const bumpline = ({
  type = 'bumpline',
  data
}) => {
  const uniqXValues = data.map(d => d._xyCoordinates.map(p => datesForUnique$1(p.x))).reduce((a, b) => a.concat(b), []).reduce((p, c) => {
    if (p.indexOf(c) === -1) {
      p.push(c);
    }

    return p;
  }, []);

  let bumpSort = (a, b) => {
    if (a.y > b.y) {
      return 1;
    }

    if (a.y < b.y) {
      return -1;
    }

    return -1;
  };

  if (type === 'bumparea-invert' || type === 'bumpline-invert') {
    bumpSort = (a, b) => {
      if (a.y < b.y) {
        return 1;
      }

      if (a.y > b.y) {
        return -1;
      }

      return -1;
    };
  }

  uniqXValues.forEach(xValue => {
    let negativeOffset = 0;
    let positiveOffset = 0;
    data.map(d => d._xyCoordinates.filter(p => datesForUnique$1(p.x) === xValue)).reduce((a, b) => a.concat(b), []).sort(bumpSort).forEach((l, rank) => {
      //determine ranking and offset by the number of less than this one at each step
      l._XYFrameRank = rank + 1;

      if (type === 'bumparea' || type === 'bumparea-invert') {
        if (l.y < 0) {
          l.y = negativeOffset + l.y;
          l.yMiddle = negativeOffset + l.y / 2;
          l.yBottom = negativeOffset;
          negativeOffset += l.y;
        } else {
          l.yTop = positiveOffset + l.y;
          l.yMiddle = positiveOffset + l.y / 2;
          l.yBottom = positiveOffset;
          positiveOffset += l.y;
        }
      } else {
        l.y = rank + 1;
        l.yTop = rank + 1;
        l.yBottom = rank + 1;
      }
    });
  });
  return data;
};

const line$2 = ({
  data,
  y1,
  yPropTop,
  yPropMiddle,
  yPropBottom
}) => {
  if (y1) {
    data.forEach(d => {
      d.data.forEach(p => {
        p[yPropBottom] = y1(p);
        p[yPropMiddle] = p[yPropBottom] + p[yPropTop] / 2;
      });
    });
  }

  return data;
};

const cumulativeLine = ({
  data,
  type = 'cumulative'
}) => {
  data.forEach(d => {
    let cumulativeValue = 0;
    const dataArray = type === 'cumulative-reverse' ? d._xyCoordinates.reverse() : d._xyCoordinates;
    dataArray.forEach(p => {
      cumulativeValue += p.yTop;
      p.yBottom = p.yTop = p.yMiddle = cumulativeValue;
    });
  });
  return data;
};

const objectifyType = type => {
  if (type instanceof Function || typeof type === 'string') {
    return {
      type: type
    };
  } else if (type === undefined) {
    return {};
  }

  return type;
};

const differenceCatch = (olineType, data) => olineType === 'difference' && data.length !== 2 ? 'line' : olineType;

const builtInTransformations = {
  stackedarea: stackedArea,
  'stackedarea-invert': stackedArea,
  stackedpercent: stackedArea,
  'stackedpercent-invert': stackedArea,
  linepercent: stackedArea,
  difference: differenceLine,
  bumparea: bumpline,
  bumpline: bumpline,
  'bumparea-invert': bumpline,
  line: line$2,
  area: line$2,
  cumulative: cumulativeLine,
  'cumulative-reverse': cumulativeLine
};

const lineTransformation = lineType => data => builtInTransformations[differenceCatch(lineType.type, data)]({ ...lineType,
  data
});

const lineProjection = ({
  data,
  xAccessor,
  yAccessor,
  sAccessor,
  showPoints,
  lineType: userType
}) => {
  const {
    groupedData,
    projectedPoints
  } = groupData({
    data,
    xAccessor,
    yAccessor,
    sAccessor,
    showPoints
  });
  const lineType = objectifyType(userType);
  const projectedLines = lineTransformation(lineType)(groupedData.slice());
  return {
    projectedLines,
    projectedAreas: [],
    projectedPoints
  };
};

const Line = props => {
  return React$1__default.createElement(Plot, props);
};

Line.propTypes = { ...Plot.propTypes,
  // lineType: PropTypes.oneOf([
  //   'stackedarea',
  //   'stackedarea-invert',
  //   'stackedpercent',
  //   'stackedpercent-invert',
  //   'linepercent',
  //   'difference',
  //   'bumparea',
  //   'bumpline',
  //   'bumparea-invert',
  //   'line',
  //   'area',
  //   'cumulative',
  //   'cumulative-reverse'
  // ]),
  simpleLine: propTypes.bool
};
Line.defaultProps = { ...Plot.defaultProps,
  lineType: 'line',
  projection: lineProjection
};

const scatterProjection = ({
  data,
  xAccessor,
  yAccessor,
  sAccessor
}) => {
  const {
    groupedData,
    projectedPoints
  } = groupData({
    data,
    xAccessor,
    yAccessor,
    sAccessor,
    showPoints: true
  });
  return {
    projectedLines: [],
    projectedAreas: [],
    projectedPoints
  };
};

const Scatter = props => {
  return React$1__default.createElement(Plot, props);
};

Scatter.propTypes = { ...Plot.propTypes
};
Scatter.defaultProps = { ...Plot.defaultProps,
  projection: scatterProjection
};

var regression = createCommonjsModule(function (module, exports) {
(function (global, factory) {
  {
    factory(module);
  }
})(commonjsGlobal, function (module) {

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  var _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  function _toConsumableArray(arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
        arr2[i] = arr[i];
      }

      return arr2;
    } else {
      return Array.from(arr);
    }
  }

  var DEFAULT_OPTIONS = { order: 2, precision: 2, period: null };

  /**
  * Determine the coefficient of determination (r^2) of a fit from the observations
  * and predictions.
  *
  * @param {Array<Array<number>>} data - Pairs of observed x-y values
  * @param {Array<Array<number>>} results - Pairs of observed predicted x-y values
  *
  * @return {number} - The r^2 value, or NaN if one cannot be calculated.
  */
  function determinationCoefficient(data, results) {
    var predictions = [];
    var observations = [];

    data.forEach(function (d, i) {
      if (d[1] !== null) {
        observations.push(d);
        predictions.push(results[i]);
      }
    });

    var sum = observations.reduce(function (a, observation) {
      return a + observation[1];
    }, 0);
    var mean = sum / observations.length;

    var ssyy = observations.reduce(function (a, observation) {
      var difference = observation[1] - mean;
      return a + difference * difference;
    }, 0);

    var sse = observations.reduce(function (accum, observation, index) {
      var prediction = predictions[index];
      var residual = observation[1] - prediction[1];
      return accum + residual * residual;
    }, 0);

    return 1 - sse / ssyy;
  }

  /**
  * Determine the solution of a system of linear equations A * x = b using
  * Gaussian elimination.
  *
  * @param {Array<Array<number>>} input - A 2-d matrix of data in row-major form [ A | b ]
  * @param {number} order - How many degrees to solve for
  *
  * @return {Array<number>} - Vector of normalized solution coefficients matrix (x)
  */
  function gaussianElimination(input, order) {
    var matrix = input;
    var n = input.length - 1;
    var coefficients = [order];

    for (var i = 0; i < n; i++) {
      var maxrow = i;
      for (var j = i + 1; j < n; j++) {
        if (Math.abs(matrix[i][j]) > Math.abs(matrix[i][maxrow])) {
          maxrow = j;
        }
      }

      for (var k = i; k < n + 1; k++) {
        var tmp = matrix[k][i];
        matrix[k][i] = matrix[k][maxrow];
        matrix[k][maxrow] = tmp;
      }

      for (var _j = i + 1; _j < n; _j++) {
        for (var _k = n; _k >= i; _k--) {
          matrix[_k][_j] -= matrix[_k][i] * matrix[i][_j] / matrix[i][i];
        }
      }
    }

    for (var _j2 = n - 1; _j2 >= 0; _j2--) {
      var total = 0;
      for (var _k2 = _j2 + 1; _k2 < n; _k2++) {
        total += matrix[_k2][_j2] * coefficients[_k2];
      }

      coefficients[_j2] = (matrix[n][_j2] - total) / matrix[_j2][_j2];
    }

    return coefficients;
  }

  /**
  * Round a number to a precision, specificed in number of decimal places
  *
  * @param {number} number - The number to round
  * @param {number} precision - The number of decimal places to round to:
  *                             > 0 means decimals, < 0 means powers of 10
  *
  *
  * @return {numbr} - The number, rounded
  */
  function round(number, precision) {
    var factor = Math.pow(10, precision);
    return Math.round(number * factor) / factor;
  }

  /**
  * The set of all fitting methods
  *
  * @namespace
  */
  var methods = {
    linear: function linear(data, options) {
      var sum = [0, 0, 0, 0, 0];
      var len = 0;

      for (var n = 0; n < data.length; n++) {
        if (data[n][1] !== null) {
          len++;
          sum[0] += data[n][0];
          sum[1] += data[n][1];
          sum[2] += data[n][0] * data[n][0];
          sum[3] += data[n][0] * data[n][1];
          sum[4] += data[n][1] * data[n][1];
        }
      }

      var run = len * sum[2] - sum[0] * sum[0];
      var rise = len * sum[3] - sum[0] * sum[1];
      var gradient = run === 0 ? 0 : round(rise / run, options.precision);
      var intercept = round(sum[1] / len - gradient * sum[0] / len, options.precision);

      var predict = function predict(x) {
        return [round(x, options.precision), round(gradient * x + intercept, options.precision)];
      };

      var points = data.map(function (point) {
        return predict(point[0]);
      });

      return {
        points: points,
        predict: predict,
        equation: [gradient, intercept],
        r2: round(determinationCoefficient(data, points), options.precision),
        string: intercept === 0 ? 'y = ' + gradient + 'x' : 'y = ' + gradient + 'x + ' + intercept
      };
    },
    exponential: function exponential(data, options) {
      var sum = [0, 0, 0, 0, 0, 0];

      for (var n = 0; n < data.length; n++) {
        if (data[n][1] !== null) {
          sum[0] += data[n][0];
          sum[1] += data[n][1];
          sum[2] += data[n][0] * data[n][0] * data[n][1];
          sum[3] += data[n][1] * Math.log(data[n][1]);
          sum[4] += data[n][0] * data[n][1] * Math.log(data[n][1]);
          sum[5] += data[n][0] * data[n][1];
        }
      }

      var denominator = sum[1] * sum[2] - sum[5] * sum[5];
      var a = Math.exp((sum[2] * sum[3] - sum[5] * sum[4]) / denominator);
      var b = (sum[1] * sum[4] - sum[5] * sum[3]) / denominator;
      var coeffA = round(a, options.precision);
      var coeffB = round(b, options.precision);
      var predict = function predict(x) {
        return [round(x, options.precision), round(coeffA * Math.exp(coeffB * x), options.precision)];
      };

      var points = data.map(function (point) {
        return predict(point[0]);
      });

      return {
        points: points,
        predict: predict,
        equation: [coeffA, coeffB],
        string: 'y = ' + coeffA + 'e^(' + coeffB + 'x)',
        r2: round(determinationCoefficient(data, points), options.precision)
      };
    },
    logarithmic: function logarithmic(data, options) {
      var sum = [0, 0, 0, 0];
      var len = data.length;

      for (var n = 0; n < len; n++) {
        if (data[n][1] !== null) {
          sum[0] += Math.log(data[n][0]);
          sum[1] += data[n][1] * Math.log(data[n][0]);
          sum[2] += data[n][1];
          sum[3] += Math.pow(Math.log(data[n][0]), 2);
        }
      }

      var a = (len * sum[1] - sum[2] * sum[0]) / (len * sum[3] - sum[0] * sum[0]);
      var coeffB = round(a, options.precision);
      var coeffA = round((sum[2] - coeffB * sum[0]) / len, options.precision);

      var predict = function predict(x) {
        return [round(x, options.precision), round(round(coeffA + coeffB * Math.log(x), options.precision), options.precision)];
      };

      var points = data.map(function (point) {
        return predict(point[0]);
      });

      return {
        points: points,
        predict: predict,
        equation: [coeffA, coeffB],
        string: 'y = ' + coeffA + ' + ' + coeffB + ' ln(x)',
        r2: round(determinationCoefficient(data, points), options.precision)
      };
    },
    power: function power(data, options) {
      var sum = [0, 0, 0, 0, 0];
      var len = data.length;

      for (var n = 0; n < len; n++) {
        if (data[n][1] !== null) {
          sum[0] += Math.log(data[n][0]);
          sum[1] += Math.log(data[n][1]) * Math.log(data[n][0]);
          sum[2] += Math.log(data[n][1]);
          sum[3] += Math.pow(Math.log(data[n][0]), 2);
        }
      }

      var b = (len * sum[1] - sum[0] * sum[2]) / (len * sum[3] - Math.pow(sum[0], 2));
      var a = (sum[2] - b * sum[0]) / len;
      var coeffA = round(Math.exp(a), options.precision);
      var coeffB = round(b, options.precision);

      var predict = function predict(x) {
        return [round(x, options.precision), round(round(coeffA * Math.pow(x, coeffB), options.precision), options.precision)];
      };

      var points = data.map(function (point) {
        return predict(point[0]);
      });

      return {
        points: points,
        predict: predict,
        equation: [coeffA, coeffB],
        string: 'y = ' + coeffA + 'x^' + coeffB,
        r2: round(determinationCoefficient(data, points), options.precision)
      };
    },
    polynomial: function polynomial(data, options) {
      var lhs = [];
      var rhs = [];
      var a = 0;
      var b = 0;
      var len = data.length;
      var k = options.order + 1;

      for (var i = 0; i < k; i++) {
        for (var l = 0; l < len; l++) {
          if (data[l][1] !== null) {
            a += Math.pow(data[l][0], i) * data[l][1];
          }
        }

        lhs.push(a);
        a = 0;

        var c = [];
        for (var j = 0; j < k; j++) {
          for (var _l = 0; _l < len; _l++) {
            if (data[_l][1] !== null) {
              b += Math.pow(data[_l][0], i + j);
            }
          }
          c.push(b);
          b = 0;
        }
        rhs.push(c);
      }
      rhs.push(lhs);

      var coefficients = gaussianElimination(rhs, k).map(function (v) {
        return round(v, options.precision);
      });

      var predict = function predict(x) {
        return [round(x, options.precision), round(coefficients.reduce(function (sum, coeff, power) {
          return sum + coeff * Math.pow(x, power);
        }, 0), options.precision)];
      };

      var points = data.map(function (point) {
        return predict(point[0]);
      });

      var string = 'y = ';
      for (var _i = coefficients.length - 1; _i >= 0; _i--) {
        if (_i > 1) {
          string += coefficients[_i] + 'x^' + _i + ' + ';
        } else if (_i === 1) {
          string += coefficients[_i] + 'x + ';
        } else {
          string += coefficients[_i];
        }
      }

      return {
        string: string,
        points: points,
        predict: predict,
        equation: [].concat(_toConsumableArray(coefficients)).reverse(),
        r2: round(determinationCoefficient(data, points), options.precision)
      };
    }
  };

  function createWrapper() {
    var reduce = function reduce(accumulator, name) {
      return _extends({
        _round: round
      }, accumulator, _defineProperty({}, name, function (data, supplied) {
        return methods[name](data, _extends({}, DEFAULT_OPTIONS, supplied));
      }));
    };

    return Object.keys(methods).reduce(reduce, {});
  }

  module.exports = createWrapper();
});
});

const trendliningProjection = ({
  regressionType: baseRegressionType,
  order,
  precision,
  controlPoints,
  curve,
  frameXScale,
  xScaleType = linear$1(),
  data,
  xAccessor,
  yAccessor,
  sAccessor,
  showPoints
}) => {
  let regressionType = baseRegressionType;

  if (frameXScale.domain()[0] < 0 && (baseRegressionType === 'logarithmic' || baseRegressionType === 'power' || baseRegressionType === 'exponential')) {
    console.error(`Cannot use this ${baseRegressionType} regressionType type with value range that goes below 0, defaulting to linear`);
    regressionType = 'linear';
  }

  let projectedAreas = [];
  const {
    groupedData,
    projectedPoints
  } = groupData({
    data,
    xAccessor,
    yAccessor,
    sAccessor,
    showPoints
  });
  const xScale = xScaleType.domain([0, 1]).range(frameXScale.domain());
  groupedData.forEach(bdata => {
    const regressionLine = regression[regressionType](bdata._xyCoordinates.map(d => [d.x.getTime ? d.x.getTime() : d.x, d.y.getTime ? d.y.getTime() : d.y]), {
      order,
      precision
    });
    const controlStep = 1 / controlPoints;
    let steps = [0, 1];

    if (regressionType !== 'linear') {
      steps = [];

      for (let step = 0; step < 1 + controlStep; step += controlStep) {
        steps.push(step);
      }
    }

    const controlPointArray = [];
    steps.forEach(controlPoint => {
      controlPointArray.push(regressionLine.predict(xScale(controlPoint)));
    });
    projectedAreas.push({
      centroid: false,
      customMark: undefined,
      data: bdata,
      parentSummary: bdata,
      value: regressionLine.string,
      r2: regressionLine.r2,
      curve,
      _xyCoordinates: controlPointArray
    });
  });
  return {
    projectedAreas,
    projectedPoints,
    projectedLines: []
  };
};

const Trendline = props => {
  return React$1__default.createElement(Plot, props);
};

Trendline.propTypes = { ...Plot.propTypes,
  regressionType: propTypes.oneOf(['logarithmic', 'power', 'polynomial', 'exponential', 'linear']),
  order: propTypes.number,
  precision: propTypes.number,
  controlPoints: propTypes.number,
  curve: propTypes.func
};
Trendline.defaultProps = { ...Plot.defaultProps,
  regressionType: 'linear',
  order: 2,
  precision: 4,
  controlPoints: 20,
  curve: curveCardinal,
  projection: trendliningProjection
};

const OrdinalPlot = props => {
  return null;
};

OrdinalPlot.propTypes = {
  customMark: propTypes.func,
  data: propTypes.array,
  // common
  columns: propTypes.object,
  rScaleType: propTypes.func,
  oScaleType: propTypes.func,
  rAccessor: propTypes.oneOfType([propTypes.array, propTypes.string, propTypes.object, propTypes.func]),
  oAccessor: propTypes.oneOfType([propTypes.array, propTypes.string, propTypes.object, propTypes.func]),
  invertR: propTypes.bool,
  oPadding: propTypes.number,
  oSort: propTypes.func,
  dynamicColumnWidth: propTypes.oneOfType([propTypes.string, propTypes.func]),
  pixelColumnWidth: propTypes.number,
  projection: propTypes.oneOf(['vertical', 'horizontal', 'radial']),
  baseOExtent: propTypes.array,
  baseMarkProps: propTypes.oneOfType([propTypes.object, propTypes.func]),
  // pieces
  type: propTypes.oneOfType([propTypes.string, propTypes.object, propTypes.func]),
  renderOrder: propTypes.array,
  renderKey: propTypes.oneOfType([propTypes.object, propTypes.string, propTypes.func]),
  style: propTypes.oneOfType([propTypes.object, propTypes.func]),
  pieceClass: propTypes.oneOfType([propTypes.string, propTypes.func]),
  pieceRenderMode: propTypes.oneOfType([propTypes.string, propTypes.object, propTypes.func]),
  pieceUseCanvas: propTypes.bool,
  pieceHoverAnnotation: propTypes.bool,
  // connectors
  connectorType: propTypes.oneOfType([propTypes.string, propTypes.func]),
  connectorStyle: propTypes.oneOfType([propTypes.object, propTypes.func]),
  connectorRenderMode: propTypes.oneOfType([propTypes.string, propTypes.object, propTypes.func]),
  connectorUseCanvas: propTypes.bool,
  // summaries
  summaryType: propTypes.oneOfType([propTypes.string, propTypes.object, propTypes.func]),
  summaryStyle: propTypes.oneOfType([propTypes.object, propTypes.func]),
  summaryClass: propTypes.oneOfType([propTypes.string, propTypes.func]),
  summaryPosition: propTypes.func,
  summaryRenderMode: propTypes.oneOfType([propTypes.string, propTypes.object, propTypes.func]),
  summaryUseCanvas: propTypes.bool
};
OrdinalPlot.defaultProps = {
  data: [],
  oScaleType: band(),
  rScaleType: linear$1(),
  projection: 'vertical',
  type: 'none',
  connectorUseCanvas: true,
  pieceUseCanvas: false,
  summaryUseCanvas: false,
  optimizeCustomTooltipPosition: false,
  invertR: false
};

const arcTweener = (oldProps, newProps) => {
  const innerRadiusInterpolator = interpolateNumber(oldProps.innerRadius, newProps.innerRadius);
  const outerRadiusInterpolator = interpolateNumber(oldProps.outerRadius, newProps.outerRadius);
  const startAngleInterpolator = interpolateNumber(oldProps.startAngle, newProps.startAngle);
  const endAngleInterpolator = interpolateNumber(oldProps.endAngle, newProps.endAngle);
  return t => {
    const sliceGenerator = arc$2().innerRadius(innerRadiusInterpolator(t)).outerRadius(outerRadiusInterpolator(t));
    return sliceGenerator({
      startAngle: startAngleInterpolator(t),
      endAngle: endAngleInterpolator(t)
    });
  };
};

const twoPI$1 = Math.PI * 2;

const radialBarFeatureGenerator = ({
  innerRadius,
  offsetAngle = 0,
  angleRange = [0, 360],
  ordset,
  isClusterBar = false,
  isTimeline = false,
  adjustedSize,
  piece,
  i
}) => {
  const offsetPct = offsetAngle / 360;
  const rangePct = angleRange.map(d => d / 360);
  const rangeMod = rangePct[1] - rangePct[0];
  const adjustedPct = rangeMod < 1 ? linear$1().domain([0, 1]).range(rangePct) : d => d;
  let innerSize = isClusterBar ? 0 : isTimeline ? piece.scaledValue / 2 : piece.bottom / 2;
  let outerSize = isClusterBar ? piece.scaledValue / 2 : isTimeline ? piece.scaledEndValue / 2 : piece.scaledValue / 2 + piece.bottom / 2;

  if (innerRadius) {
    innerRadius = parseInt(innerRadius, 10);
    const canvasRadius = adjustedSize[0] / 2;
    const donutMod = (canvasRadius - innerRadius) / canvasRadius;
    innerSize = innerSize * donutMod + innerRadius;
    outerSize = outerSize * donutMod + innerRadius;
  }

  const arcGenerator = arc$2().innerRadius(innerSize).outerRadius(outerSize);
  const angle = (isClusterBar ? (ordset.pct - ordset.pct_padding) / ordset.pieceData.length : ordset.pct) * rangeMod;
  const startAngle = adjustedPct(isClusterBar ? ordset.pct_start + i / ordset.pieceData.length * (ordset.pct - ordset.pct_padding) : ordset.pct === 1 ? 0 : ordset.pct_start + offsetPct);
  const endAngle = ordset.pct === 1 ? rangePct[1] : Math.max(startAngle, startAngle + angle - ordset.pct_padding / 2);
  const startAngleFinal = startAngle * twoPI$1;
  const endAngleFinal = endAngle * twoPI$1;
  const markD = arcGenerator({
    startAngle: startAngleFinal,
    endAngle: endAngleFinal
  });
  const centroid = arcGenerator.centroid({
    startAngle: startAngleFinal,
    endAngle: endAngleFinal
  });
  const xOffset = adjustedSize[0] / 2;
  const yOffset = adjustedSize[1] / 2;
  const xPosition = centroid[0] + xOffset;
  const yPosition = centroid[1] + yOffset;
  const outerPoint = pointOnArcAtAngle([0, 0], (startAngle + endAngle) / 2, piece.scaledValue / 2);
  const xy = {
    arcGenerator: arcGenerator,
    startAngle: startAngleFinal,
    endAngle: endAngleFinal,
    dx: outerPoint[0],
    dy: outerPoint[1]
  };
  const translate = `translate(${xOffset},${yOffset})`;
  return {
    xPosition,
    yPosition,
    xy,
    translate,
    markProps: {
      markType: 'path',
      d: markD,
      tx: xOffset,
      ty: yOffset,
      transform: translate,
      customTween: {
        fn: arcTweener,
        props: {
          startAngle: startAngleFinal,
          endAngle: endAngleFinal,
          innerRadius: innerSize,
          outerRadius: outerSize
        }
      }
    }
  };
};

const clusterRadialBarFeatureGenerator = props => radialBarFeatureGenerator({ ...props,
  isClusterBar: true
});

const timelineRadialBarFeatureGenerator = props => radialBarFeatureGenerator({ ...props,
  isTimeline: true
});

const timelineLayout = ({
  customMark,
  innerRadius,
  offsetAngle,
  angleRange,
  data,
  renderMode,
  eventListenersGenerator,
  styleFn,
  projection,
  classFn,
  adjustedSize,
  chartSize,
  margin,
  baseMarkProps,
  rScale
}) => {
  let allCalculatedPieces = [];
  const keys = Object.keys(data);
  keys.forEach((key, ordsetI) => {
    const ordset = data[key];
    const calculatedPieces = [];
    ordset.pieceData.forEach((piece, i) => {
      const renderValue = renderMode && renderMode(piece.data, i);
      let xPosition = ordset.x;
      let height = piece.scaledEndValue - piece.scaledValue;
      let yPosition = piece.scaledVerticalValue - height;
      let width = ordset.width;
      let markProps = {
        markType: 'rect',
        height: height < 0 ? -height : height,
        width,
        x: xPosition,
        y: height < 0 ? yPosition + height : yPosition
      };

      if (projection === 'horizontal') {
        yPosition = ordset.x;
        xPosition = piece.scaledValue;
        width = piece.scaledEndValue - piece.scaledValue;
        height = ordset.width;
        markProps = {
          markType: 'rect',
          height,
          width: width < 0 ? -width : width,
          x: width < 0 ? xPosition + width : xPosition,
          y: yPosition
        };
      } else if (projection === 'radial') {
        ({
          markProps
        } = timelineRadialBarFeatureGenerator({
          innerRadius,
          offsetAngle,
          angleRange,
          piece,
          ordset,
          adjustedSize,
          i
        }));
      } //Only return the actual piece if you're rendering points, otherwise you just needed to iterate and calculate the points for the contour summary type


      const eventListeners = eventListenersGenerator(piece, i);
      const xy = {
        x: xPosition,
        y: yPosition,
        height
      };
      const renderElementObject = customMark ? React$1.createElement("g", {
        key: `piece-${piece.renderKey}`,
        transform: `translate(${xPosition},${yPosition + height})`
      }, customMark({ ...piece.data,
        ...piece,
        x: xPosition,
        y: yPosition
      }, i, { ...xy,
        baseMarkProps,
        renderMode,
        styleFn,
        classFn,
        adjustedSize,
        chartSize,
        margin,
        rScale
      })) : {
        className: classFn({ ...piece,
          ...piece.data
        }, i),
        renderMode: renderValue,
        key: `piece-${piece.renderKey}`,
        style: styleFn({ ...piece,
          ...piece.data
        }, ordsetI),
        ...markProps,
        ...eventListeners
      };
      const calculatedPiece = {
        o: key,
        xy,
        piece,
        renderElement: renderElementObject
      };
      calculatedPieces.push(calculatedPiece);
    });
    allCalculatedPieces = [...allCalculatedPieces, ...calculatedPieces];
  });
  return allCalculatedPieces;
};

const Timeline = props => {};

Timeline.layout = timelineLayout;
Timeline.propTypes = { ...OrdinalPlot.propTypes,
  innerRadius: propTypes.number,
  offsetAngle: propTypes.number,
  angleRange: propTypes.array
};
Timeline.defaultProps = { ...OrdinalPlot.defaultProps,
  angleRange: [0, 360]
};

const pointLayout = ({
  r,
  customMark,
  data,
  renderMode,
  eventListenersGenerator,
  styleFn,
  projection,
  classFn,
  adjustedSize,
  chartSize,
  margin,
  baseMarkProps,
  rScale
}) => {
  const circleRadius = r || 3;
  let allCalculatedPieces = [];
  const keys = Object.keys(data);
  keys.forEach((key, ordsetI) => {
    const ordset = data[key];
    const calculatedPieces = [];
    ordset.pieceData.forEach((piece, i) => {
      const renderValue = renderMode && renderMode(piece.data, i);
      let xPosition = ordset.middle;
      let yPosition = piece.scaledVerticalValue;

      if (projection === 'horizontal') {
        yPosition = ordset.middle;
        xPosition = piece.scaledValue;
      } else if (projection === 'radial') {
        const angle = ordset.pct_middle;
        const rPosition = piece.scaledValue / 2;
        const baseCentroid = pointOnArcAtAngle([adjustedSize[0] / 2, adjustedSize[1] / 2], angle, rPosition);
        xPosition = baseCentroid[0];
        yPosition = baseCentroid[1];
      } //Only return the actual piece if you're rendering points, otherwise you just needed to iterate and calculate the points for the contour summary type


      const actualCircleRadius = typeof circleRadius === 'function' ? circleRadius(piece, i) : circleRadius;
      const eventListeners = eventListenersGenerator(piece, i);
      const renderElementObject = customMark ? React$1.createElement("g", {
        key: `piece-${piece.renderKey}`,
        transform: `translate(${xPosition},${yPosition})`
      }, customMark({ ...piece.data,
        ...piece,
        x: xPosition,
        y: yPosition
      }, i, {
        r: circleRadius,
        x: xPosition,
        y: yPosition,
        baseMarkProps,
        renderMode,
        styleFn,
        classFn,
        adjustedSize,
        chartSize,
        margin,
        rScale
      })) : {
        className: classFn({ ...piece,
          ...piece.data
        }, i),
        markType: 'rect',
        renderMode: renderValue,
        key: `piece-${piece.renderKey}`,
        height: actualCircleRadius * 2,
        width: actualCircleRadius * 2,
        x: xPosition - actualCircleRadius,
        y: yPosition - actualCircleRadius,
        rx: actualCircleRadius,
        ry: actualCircleRadius,
        style: styleFn({ ...piece,
          ...piece.data
        }, ordsetI),
        ...eventListeners
      };
      const calculatedPiece = {
        o: key,
        xy: {
          x: xPosition,
          y: yPosition
        },
        piece,
        renderElement: renderElementObject
      };
      calculatedPieces.push(calculatedPiece);
    });
    allCalculatedPieces = [...allCalculatedPieces, ...calculatedPieces];
  });
  return allCalculatedPieces;
};

const OrdinalPoint = props => {};

OrdinalPoint.layout = pointLayout;
OrdinalPoint.propTypes = { ...OrdinalPlot.propTypes,
  r: propTypes.oneOfType([propTypes.number, propTypes.func])
};
OrdinalPoint.defaultProps = { ...OrdinalPlot.defaultProps
};

var BoundingBox_1 = BoundingBox;

// from https://github.com/gabelerner/canvg/blob/860e418aca67b9a41e858a223d74d375793ec364/canvg.js#L449

function BoundingBox(x1, y1, x2, y2) { // pass in initial points if you want
  this.x1 = Number.NaN;
  this.y1 = Number.NaN;
  this.x2 = Number.NaN;
  this.y2 = Number.NaN;

  this.addPoint(x1, y1);
  this.addPoint(x2, y2);
}

BoundingBox.prototype = {

  width: function () {
    return this.x2 - this.x1;
  },

  height: function () {
    return this.y2 - this.y1;
  },

  addPoint: function (x, y) {
    if (x != null) {
      if (isNaN(this.x1) || isNaN(this.x2)) {
        this.x1 = x;
        this.x2 = x;
      }
      if (x < this.x1) this.x1 = x;
      if (x > this.x2) this.x2 = x;
    }

    if (y != null) {
      if (isNaN(this.y1) || isNaN(this.y2)) {
        this.y1 = y;
        this.y2 = y;
      }
      if (y < this.y1) this.y1 = y;
      if (y > this.y2) this.y2 = y;
    }
  },

  addX: function (x) {
    this.addPoint(x, null);
  },

  addY: function (y) {
    this.addPoint(null, y);
  },

  addQuadraticCurve: function (p0x, p0y, p1x, p1y, p2x, p2y) {
    var cp1x = p0x + 2 / 3 * (p1x - p0x); // CP1 = QP0 + 2/3 *(QP1-QP0)
    var cp1y = p0y + 2 / 3 * (p1y - p0y); // CP1 = QP0 + 2/3 *(QP1-QP0)
    var cp2x = cp1x + 1 / 3 * (p2x - p0x); // CP2 = CP1 + 1/3 *(QP2-QP0)
    var cp2y = cp1y + 1 / 3 * (p2y - p0y); // CP2 = CP1 + 1/3 *(QP2-QP0)
    this.addBezierCurve(p0x, p0y, cp1x, cp2x, cp1y, cp2y, p2x, p2y);
  },

  addBezierCurve: function (p0x, p0y, p1x, p1y, p2x, p2y, p3x, p3y) {
    // from http://blog.hackers-cafe.net/2009/06/how-to-calculate-bezier-curves-bounding.html
    var
      i,
      p0 = [p0x, p0y],
      p1 = [p1x, p1y],
      p2 = [p2x, p2y],
      p3 = [p3x, p3y];

    this.addPoint(p0[0], p0[1]);
    this.addPoint(p3[0], p3[1]);

    for (i = 0; i <= 1; i++) {
      var f = function (t) {
        return Math.pow(1 - t, 3) * p0[i]
          + 3 * Math.pow(1 - t, 2) * t * p1[i]
          + 3 * (1 - t) * Math.pow(t, 2) * p2[i]
          + Math.pow(t, 3) * p3[i];
      };

      var b = 6 * p0[i] - 12 * p1[i] + 6 * p2[i];
      var a = -3 * p0[i] + 9 * p1[i] - 9 * p2[i] + 3 * p3[i];
      var c = 3 * p1[i] - 3 * p0[i];

      if (a == 0) {
        if (b == 0) continue;
        var t = -c / b;
        if (0 < t && t < 1) {
          if (i == 0) this.addX(f(t));
          if (i == 1) this.addY(f(t));
        }
        continue;
      }

      var b2ac = Math.pow(b, 2) - 4 * c * a;
      if (b2ac < 0) continue;
      var t1 = (-b + Math.sqrt(b2ac)) / (2 * a);
      if (0 < t1 && t1 < 1) {
        if (i == 0) this.addX(f(t1));
        if (i == 1) this.addY(f(t1));
      }
      var t2 = (-b - Math.sqrt(b2ac)) / (2 * a);
      if (0 < t2 && t2 < 1) {
        if (i == 0) this.addX(f(t2));
        if (i == 1) this.addY(f(t2));
      }
    }
  }

};

var BoundingBoxView_1 = BoundingBoxView;

function BoundingBoxView(boundingBox) {

  this.x1 = this.minX = boundingBox.x1 || 0;
  this.y1 = this.minY = boundingBox.y1 || 0;
  this.x2 = this.maxX = boundingBox.x2 || 0;
  this.y2 = this.maxY = boundingBox.y2 || 0;
  this.width = boundingBox.width() || 0;
  this.height = boundingBox.height() || 0;

}

BoundingBoxView.prototype = {

  round: function(precision) {
    precision = precision || 0;

    this.x1 = this.minX = +this.x1.toFixed(precision);
    this.y1 = this.minY = +this.y1.toFixed(precision);
    this.x2 = this.maxX = +this.x2.toFixed(precision);
    this.y2 = this.maxY = +this.y2.toFixed(precision);
    this.width = +this.width.toFixed(precision);
    this.height = +this.height.toFixed(precision);

    return this;
  },

  scale: function(scale) {
    var
      self = this;

    scale = scale || 1;

    [
      'x1',
      'minX',
      'y1',
      'minY',
      'x2',
      'maxX',
      'y2',
      'maxY',
      'width',
      'height'
    ]
      .forEach(function(name) {
        self[name] = self[name] * scale;
      });

    return this;
  },

  toString: function() {
    return [
      this.minX,
      this.minY,
      this.width,
      this.height
    ]
      .join(' ');
  }

};

var paramCounts = { a: 7, c: 6, h: 1, l: 2, m: 2, r: 4, q: 4, s: 4, t: 2, v: 1, z: 0 };

var SPECIAL_SPACES = [
  0x1680, 0x180E, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006,
  0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF
];

function isSpace(ch) {
  return (ch === 0x0A) || (ch === 0x0D) || (ch === 0x2028) || (ch === 0x2029) || // Line terminators
    // White spaces
    (ch === 0x20) || (ch === 0x09) || (ch === 0x0B) || (ch === 0x0C) || (ch === 0xA0) ||
    (ch >= 0x1680 && SPECIAL_SPACES.indexOf(ch) >= 0);
}

function isCommand(code) {
  /*eslint-disable no-bitwise*/
  switch (code | 0x20) {
    case 0x6D/* m */:
    case 0x7A/* z */:
    case 0x6C/* l */:
    case 0x68/* h */:
    case 0x76/* v */:
    case 0x63/* c */:
    case 0x73/* s */:
    case 0x71/* q */:
    case 0x74/* t */:
    case 0x61/* a */:
    case 0x72/* r */:
      return true;
  }
  return false;
}

function isDigit(code) {
  return (code >= 48 && code <= 57);   // 0..9
}

function isDigitStart(code) {
  return (code >= 48 && code <= 57) || /* 0..9 */
          code === 0x2B || /* + */
          code === 0x2D || /* - */
          code === 0x2E;   /* . */
}


function State(path) {
  this.index  = 0;
  this.path   = path;
  this.max    = path.length;
  this.result = [];
  this.param  = 0.0;
  this.err    = '';
  this.segmentStart = 0;
  this.data   = [];
}

function skipSpaces(state) {
  while (state.HospitalFacilities < state.max && isSpace(state.path.charCodeAt(state.HospitalFacilities))) {
    state.HospitalFacilities++;
  }
}


function scanParam(state) {
  var start = state.index,
      index = start,
      max = state.max,
      zeroFirst = false,
      hasCeiling = false,
      hasDecimal = false,
      hasDot = false,
      ch;

  if (index >= max) {
    state.err = 'SvgPath: missed param (at pos ' + index + ')';
    return;
  }
  ch = state.path.charCodeAt(index);

  if (ch === 0x2B/* + */ || ch === 0x2D/* - */) {
    index++;
    ch = (index < max) ? state.path.charCodeAt(index) : 0;
  }

  // This logic is shamelessly borrowed from Esprima
  // https://github.com/ariya/esprimas
  //
  if (!isDigit(ch) && ch !== 0x2E/* . */) {
    state.err = 'SvgPath: param should start with 0..9 or `.` (at pos ' + index + ')';
    return;
  }

  if (ch !== 0x2E/* . */) {
    zeroFirst = (ch === 0x30/* 0 */);
    index++;

    ch = (index < max) ? state.path.charCodeAt(index) : 0;

    if (zeroFirst && index < max) {
      // decimal number starts with '0' such as '09' is illegal.
      if (ch && isDigit(ch)) {
        state.err = 'SvgPath: numbers started with `0` such as `09` are ilegal (at pos ' + start + ')';
        return;
      }
    }

    while (index < max && isDigit(state.path.charCodeAt(index))) {
      index++;
      hasCeiling = true;
    }
    ch = (index < max) ? state.path.charCodeAt(index) : 0;
  }

  if (ch === 0x2E/* . */) {
    hasDot = true;
    index++;
    while (isDigit(state.path.charCodeAt(index))) {
      index++;
      hasDecimal = true;
    }
    ch = (index < max) ? state.path.charCodeAt(index) : 0;
  }

  if (ch === 0x65/* e */ || ch === 0x45/* E */) {
    if (hasDot && !hasCeiling && !hasDecimal) {
      state.err = 'SvgPath: invalid float exponent (at pos ' + index + ')';
      return;
    }

    index++;

    ch = (index < max) ? state.path.charCodeAt(index) : 0;
    if (ch === 0x2B/* + */ || ch === 0x2D/* - */) {
      index++;
    }
    if (index < max && isDigit(state.path.charCodeAt(index))) {
      while (index < max && isDigit(state.path.charCodeAt(index))) {
        index++;
      }
    } else {
      state.err = 'SvgPath: invalid float exponent (at pos ' + index + ')';
      return;
    }
  }

  state.index = index;
  state.param = parseFloat(state.path.slice(start, index)) + 0.0;
}


function finalizeSegment(state) {
  var cmd, cmdLC;

  // Process duplicated commands (without comand name)

  // This logic is shamelessly borrowed from Raphael
  // https://github.com/DmitryBaranovskiy/raphael/
  //
  cmd   = state.path[state.segmentStart];
  cmdLC = cmd.toLowerCase();

  var params = state.data;

  if (cmdLC === 'm' && params.length > 2) {
    state.result.push([ cmd, params[0], params[1] ]);
    params = params.slice(2);
    cmdLC = 'l';
    cmd = (cmd === 'm') ? 'l' : 'L';
  }

  if (cmdLC === 'r') {
    state.result.push([ cmd ].concat(params));
  } else {

    while (params.length >= paramCounts[cmdLC]) {
      state.result.push([ cmd ].concat(params.splice(0, paramCounts[cmdLC])));
      if (!paramCounts[cmdLC]) {
        break;
      }
    }
  }
}


function scanSegment(state) {
  var max = state.max,
      cmdCode, comma_found, need_params, i;

  state.segmentStart = state.HospitalFacilities;
  cmdCode = state.path.charCodeAt(state.HospitalFacilities);

  if (!isCommand(cmdCode)) {
    state.err = 'SvgPath: bad command ' + state.path[state.HospitalFacilities] + ' (at pos ' + state.HospitalFacilities + ')';
    return;
  }

  need_params = paramCounts[state.path[state.HospitalFacilities].toLowerCase()];

  state.HospitalFacilities++;
  skipSpaces(state);

  state.data = [];

  if (!need_params) {
    // Z
    finalizeSegment(state);
    return;
  }

  comma_found = false;

  for (;;) {
    for (i = need_params; i > 0; i--) {
      scanParam(state);
      if (state.err.length) {
        return;
      }
      state.data.push(state.param);

      skipSpaces(state);
      comma_found = false;

      if (state.HospitalFacilities < max && state.path.charCodeAt(state.HospitalFacilities) === 0x2C/* , */) {
        state.HospitalFacilities++;
        skipSpaces(state);
        comma_found = true;
      }
    }

    // after ',' param is mandatory
    if (comma_found) {
      continue;
    }

    if (state.HospitalFacilities >= state.max) {
      break;
    }

    // Stop on next segment
    if (!isDigitStart(state.path.charCodeAt(state.HospitalFacilities))) {
      break;
    }
  }

  finalizeSegment(state);
}


/* Returns array of segments:
 *
 * [
 *   [ command, coord1, coord2, ... ]
 * ]
 */
var path_parse = function pathParse(svgPath) {
  var state = new State(svgPath);
  var max = state.max;

  skipSpaces(state);

  while (state.index < max && !state.err.length) {
    scanSegment(state);
  }

  if (state.err.length) {
    state.result = [];

  } else if (state.result.length) {

    if ('mM'.indexOf(state.result[0][0]) < 0) {
      state.err = 'SvgPath: string should start with `M` or `m`';
      state.result = [];
    } else {
      state.result[0][0] = 'M';
    }
  }

  return {
    err: state.err,
    segments: state.result
  };
};

// combine 2 matrixes
// m1, m2 - [a, b, c, d, e, g]
//
function combine(m1, m2) {
  return [
    m1[0] * m2[0] + m1[2] * m2[1],
    m1[1] * m2[0] + m1[3] * m2[1],
    m1[0] * m2[2] + m1[2] * m2[3],
    m1[1] * m2[2] + m1[3] * m2[3],
    m1[0] * m2[4] + m1[2] * m2[5] + m1[4],
    m1[1] * m2[4] + m1[3] * m2[5] + m1[5]
  ];
}


function Matrix() {
  if (!(this instanceof Matrix)) { return new Matrix(); }
  this.queue = [];   // list of matrixes to apply
  this.cache = null; // combined matrix cache
}


Matrix.prototype.matrix = function (m) {
  if (m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 1 && m[4] === 0 && m[5] === 0) {
    return this;
  }
  this.cache = null;
  this.queue.push(m);
  return this;
};


Matrix.prototype.translate = function (tx, ty) {
  if (tx !== 0 || ty !== 0) {
    this.cache = null;
    this.queue.push([ 1, 0, 0, 1, tx, ty ]);
  }
  return this;
};


Matrix.prototype.scale = function (sx, sy) {
  if (sx !== 1 || sy !== 1) {
    this.cache = null;
    this.queue.push([ sx, 0, 0, sy, 0, 0 ]);
  }
  return this;
};


Matrix.prototype.rotate = function (angle, rx, ry) {
  var rad, cos, sin;

  if (angle !== 0) {
    this.translate(rx, ry);

    rad = angle * Math.PI / 180;
    cos = Math.cos(rad);
    sin = Math.sin(rad);

    this.queue.push([ cos, sin, -sin, cos, 0, 0 ]);
    this.cache = null;

    this.translate(-rx, -ry);
  }
  return this;
};


Matrix.prototype.skewX = function (angle) {
  if (angle !== 0) {
    this.cache = null;
    this.queue.push([ 1, 0, Math.tan(angle * Math.PI / 180), 1, 0, 0 ]);
  }
  return this;
};


Matrix.prototype.skewY = function (angle) {
  if (angle !== 0) {
    this.cache = null;
    this.queue.push([ 1, Math.tan(angle * Math.PI / 180), 0, 1, 0, 0 ]);
  }
  return this;
};


// Flatten queue
//
Matrix.prototype.toArray = function () {
  if (this.cache) {
    return this.cache;
  }

  if (!this.queue.length) {
    this.cache = [ 1, 0, 0, 1, 0, 0 ];
    return this.cache;
  }

  this.cache = this.queue[0];

  if (this.queue.length === 1) {
    return this.cache;
  }

  for (var i = 1; i < this.queue.length; i++) {
    this.cache = combine(this.cache, this.queue[i]);
  }

  return this.cache;
};


// Apply list of matrixes to (x,y) point.
// If `isRelative` set, `translate` component of matrix will be skipped
//
Matrix.prototype.calc = function (x, y, isRelative) {
  var m;

  // Don't change point on empty transforms queue
  if (!this.queue.length) { return [ x, y ]; }

  // Calculate final matrix, if not exists
  //
  // NB. if you deside to apply transforms to point one-by-one,
  // they should be taken in reverse order

  if (!this.cache) {
    this.cache = this.toArray();
  }

  m = this.cache;

  // Apply matrix to point
  return [
    x * m[0] + y * m[2] + (isRelative ? 0 : m[4]),
    x * m[1] + y * m[3] + (isRelative ? 0 : m[5])
  ];
};


var matrix = Matrix;

var operations$1 = {
  matrix: true,
  scale: true,
  rotate: true,
  translate: true,
  skewX: true,
  skewY: true
};

var CMD_SPLIT_RE    = /\s*(matrix|translate|scale|rotate|skewX|skewY)\s*\(\s*(.+?)\s*\)[\s,]*/;
var PARAMS_SPLIT_RE = /[\s,]+/;


var transform_parse = function transformParse(transformString) {
  var matrix$1 = new matrix();
  var cmd, params;

  // Split value into ['', 'translate', '10 50', '', 'scale', '2', '', 'rotate',  '-45', '']
  transformString.split(CMD_SPLIT_RE).forEach(function (item) {

    // Skip empty elements
    if (!item.length) { return; }

    // remember operation
    if (typeof operations$1[item] !== 'undefined') {
      cmd = item;
      return;
    }

    // extract params & att operation to matrix
    params = item.split(PARAMS_SPLIT_RE).map(function (i) {
      return +i || 0;
    });

    // If params count is not correct - ignore command
    switch (cmd) {
      case 'matrix':
        if (params.length === 6) {
          matrix$1.matrix(params);
        }
        return;

      case 'scale':
        if (params.length === 1) {
          matrix$1.scale(params[0], params[0]);
        } else if (params.length === 2) {
          matrix$1.scale(params[0], params[1]);
        }
        return;

      case 'rotate':
        if (params.length === 1) {
          matrix$1.rotate(params[0], 0, 0);
        } else if (params.length === 3) {
          matrix$1.rotate(params[0], params[1], params[2]);
        }
        return;

      case 'translate':
        if (params.length === 1) {
          matrix$1.translate(params[0], 0);
        } else if (params.length === 2) {
          matrix$1.translate(params[0], params[1]);
        }
        return;

      case 'skewX':
        if (params.length === 1) {
          matrix$1.skewX(params[0]);
        }
        return;

      case 'skewY':
        if (params.length === 1) {
          matrix$1.skewY(params[0]);
        }
        return;
    }
  });

  return matrix$1;
};

// Convert an arc to a sequence of cubic bézier curves


var TAU = Math.PI * 2;


/* eslint-disable space-infix-ops */

// Calculate an angle between two unit vectors
//
// Since we measure angle between radii of circular arcs,
// we can use simplified math (without length normalization)
//
function unit_vector_angle(ux, uy, vx, vy) {
  var sign = (ux * vy - uy * vx < 0) ? -1 : 1;
  var dot  = ux * vx + uy * vy;

  // Add this to work with arbitrary vectors:
  // dot /= Math.sqrt(ux * ux + uy * uy) * Math.sqrt(vx * vx + vy * vy);

  // rounding errors, e.g. -1.0000000000000002 can screw up this
  if (dot >  1.0) { dot =  1.0; }
  if (dot < -1.0) { dot = -1.0; }

  return sign * Math.acos(dot);
}


// Convert from endpoint to center parameterization,
// see http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes
//
// Return [cx, cy, theta1, delta_theta]
//
function get_arc_center(x1, y1, x2, y2, fa, fs, rx, ry, sin_phi, cos_phi) {
  // Step 1.
  //
  // Moving an ellipse so origin will be the middlepoint between our two
  // points. After that, rotate it to line up ellipse axes with coordinate
  // axes.
  //
  var x1p =  cos_phi*(x1-x2)/2 + sin_phi*(y1-y2)/2;
  var y1p = -sin_phi*(x1-x2)/2 + cos_phi*(y1-y2)/2;

  var rx_sq  =  rx * rx;
  var ry_sq  =  ry * ry;
  var x1p_sq = x1p * x1p;
  var y1p_sq = y1p * y1p;

  // Step 2.
  //
  // Compute coordinates of the centre of this ellipse (cx', cy')
  // in the new coordinate system.
  //
  var radicant = (rx_sq * ry_sq) - (rx_sq * y1p_sq) - (ry_sq * x1p_sq);

  if (radicant < 0) {
    // due to rounding errors it might be e.g. -1.3877787807814457e-17
    radicant = 0;
  }

  radicant /=   (rx_sq * y1p_sq) + (ry_sq * x1p_sq);
  radicant = Math.sqrt(radicant) * (fa === fs ? -1 : 1);

  var cxp = radicant *  rx/ry * y1p;
  var cyp = radicant * -ry/rx * x1p;

  // Step 3.
  //
  // Transform back to get centre coordinates (cx, cy) in the original
  // coordinate system.
  //
  var cx = cos_phi*cxp - sin_phi*cyp + (x1+x2)/2;
  var cy = sin_phi*cxp + cos_phi*cyp + (y1+y2)/2;

  // Step 4.
  //
  // Compute angles (theta1, delta_theta).
  //
  var v1x =  (x1p - cxp) / rx;
  var v1y =  (y1p - cyp) / ry;
  var v2x = (-x1p - cxp) / rx;
  var v2y = (-y1p - cyp) / ry;

  var theta1 = unit_vector_angle(1, 0, v1x, v1y);
  var delta_theta = unit_vector_angle(v1x, v1y, v2x, v2y);

  if (fs === 0 && delta_theta > 0) {
    delta_theta -= TAU;
  }
  if (fs === 1 && delta_theta < 0) {
    delta_theta += TAU;
  }

  return [ cx, cy, theta1, delta_theta ];
}

//
// Approximate one unit arc segment with bézier curves,
// see http://math.stackexchange.com/questions/873224
//
function approximate_unit_arc(theta1, delta_theta) {
  var alpha = 4/3 * Math.tan(delta_theta/4);

  var x1 = Math.cos(theta1);
  var y1 = Math.sin(theta1);
  var x2 = Math.cos(theta1 + delta_theta);
  var y2 = Math.sin(theta1 + delta_theta);

  return [ x1, y1, x1 - y1*alpha, y1 + x1*alpha, x2 + y2*alpha, y2 - x2*alpha, x2, y2 ];
}

var a2c = function a2c(x1, y1, x2, y2, fa, fs, rx, ry, phi) {
  var sin_phi = Math.sin(phi * TAU / 360);
  var cos_phi = Math.cos(phi * TAU / 360);

  // Make sure radii are valid
  //
  var x1p =  cos_phi*(x1-x2)/2 + sin_phi*(y1-y2)/2;
  var y1p = -sin_phi*(x1-x2)/2 + cos_phi*(y1-y2)/2;

  if (x1p === 0 && y1p === 0) {
    // we're asked to draw line to itself
    return [];
  }

  if (rx === 0 || ry === 0) {
    // one of the radii is zero
    return [];
  }


  // Compensate out-of-range radii
  //
  rx = Math.abs(rx);
  ry = Math.abs(ry);

  var lambda = (x1p * x1p) / (rx * rx) + (y1p * y1p) / (ry * ry);
  if (lambda > 1) {
    rx *= Math.sqrt(lambda);
    ry *= Math.sqrt(lambda);
  }


  // Get center parameters (cx, cy, theta1, delta_theta)
  //
  var cc = get_arc_center(x1, y1, x2, y2, fa, fs, rx, ry, sin_phi, cos_phi);

  var result = [];
  var theta1 = cc[2];
  var delta_theta = cc[3];

  // Split an arc to multiple segments, so each segment
  // will be less than τ/4 (= 90°)
  //
  var segments = Math.max(Math.ceil(Math.abs(delta_theta) / (TAU / 4)), 1);
  delta_theta /= segments;

  for (var i = 0; i < segments; i++) {
    result.push(approximate_unit_arc(theta1, delta_theta));
    theta1 += delta_theta;
  }

  // We have a bezier approximation of a unit circle,
  // now need to transform back to the original ellipse
  //
  return result.map(function (curve) {
    for (var i = 0; i < curve.length; i += 2) {
      var x = curve[i + 0];
      var y = curve[i + 1];

      // scale
      x *= rx;
      y *= ry;

      // rotate
      var xp = cos_phi*x - sin_phi*y;
      var yp = sin_phi*x + cos_phi*y;

      // translate
      curve[i + 0] = xp + cc[0];
      curve[i + 1] = yp + cc[1];
    }

    return curve;
  });
};

/* eslint-disable space-infix-ops */

// The precision used to consider an ellipse as a circle
//
var epsilon$3 = 0.0000000001;

// To convert degree in radians
//
var torad = Math.PI / 180;

// Class constructor :
//  an ellipse centred at 0 with radii rx,ry and x - axis - angle ax.
//
function Ellipse(rx, ry, ax) {
  if (!(this instanceof Ellipse)) { return new Ellipse(rx, ry, ax); }
  this.rx = rx;
  this.ry = ry;
  this.ax = ax;
}

// Apply a linear transform m to the ellipse
// m is an array representing a matrix :
//    -         -
//   | m[0] m[2] |
//   | m[1] m[3] |
//    -         -
//
Ellipse.prototype.transform = function (m) {
  // We consider the current ellipse as image of the unit circle
  // by first scale(rx,ry) and then rotate(ax) ...
  // So we apply ma =  m x rotate(ax) x scale(rx,ry) to the unit circle.
  var c = Math.cos(this.ax * torad), s = Math.sin(this.ax * torad);
  var ma = [
    this.rx * (m[0]*c + m[2]*s),
    this.rx * (m[1]*c + m[3]*s),
    this.ry * (-m[0]*s + m[2]*c),
    this.ry * (-m[1]*s + m[3]*c)
  ];

  // ma * transpose(ma) = [ J L ]
  //                      [ L K ]
  // L is calculated later (if the image is not a circle)
  var J = ma[0]*ma[0] + ma[2]*ma[2],
      K = ma[1]*ma[1] + ma[3]*ma[3];

  // the discriminant of the characteristic polynomial of ma * transpose(ma)
  var D = ((ma[0]-ma[3])*(ma[0]-ma[3]) + (ma[2]+ma[1])*(ma[2]+ma[1])) *
          ((ma[0]+ma[3])*(ma[0]+ma[3]) + (ma[2]-ma[1])*(ma[2]-ma[1]));

  // the "mean eigenvalue"
  var JK = (J + K) / 2;

  // check if the image is (almost) a circle
  if (D < epsilon$3 * JK) {
    // if it is
    this.rx = this.ry = Math.sqrt(JK);
    this.ax = 0;
    return this;
  }

  // if it is not a circle
  var L = ma[0]*ma[1] + ma[2]*ma[3];

  D = Math.sqrt(D);

  // {l1,l2} = the two eigen values of ma * transpose(ma)
  var l1 = JK + D/2,
      l2 = JK - D/2;
  // the x - axis - rotation angle is the argument of the l1 - eigenvector
  /*eslint-disable indent*/
  this.ax = (Math.abs(L) < epsilon$3 && Math.abs(l1 - K) < epsilon$3) ?
    90
  :
    Math.atan(Math.abs(L) > Math.abs(l1 - K) ?
      (l1 - J) / L
    :
      L / (l1 - K)
    ) * 180 / Math.PI;
  /*eslint-enable indent*/

  // if ax > 0 => rx = sqrt(l1), ry = sqrt(l2), else exchange axes and ax += 90
  if (this.ax >= 0) {
    // if ax in [0,90]
    this.rx = Math.sqrt(l1);
    this.ry = Math.sqrt(l2);
  } else {
    // if ax in ]-90,0[ => exchange axes
    this.ax += 90;
    this.rx = Math.sqrt(l2);
    this.ry = Math.sqrt(l1);
  }

  return this;
};

// Check if the ellipse is (almost) degenerate, i.e. rx = 0 or ry = 0
//
Ellipse.prototype.isDegenerate = function () {
  return (this.rx < epsilon$3 * this.ry || this.ry < epsilon$3 * this.rx);
};

var ellipse = Ellipse;

// Class constructor
//
function SvgPath(path) {
  if (!(this instanceof SvgPath)) { return new SvgPath(path); }

  var pstate = path_parse(path);

  // Array of path segments.
  // Each segment is array [command, param1, param2, ...]
  this.segments = pstate.segments;

  // Error message on parse error.
  this.err      = pstate.err;

  // Transforms stack for lazy evaluation
  this.__stack    = [];
}


SvgPath.prototype.__matrix = function (m) {
  var self = this, i;

  // Quick leave for empty matrix
  if (!m.queue.length) { return; }

  this.iterate(function (s, index, x, y) {
    var p, result, name, isRelative;

    switch (s[0]) {

      // Process 'assymetric' commands separately
      case 'v':
        p      = m.calc(0, s[1], true);
        result = (p[0] === 0) ? [ 'v', p[1] ] : [ 'l', p[0], p[1] ];
        break;

      case 'V':
        p      = m.calc(x, s[1], false);
        result = (p[0] === m.calc(x, y, false)[0]) ? [ 'V', p[1] ] : [ 'L', p[0], p[1] ];
        break;

      case 'h':
        p      = m.calc(s[1], 0, true);
        result = (p[1] === 0) ? [ 'h', p[0] ] : [ 'l', p[0], p[1] ];
        break;

      case 'H':
        p      = m.calc(s[1], y, false);
        result = (p[1] === m.calc(x, y, false)[1]) ? [ 'H', p[0] ] : [ 'L', p[0], p[1] ];
        break;

      case 'a':
      case 'A':
        // ARC is: ['A', rx, ry, x-axis-rotation, large-arc-flag, sweep-flag, x, y]

        // Drop segment if arc is empty (end point === start point)
        /*if ((s[0] === 'A' && s[6] === x && s[7] === y) ||
            (s[0] === 'a' && s[6] === 0 && s[7] === 0)) {
          return [];
        }*/

        // Transform rx, ry and the x-axis-rotation
        var ma = m.toArray();
        var e = ellipse(s[1], s[2], s[3]).transform(ma);

        // flip sweep-flag if matrix is not orientation-preserving
        if (ma[0] * ma[3] - ma[1] * ma[2] < 0) {
          s[5] = s[5] ? '0' : '1';
        }

        // Transform end point as usual (without translation for relative notation)
        p = m.calc(s[6], s[7], s[0] === 'a');

        // Empty arcs can be ignored by renderer, but should not be dropped
        // to avoid collisions with `S A S` and so on. Replace with empty line.
        if ((s[0] === 'A' && s[6] === x && s[7] === y) ||
            (s[0] === 'a' && s[6] === 0 && s[7] === 0)) {
          result = [ s[0] === 'a' ? 'l' : 'L', p[0], p[1] ];
          break;
        }

        // if the resulting ellipse is (almost) a segment ...
        if (e.isDegenerate()) {
          // replace the arc by a line
          result = [ s[0] === 'a' ? 'l' : 'L', p[0], p[1] ];
        } else {
          // if it is a real ellipse
          // s[0], s[4] and s[5] are not modified
          result = [ s[0], e.rx, e.ry, e.ax, s[4], s[5], p[0], p[1] ];
        }

        break;

      case 'm':
        // Edge case. The very first `m` should be processed as absolute, if happens.
        // Make sense for coord shift transforms.
        isRelative = index > 0;

        p = m.calc(s[1], s[2], isRelative);
        result = [ 'm', p[0], p[1] ];
        break;

      default:
        name       = s[0];
        result     = [ name ];
        isRelative = (name.toLowerCase() === name);

        // Apply transformations to the segment
        for (i = 1; i < s.length; i += 2) {
          p = m.calc(s[i], s[i + 1], isRelative);
          result.push(p[0], p[1]);
        }
    }

    self.segments[index] = result;
  }, true);
};


// Apply stacked commands
//
SvgPath.prototype.__evaluateStack = function () {
  var m, i;

  if (!this.__stack.length) { return; }

  if (this.__stack.length === 1) {
    this.__matrix(this.__stack[0]);
    this.__stack = [];
    return;
  }

  m = matrix();
  i = this.__stack.length;

  while (--i >= 0) {
    m.matrix(this.__stack[i].toArray());
  }

  this.__matrix(m);
  this.__stack = [];
};


// Convert processed SVG Path back to string
//
SvgPath.prototype.toString = function () {
  var elements = [], skipCmd, cmd;

  this.__evaluateStack();

  for (var i = 0; i < this.segments.length; i++) {
    // remove repeating commands names
    cmd = this.segments[i][0];
    skipCmd = i > 0 && cmd !== 'm' && cmd !== 'M' && cmd === this.segments[i - 1][0];
    elements = elements.concat(skipCmd ? this.segments[i].slice(1) : this.segments[i]);
  }

  return elements.join(' ')
    // Optimizations: remove spaces around commands & before `-`
    //
    // We could also remove leading zeros for `0.5`-like values,
    // but their count is too small to spend time for.
    .replace(/ ?([achlmqrstvz]) ?/gi, '$1')
    .replace(/ \-/g, '-')
    // workaround for FontForge SVG importing bug
    .replace(/zm/g, 'z m');
};


// Translate path to (x [, y])
//
SvgPath.prototype.translate = function (x, y) {
  this.__stack.push(matrix().translate(x, y || 0));
  return this;
};


// Scale path to (sx [, sy])
// sy = sx if not defined
//
SvgPath.prototype.scale = function (sx, sy) {
  this.__stack.push(matrix().scale(sx, (!sy && (sy !== 0)) ? sx : sy));
  return this;
};


// Rotate path around point (sx [, sy])
// sy = sx if not defined
//
SvgPath.prototype.rotate = function (angle, rx, ry) {
  this.__stack.push(matrix().rotate(angle, rx || 0, ry || 0));
  return this;
};


// Skew path along the X axis by `degrees` angle
//
SvgPath.prototype.skewX = function (degrees) {
  this.__stack.push(matrix().skewX(degrees));
  return this;
};


// Skew path along the Y axis by `degrees` angle
//
SvgPath.prototype.skewY = function (degrees) {
  this.__stack.push(matrix().skewY(degrees));
  return this;
};


// Apply matrix transform (array of 6 elements)
//
SvgPath.prototype.matrix = function (m) {
  this.__stack.push(matrix().matrix(m));
  return this;
};


// Transform path according to "transform" attr of SVG spec
//
SvgPath.prototype.transform = function (transformString) {
  if (!transformString.trim()) {
    return this;
  }
  this.__stack.push(transform_parse(transformString));
  return this;
};


// Round coords with given decimal precition.
// 0 by default (to integers)
//
SvgPath.prototype.round = function (d) {
  var contourStartDeltaX = 0, contourStartDeltaY = 0, deltaX = 0, deltaY = 0, l;

  d = d || 0;

  this.__evaluateStack();

  this.segments.forEach(function (s) {
    var isRelative = (s[0].toLowerCase() === s[0]);

    switch (s[0]) {
      case 'H':
      case 'h':
        if (isRelative) { s[1] += deltaX; }
        deltaX = s[1] - s[1].toFixed(d);
        s[1] = +s[1].toFixed(d);
        return;

      case 'V':
      case 'v':
        if (isRelative) { s[1] += deltaY; }
        deltaY = s[1] - s[1].toFixed(d);
        s[1] = +s[1].toFixed(d);
        return;

      case 'Z':
      case 'z':
        deltaX = contourStartDeltaX;
        deltaY = contourStartDeltaY;
        return;

      case 'M':
      case 'm':
        if (isRelative) {
          s[1] += deltaX;
          s[2] += deltaY;
        }

        deltaX = s[1] - s[1].toFixed(d);
        deltaY = s[2] - s[2].toFixed(d);

        contourStartDeltaX = deltaX;
        contourStartDeltaY = deltaY;

        s[1] = +s[1].toFixed(d);
        s[2] = +s[2].toFixed(d);
        return;

      case 'A':
      case 'a':
        // [cmd, rx, ry, x-axis-rotation, large-arc-flag, sweep-flag, x, y]
        if (isRelative) {
          s[6] += deltaX;
          s[7] += deltaY;
        }

        deltaX = s[6] - s[6].toFixed(d);
        deltaY = s[7] - s[7].toFixed(d);

        s[1] = +s[1].toFixed(d);
        s[2] = +s[2].toFixed(d);
        s[3] = +s[3].toFixed(d + 2); // better precision for rotation
        s[6] = +s[6].toFixed(d);
        s[7] = +s[7].toFixed(d);
        return;

      default:
        // a c l q s t
        l = s.length;

        if (isRelative) {
          s[l - 2] += deltaX;
          s[l - 1] += deltaY;
        }

        deltaX = s[l - 2] - s[l - 2].toFixed(d);
        deltaY = s[l - 1] - s[l - 1].toFixed(d);

        s.forEach(function (val, i) {
          if (!i) { return; }
          s[i] = +s[i].toFixed(d);
        });
        return;
    }
  });

  return this;
};


// Apply iterator function to all segments. If function returns result,
// current segment will be replaced to array of returned segments.
// If empty array is returned, current regment will be deleted.
//
SvgPath.prototype.iterate = function (iterator, keepLazyStack) {
  var segments = this.segments,
      replacements = {},
      needReplace = false,
      lastX = 0,
      lastY = 0,
      countourStartX = 0,
      countourStartY = 0;
  var i, j, newSegments;

  if (!keepLazyStack) {
    this.__evaluateStack();
  }

  segments.forEach(function (s, index) {

    var res = iterator(s, index, lastX, lastY);

    if (Array.isArray(res)) {
      replacements[index] = res;
      needReplace = true;
    }

    var isRelative = (s[0] === s[0].toLowerCase());

    // calculate absolute X and Y
    switch (s[0]) {
      case 'm':
      case 'M':
        lastX = s[1] + (isRelative ? lastX : 0);
        lastY = s[2] + (isRelative ? lastY : 0);
        countourStartX = lastX;
        countourStartY = lastY;
        return;

      case 'h':
      case 'H':
        lastX = s[1] + (isRelative ? lastX : 0);
        return;

      case 'v':
      case 'V':
        lastY = s[1] + (isRelative ? lastY : 0);
        return;

      case 'z':
      case 'Z':
        // That make sence for multiple contours
        lastX = countourStartX;
        lastY = countourStartY;
        return;

      default:
        lastX = s[s.length - 2] + (isRelative ? lastX : 0);
        lastY = s[s.length - 1] + (isRelative ? lastY : 0);
    }
  });

  // Replace segments if iterator return results

  if (!needReplace) { return this; }

  newSegments = [];

  for (i = 0; i < segments.length; i++) {
    if (typeof replacements[i] !== 'undefined') {
      for (j = 0; j < replacements[i].length; j++) {
        newSegments.push(replacements[i][j]);
      }
    } else {
      newSegments.push(segments[i]);
    }
  }

  this.segments = newSegments;

  return this;
};


// Converts segments from relative to absolute
//
SvgPath.prototype.abs = function () {

  this.iterate(function (s, index, x, y) {
    var name = s[0],
        nameUC = name.toUpperCase(),
        i;

    // Skip absolute commands
    if (name === nameUC) { return; }

    s[0] = nameUC;

    switch (name) {
      case 'v':
        // v has shifted coords parity
        s[1] += y;
        return;

      case 'a':
        // ARC is: ['A', rx, ry, x-axis-rotation, large-arc-flag, sweep-flag, x, y]
        // touch x, y only
        s[6] += x;
        s[7] += y;
        return;

      default:
        for (i = 1; i < s.length; i++) {
          s[i] += i % 2 ? x : y; // odd values are X, even - Y
        }
    }
  }, true);

  return this;
};


// Converts segments from absolute to relative
//
SvgPath.prototype.rel = function () {

  this.iterate(function (s, index, x, y) {
    var name = s[0],
        nameLC = name.toLowerCase(),
        i;

    // Skip relative commands
    if (name === nameLC) { return; }

    // Don't touch the first M to avoid potential confusions.
    if (index === 0 && name === 'M') { return; }

    s[0] = nameLC;

    switch (name) {
      case 'V':
        // V has shifted coords parity
        s[1] -= y;
        return;

      case 'A':
        // ARC is: ['A', rx, ry, x-axis-rotation, large-arc-flag, sweep-flag, x, y]
        // touch x, y only
        s[6] -= x;
        s[7] -= y;
        return;

      default:
        for (i = 1; i < s.length; i++) {
          s[i] -= i % 2 ? x : y; // odd values are X, even - Y
        }
    }
  }, true);

  return this;
};


// Converts arcs to cubic bézier curves
//
SvgPath.prototype.unarc = function () {
  this.iterate(function (s, index, x, y) {
    var new_segments, nextX, nextY, result = [], name = s[0];

    // Skip anything except arcs
    if (name !== 'A' && name !== 'a') { return null; }

    if (name === 'a') {
      // convert relative arc coordinates to absolute
      nextX = x + s[6];
      nextY = y + s[7];
    } else {
      nextX = s[6];
      nextY = s[7];
    }

    new_segments = a2c(x, y, nextX, nextY, s[4], s[5], s[1], s[2], s[3]);

    // Degenerated arcs can be ignored by renderer, but should not be dropped
    // to avoid collisions with `S A S` and so on. Replace with empty line.
    if (new_segments.length === 0) {
      return [ [ s[0] === 'a' ? 'l' : 'L', s[6], s[7] ] ];
    }

    new_segments.forEach(function (s) {
      result.push([ 'C', s[2], s[3], s[4], s[5], s[6], s[7] ]);
    });

    return result;
  });

  return this;
};


// Converts smooth curves (with missed control point) to generic curves
//
SvgPath.prototype.unshort = function () {
  var segments = this.segments;
  var prevControlX, prevControlY, prevSegment;
  var curControlX, curControlY;

  // TODO: add lazy evaluation flag when relative commands supported

  this.iterate(function (s, idx, x, y) {
    var name = s[0], nameUC = name.toUpperCase(), isRelative;

    // First command MUST be M|m, it's safe to skip.
    // Protect from access to [-1] for sure.
    if (!idx) { return; }

    if (nameUC === 'T') { // quadratic curve
      isRelative = (name === 't');

      prevSegment = segments[idx - 1];

      if (prevSegment[0] === 'Q') {
        prevControlX = prevSegment[1] - x;
        prevControlY = prevSegment[2] - y;
      } else if (prevSegment[0] === 'q') {
        prevControlX = prevSegment[1] - prevSegment[3];
        prevControlY = prevSegment[2] - prevSegment[4];
      } else {
        prevControlX = 0;
        prevControlY = 0;
      }

      curControlX = -prevControlX;
      curControlY = -prevControlY;

      if (!isRelative) {
        curControlX += x;
        curControlY += y;
      }

      segments[idx] = [
        isRelative ? 'q' : 'Q',
        curControlX, curControlY,
        s[1], s[2]
      ];

    } else if (nameUC === 'S') { // cubic curve
      isRelative = (name === 's');

      prevSegment = segments[idx - 1];

      if (prevSegment[0] === 'C') {
        prevControlX = prevSegment[3] - x;
        prevControlY = prevSegment[4] - y;
      } else if (prevSegment[0] === 'c') {
        prevControlX = prevSegment[3] - prevSegment[5];
        prevControlY = prevSegment[4] - prevSegment[6];
      } else {
        prevControlX = 0;
        prevControlY = 0;
      }

      curControlX = -prevControlX;
      curControlY = -prevControlY;

      if (!isRelative) {
        curControlX += x;
        curControlY += y;
      }

      segments[idx] = [
        isRelative ? 'c' : 'C',
        curControlX, curControlY,
        s[1], s[2], s[3], s[4]
      ];
    }
  });

  return this;
};


var svgpath = SvgPath;

var svgpath$1 = svgpath;

var Path_1 = Path$1;

function Path$1(d) {
  this.d = d;
}

Path$1.prototype = {

  getBoundingBox: function() {
    var
      pathDriver,
      boundingBox;

    pathDriver = new svgpath$1(this.d);
    boundingBox = new BoundingBox_1();

    pathDriver
      .abs()
      .unarc()
      .unshort()
      .iterate(function(seg, index, x, y) {

        switch(seg[0]) {
          case 'M':
          case 'L':
            boundingBox.addPoint(
              seg[1],
              seg[2]
            );
            break;
          case 'H':
            boundingBox.addX(seg[1]);
            break;
          case 'V':
            boundingBox.addY(seg[1]);
            break;
          case 'Q':
            boundingBox.addQuadraticCurve(
              x,
              y,
              seg[1],
              seg[2],
              seg[3],
              seg[4]
            );
            break;
          case 'C':
            boundingBox.addBezierCurve(
              x,
              y,
              seg[1],
              seg[2],
              seg[3],
              seg[4],
              seg[5],
              seg[6]
            );
            break;
        }

      });

    return new BoundingBoxView_1(boundingBox);
  }

};

var caster_1 = caster;

function caster(path) {
  return new Path_1(path).getBoundingBox();
}

caster.Path = Path_1;

var svgPathBoundingBox = caster_1;

const PLOT_TYPE = 'bar';

const iconBarCustomMark$1 = ({
  icon,
  iconPadding,
  resize,
  projection,
  finalHeight,
  finalWidth,
  styleFn,
  renderValue,
  classFn
}) => (piece, i, xy) => {
  const iconD = typeof icon === 'string' ? icon : icon(piece.data, i);
  const iconBounds = svgPathBoundingBox(iconD);
  const iconTranslate = [0 - iconBounds.x1 + iconPadding, 0 - iconBounds.y1 + iconPadding];
  iconBounds.height += iconPadding * 2;
  iconBounds.width += iconPadding * 2;
  const icons = [];
  let stackedIconSize = iconBounds.height;
  let stackedIconNumber = 1;
  let iconScale = 1;
  const spaceToUse = projection === 'horizontal' ? finalHeight : finalWidth;
  const sizeToFit = projection === 'horizontal' ? iconBounds.height : iconBounds.width;
  const sizeToPad = projection === 'horizontal' ? iconBounds.width : iconBounds.height;
  const spaceToFill = projection === 'horizontal' ? xy.width : xy.height;
  const spaceToStackFill = projection === 'horizontal' ? xy.height : xy.width;

  if (resize === 'auto') {
    stackedIconSize = spaceToUse / sizeToFit;

    if (stackedIconSize < 1) {
      iconScale = stackedIconSize;
    } else {
      stackedIconNumber = Math.floor(stackedIconSize);
      iconScale = 1 + (stackedIconSize - stackedIconNumber) / stackedIconNumber;
    }
  } else if (resize === 'fixed') {
    iconScale = spaceToUse / sizeToFit;
  } //  const finalIconWidth = iconBounds.width * iconScale;


  const finalIconHeight = iconBounds.height * iconScale;
  const spaceToStep = sizeToPad * iconScale;
  const spaceToStackStep = sizeToFit * iconScale;
  iconTranslate[0] = iconTranslate[0] * iconScale;
  iconTranslate[1] = iconTranslate[1] * iconScale;
  const randoClipID = `iso-clip-${i}-${Math.random()}`;
  const clipPath = `url(#${randoClipID})`;

  if (xy.width > 0) {
    icons.push(React$1.createElement("clipPath", {
      key: randoClipID,
      id: randoClipID
    }, React$1.createElement("rect", {
      x: 0,
      y: 0,
      width: xy.width,
      height: xy.height
    })));
    const iconPieces = [];
    const stepStart = projection === 'horizontal' ? 0 : xy.height - finalIconHeight;
    const stepper = projection === 'horizontal' ? spaceToStep : -spaceToStep;
    const stepTest = projection === 'horizontal' ? (step, spaceToFillValue) => step < spaceToFillValue : (step, spaceToFillValue, stepperValue) => step > 0 + stepperValue;

    for (let step = stepStart; stepTest(step, spaceToFill, stepper); step += stepper) {
      for (let stack = 0; stack < spaceToStackFill; stack += spaceToStackStep) {
        const stepX = projection === 'horizontal' ? step : stack;
        const stepY = projection === 'horizontal' ? stack : step;
        const paddedX = stepX + iconTranslate[0];
        const paddedY = stepY + iconTranslate[1];
        iconPieces.push(React$1.createElement(lib_2, {
          forceUpdate: true,
          markType: "path",
          key: `icon-${step}-${stack}`,
          transform: `translate(${paddedX},${paddedY}) scale(${iconScale})`,
          vectorEffect: 'non-scaling-stroke',
          d: iconD,
          style: styleFn({ ...piece,
            ...piece.data
          }, i),
          renderMode: renderValue,
          className: classFn({ ...piece,
            ...piece.data
          }, i)
        }));
      }
    }

    icons.push(React$1.createElement("g", {
      key: `clipped-region-${i}`,
      clipPath: clipPath
    }, iconPieces));
  }

  return icons;
};

const barLayout = ({
  icon,
  customMark,
  iconPadding,
  resize,
  innerRadius,
  offsetAngle,
  angleRange,
  data,
  renderMode,
  eventListenersGenerator,
  styleFn,
  projection,
  classFn,
  adjustedSize,
  chartSize,
  margin,
  baseMarkProps,
  rScale
}) => {
  const keys = Object.keys(data);
  let allCalculatedPieces = [];
  keys.forEach((key, ordsetI) => {
    const ordset = data[key];
    const barColumnWidth = Math.max(ordset.width, 1);
    const calculatedPieces = ordset.pieceData.map((piece, i) => {
      const pieceSize = piece.scaledValue;
      const renderValue = renderMode && renderMode(piece.data, i);
      let xPosition = piece.x;
      let yPosition = piece.bottom;
      let finalWidth = barColumnWidth;
      let finalHeight = pieceSize;

      if (!piece.negative) {
        yPosition -= piece.scaledValue;
      }

      if (projection === 'horizontal') {
        yPosition = piece.x;
        xPosition = piece.bottom;
        finalHeight = barColumnWidth;
        finalWidth = pieceSize;

        if (piece.negative) {
          xPosition = piece.bottom - piece.scaledValue;
        }
      }

      let markProps;

      if (projection === 'radial') {
        ({
          markProps,
          xPosition,
          yPosition
        } = radialBarFeatureGenerator({
          innerRadius,
          offsetAngle,
          angleRange,
          plotType: PLOT_TYPE,
          ordset,
          adjustedSize,
          piece,
          i
        }));
        finalHeight = undefined;
        finalWidth = undefined;
      } else {
        markProps = {
          markType: 'rect',
          x: xPosition,
          y: yPosition,
          width: Math.max(0, finalWidth),
          height: Math.max(0, finalHeight),
          rx: 0,
          ry: 0
        };
      }

      const eventListeners = eventListenersGenerator(piece, i);
      const xy = {
        x: xPosition,
        y: yPosition,
        middle: barColumnWidth / 2,
        height: finalHeight,
        width: finalWidth
      };

      if (icon && projection !== 'radial') {
        customMark = iconBarCustomMark$1({
          icon,
          iconPadding,
          resize,
          projection,
          finalHeight,
          finalWidth,
          styleFn,
          renderValue,
          classFn
        });
      } else if (icon && projection !== 'horizontal') {
        console.error('Icons are currently unsupported in radial charts');
      }

      const renderElementObject = customMark ? React$1.createElement("g", {
        key: `piece-${piece.renderKey}`,
        transform: `translate(${xPosition},${yPosition})`,
        role: "img",
        tabIndex: -1
      }, customMark({ ...piece.data,
        ...piece,
        x: xPosition,
        y: yPosition
      }, i, { ...xy,
        baseMarkProps,
        renderMode,
        styleFn,
        classFn,
        adjustedSize,
        chartSize,
        margin,
        rScale
      })) : {
        className: classFn({ ...piece,
          ...piece.data
        }, i),
        renderMode: renderValue,
        key: `piece-${piece.renderKey}`,
        style: styleFn({ ...piece,
          ...piece.data
        }, ordsetI),
        ...eventListeners,
        ...markProps
      };
      const calculatedPiece = {
        o: key,
        xy,
        piece,
        renderElement: renderElementObject
      };
      return calculatedPiece;
    });
    allCalculatedPieces = [...allCalculatedPieces, ...calculatedPieces];
  });
  return allCalculatedPieces;
};

const Bar = props => {};

Bar.layout = barLayout;
Bar.propTypes = { ...OrdinalPlot.propTypes,
  icon: propTypes.oneOfType([propTypes.func, propTypes.object]),
  iconPadding: propTypes.number,
  resize: propTypes.oneOf(['fixed', 'auto']),
  innerRadius: propTypes.number,
  offsetAngle: propTypes.number,
  angleRange: propTypes.array
};
Bar.defaultProps = { ...OrdinalPlot.defaultProps,
  iconPadding: 1,
  resize: 'auto'
};

const clusterBarLayout = ({
  icon,
  iconPadding,
  resize,
  data,
  customMark: userMark,
  innerRadius,
  offsetAngle,
  angleRange,
  renderMode,
  eventListenersGenerator,
  styleFn,
  projection,
  classFn,
  adjustedSize,
  chartSize,
  margin,
  baseMarkProps,
  rScale
}) => {
  let customMark = userMark;
  let allCalculatedPieces = [];
  const keys = Object.keys(data);
  keys.forEach((key, ordsetI) => {
    const ordset = data[key];
    const barColumnWidth = Math.max(ordset.width, 1);
    const clusterWidth = barColumnWidth / ordset.pieceData.length;
    let currentX = 0;
    let currentY = 0;
    const calculatedPieces = ordset.pieceData.map((piece, i) => {
      const renderValue = renderMode && renderMode(piece.data, i);
      let xPosition = piece.x;
      let yPosition = piece.base;
      let finalWidth = clusterWidth;
      let finalHeight = piece.scaledValue;
      let xy = {
        x: 0,
        y: 0
      };

      if (!piece.negative) {
        yPosition -= piece.scaledValue;
      }

      if (projection === 'horizontal') {
        //TODO: NEGATIVE FOR HORIZONTAL
        yPosition = piece.x;
        xPosition = piece.base;
        finalHeight = clusterWidth;
        finalWidth = piece.scaledValue;
        xy.x = piece.scaledValue;

        if (piece.negative) {
          xPosition -= piece.scaledValue;
          xy.x = xPosition;
        }
      }

      let translate,
          markProps = {};

      if (projection === 'radial') {
        ({
          xPosition,
          yPosition,
          markProps,
          xy
        } = clusterRadialBarFeatureGenerator({
          innerRadius,
          offsetAngle,
          angleRange,
          ordset,
          adjustedSize,
          piece,
          i
        }));
        xy.x = xPosition;
      } else {
        xPosition += currentX;
        yPosition += currentY;
        markProps = {
          markType: 'rect',
          x: xPosition,
          y: yPosition,
          width: Math.max(0, finalWidth),
          height: Math.max(0, finalHeight),
          rx: 0,
          ry: 0
        };

        if (projection === 'vertical') {
          xy.x = xPosition;
        }
      }

      const eventListeners = eventListenersGenerator(piece, i);
      xy.y = yPosition;
      xy.middle = clusterWidth / 2;
      xy.height = finalHeight;
      xy.width = finalWidth;

      if (icon && projection !== 'radial') {
        customMark = iconBarCustomMark({
          icon,
          iconPadding,
          resize,
          projection,
          finalHeight,
          finalWidth,
          styleFn,
          renderValue,
          classFn
        });
      } else if (icon && projection === 'radial') {
        console.error('Icons are currently unsupported on radial charts');
      }

      const renderElementObject = customMark ? React$1.createElement("g", {
        key: `piece-${piece.renderKey}`,
        transform:  `translate(${xPosition},${yPosition})`
      }, customMark({ ...piece.data,
        ...piece,
        x: xPosition,
        y: yPosition
      }, i, { ...xy,
        baseMarkProps,
        renderMode,
        styleFn,
        classFn,
        adjustedSize,
        chartSize,
        margin,
        rScale
      })) : {
        className: classFn({ ...piece,
          ...piece.data
        }, i),
        renderMode: renderValue,
        key: `piece-${piece.renderKey}`,
        transform: translate,
        style: styleFn({ ...piece,
          ...piece.data
        }, ordsetI),
        ...markProps,
        ...eventListeners
      };
      const calculatedPiece = {
        o: key,
        xy,
        piece,
        renderElement: renderElementObject
      };

      if (projection === 'horizontal') {
        currentY += finalHeight;
      } else {
        currentX += finalWidth;
      } //        currentOffset += pieceSize


      return calculatedPiece;
    });
    allCalculatedPieces = [...allCalculatedPieces, ...calculatedPieces];
  });
  return allCalculatedPieces;
};

const ClusterBar = props => {};

ClusterBar.layout = clusterBarLayout;
ClusterBar.propTypes = { ...Bar.propTypes
};
ClusterBar.defaultProps = { ...Bar.defaultProps
};

const BarPercent = props => {};

BarPercent.layout = barLayout;
BarPercent.Bar = { ...Bar.propTypes
};
BarPercent.defaultProps = { ...Bar.defaultProps
};

function tree_add(d) {
  var x = +this._x.call(null, d),
      y = +this._y.call(null, d);
  return add(this.cover(x, y), x, y, d);
}

function add(tree, x, y, d) {
  if (isNaN(x) || isNaN(y)) return tree; // ignore invalid points

  var parent,
      node = tree._root,
      leaf = {data: d},
      x0 = tree._x0,
      y0 = tree._y0,
      x1 = tree._x1,
      y1 = tree._y1,
      xm,
      ym,
      xp,
      yp,
      right,
      bottom,
      i,
      j;

  // If the tree is empty, initialize the root as a leaf.
  if (!node) return tree._root = leaf, tree;

  // Find the existing leaf for the new point, or add it.
  while (node.length) {
    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
    if (parent = node, !(node = node[i = bottom << 1 | right])) return parent[i] = leaf, tree;
  }

  // Is the new point is exactly coincident with the existing point?
  xp = +tree._x.call(null, node.data);
  yp = +tree._y.call(null, node.data);
  if (x === xp && y === yp) return leaf.next = node, parent ? parent[i] = leaf : tree._root = leaf, tree;

  // Otherwise, split the leaf node until the old and new point are separated.
  do {
    parent = parent ? parent[i] = new Array(4) : tree._root = new Array(4);
    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
  } while ((i = bottom << 1 | right) === (j = (yp >= ym) << 1 | (xp >= xm)));
  return parent[j] = node, parent[i] = leaf, tree;
}

function addAll(data) {
  var d, i, n = data.length,
      x,
      y,
      xz = new Array(n),
      yz = new Array(n),
      x0 = Infinity,
      y0 = Infinity,
      x1 = -Infinity,
      y1 = -Infinity;

  // Compute the points and their extent.
  for (i = 0; i < n; ++i) {
    if (isNaN(x = +this._x.call(null, d = data[i])) || isNaN(y = +this._y.call(null, d))) continue;
    xz[i] = x;
    yz[i] = y;
    if (x < x0) x0 = x;
    if (x > x1) x1 = x;
    if (y < y0) y0 = y;
    if (y > y1) y1 = y;
  }

  // If there were no (valid) points, inherit the existing extent.
  if (x1 < x0) x0 = this._x0, x1 = this._x1;
  if (y1 < y0) y0 = this._y0, y1 = this._y1;

  // Expand the tree to cover the new points.
  this.cover(x0, y0).cover(x1, y1);

  // Add the new points.
  for (i = 0; i < n; ++i) {
    add(this, xz[i], yz[i], data[i]);
  }

  return this;
}

function tree_cover(x, y) {
  if (isNaN(x = +x) || isNaN(y = +y)) return this; // ignore invalid points

  var x0 = this._x0,
      y0 = this._y0,
      x1 = this._x1,
      y1 = this._y1;

  // If the quadtree has no extent, initialize them.
  // Integer extent are necessary so that if we later double the extent,
  // the existing quadrant boundaries don’t change due to floating point error!
  if (isNaN(x0)) {
    x1 = (x0 = Math.floor(x)) + 1;
    y1 = (y0 = Math.floor(y)) + 1;
  }

  // Otherwise, double repeatedly to cover.
  else if (x0 > x || x > x1 || y0 > y || y > y1) {
    var z = x1 - x0,
        node = this._root,
        parent,
        i;

    switch (i = (y < (y0 + y1) / 2) << 1 | (x < (x0 + x1) / 2)) {
      case 0: {
        do parent = new Array(4), parent[i] = node, node = parent;
        while (z *= 2, x1 = x0 + z, y1 = y0 + z, x > x1 || y > y1);
        break;
      }
      case 1: {
        do parent = new Array(4), parent[i] = node, node = parent;
        while (z *= 2, x0 = x1 - z, y1 = y0 + z, x0 > x || y > y1);
        break;
      }
      case 2: {
        do parent = new Array(4), parent[i] = node, node = parent;
        while (z *= 2, x1 = x0 + z, y0 = y1 - z, x > x1 || y0 > y);
        break;
      }
      case 3: {
        do parent = new Array(4), parent[i] = node, node = parent;
        while (z *= 2, x0 = x1 - z, y0 = y1 - z, x0 > x || y0 > y);
        break;
      }
    }

    if (this._root && this._root.length) this._root = node;
  }

  // If the quadtree covers the point already, just return.
  else return this;

  this._x0 = x0;
  this._y0 = y0;
  this._x1 = x1;
  this._y1 = y1;
  return this;
}

function tree_data() {
  var data = [];
  this.visit(function(node) {
    if (!node.length) do data.push(node.data); while (node = node.next)
  });
  return data;
}

function tree_extent(_) {
  return arguments.length
      ? this.cover(+_[0][0], +_[0][1]).cover(+_[1][0], +_[1][1])
      : isNaN(this._x0) ? undefined : [[this._x0, this._y0], [this._x1, this._y1]];
}

function Quad(node, x0, y0, x1, y1) {
  this.node = node;
  this.x0 = x0;
  this.y0 = y0;
  this.x1 = x1;
  this.y1 = y1;
}

function tree_find(x, y, radius) {
  var data,
      x0 = this._x0,
      y0 = this._y0,
      x1,
      y1,
      x2,
      y2,
      x3 = this._x1,
      y3 = this._y1,
      quads = [],
      node = this._root,
      q,
      i;

  if (node) quads.push(new Quad(node, x0, y0, x3, y3));
  if (radius == null) radius = Infinity;
  else {
    x0 = x - radius, y0 = y - radius;
    x3 = x + radius, y3 = y + radius;
    radius *= radius;
  }

  while (q = quads.pop()) {

    // Stop searching if this quadrant can’t contain a closer node.
    if (!(node = q.node)
        || (x1 = q.x0) > x3
        || (y1 = q.y0) > y3
        || (x2 = q.x1) < x0
        || (y2 = q.y1) < y0) continue;

    // Bisect the current quadrant.
    if (node.length) {
      var xm = (x1 + x2) / 2,
          ym = (y1 + y2) / 2;

      quads.push(
        new Quad(node[3], xm, ym, x2, y2),
        new Quad(node[2], x1, ym, xm, y2),
        new Quad(node[1], xm, y1, x2, ym),
        new Quad(node[0], x1, y1, xm, ym)
      );

      // Visit the closest quadrant first.
      if (i = (y >= ym) << 1 | (x >= xm)) {
        q = quads[quads.length - 1];
        quads[quads.length - 1] = quads[quads.length - 1 - i];
        quads[quads.length - 1 - i] = q;
      }
    }

    // Visit this point. (Visiting coincident points isn’t necessary!)
    else {
      var dx = x - +this._x.call(null, node.data),
          dy = y - +this._y.call(null, node.data),
          d2 = dx * dx + dy * dy;
      if (d2 < radius) {
        var d = Math.sqrt(radius = d2);
        x0 = x - d, y0 = y - d;
        x3 = x + d, y3 = y + d;
        data = node.data;
      }
    }
  }

  return data;
}

function tree_remove(d) {
  if (isNaN(x = +this._x.call(null, d)) || isNaN(y = +this._y.call(null, d))) return this; // ignore invalid points

  var parent,
      node = this._root,
      retainer,
      previous,
      next,
      x0 = this._x0,
      y0 = this._y0,
      x1 = this._x1,
      y1 = this._y1,
      x,
      y,
      xm,
      ym,
      right,
      bottom,
      i,
      j;

  // If the tree is empty, initialize the root as a leaf.
  if (!node) return this;

  // Find the leaf node for the point.
  // While descending, also retain the deepest parent with a non-removed sibling.
  if (node.length) while (true) {
    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
    if (!(parent = node, node = node[i = bottom << 1 | right])) return this;
    if (!node.length) break;
    if (parent[(i + 1) & 3] || parent[(i + 2) & 3] || parent[(i + 3) & 3]) retainer = parent, j = i;
  }

  // Find the point to remove.
  while (node.data !== d) if (!(previous = node, node = node.next)) return this;
  if (next = node.next) delete node.next;

  // If there are multiple coincident points, remove just the point.
  if (previous) return (next ? previous.next = next : delete previous.next), this;

  // If this is the root point, remove it.
  if (!parent) return this._root = next, this;

  // Remove this leaf.
  next ? parent[i] = next : delete parent[i];

  // If the parent now contains exactly one leaf, collapse superfluous parents.
  if ((node = parent[0] || parent[1] || parent[2] || parent[3])
      && node === (parent[3] || parent[2] || parent[1] || parent[0])
      && !node.length) {
    if (retainer) retainer[j] = node;
    else this._root = node;
  }

  return this;
}

function removeAll(data) {
  for (var i = 0, n = data.length; i < n; ++i) this.remove(data[i]);
  return this;
}

function tree_root() {
  return this._root;
}

function tree_size() {
  var size = 0;
  this.visit(function(node) {
    if (!node.length) do ++size; while (node = node.next)
  });
  return size;
}

function tree_visit(callback) {
  var quads = [], q, node = this._root, child, x0, y0, x1, y1;
  if (node) quads.push(new Quad(node, this._x0, this._y0, this._x1, this._y1));
  while (q = quads.pop()) {
    if (!callback(node = q.node, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1) && node.length) {
      var xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
      if (child = node[3]) quads.push(new Quad(child, xm, ym, x1, y1));
      if (child = node[2]) quads.push(new Quad(child, x0, ym, xm, y1));
      if (child = node[1]) quads.push(new Quad(child, xm, y0, x1, ym));
      if (child = node[0]) quads.push(new Quad(child, x0, y0, xm, ym));
    }
  }
  return this;
}

function tree_visitAfter(callback) {
  var quads = [], next = [], q;
  if (this._root) quads.push(new Quad(this._root, this._x0, this._y0, this._x1, this._y1));
  while (q = quads.pop()) {
    var node = q.node;
    if (node.length) {
      var child, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1, xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
      if (child = node[0]) quads.push(new Quad(child, x0, y0, xm, ym));
      if (child = node[1]) quads.push(new Quad(child, xm, y0, x1, ym));
      if (child = node[2]) quads.push(new Quad(child, x0, ym, xm, y1));
      if (child = node[3]) quads.push(new Quad(child, xm, ym, x1, y1));
    }
    next.push(q);
  }
  while (q = next.pop()) {
    callback(q.node, q.x0, q.y0, q.x1, q.y1);
  }
  return this;
}

function defaultX$1(d) {
  return d[0];
}

function tree_x(_) {
  return arguments.length ? (this._x = _, this) : this._x;
}

function defaultY$1(d) {
  return d[1];
}

function tree_y(_) {
  return arguments.length ? (this._y = _, this) : this._y;
}

function quadtree(nodes, x, y) {
  var tree = new Quadtree(x == null ? defaultX$1 : x, y == null ? defaultY$1 : y, NaN, NaN, NaN, NaN);
  return nodes == null ? tree : tree.addAll(nodes);
}

function Quadtree(x, y, x0, y0, x1, y1) {
  this._x = x;
  this._y = y;
  this._x0 = x0;
  this._y0 = y0;
  this._x1 = x1;
  this._y1 = y1;
  this._root = undefined;
}

function leaf_copy(leaf) {
  var copy = {data: leaf.data}, next = copy;
  while (leaf = leaf.next) next = next.next = {data: leaf.data};
  return copy;
}

var treeProto = quadtree.prototype = Quadtree.prototype;

treeProto.copy = function() {
  var copy = new Quadtree(this._x, this._y, this._x0, this._y0, this._x1, this._y1),
      node = this._root,
      nodes,
      child;

  if (!node) return copy;

  if (!node.length) return copy._root = leaf_copy(node), copy;

  nodes = [{source: node, target: copy._root = new Array(4)}];
  while (node = nodes.pop()) {
    for (var i = 0; i < 4; ++i) {
      if (child = node.source[i]) {
        if (child.length) nodes.push({source: child, target: node.target[i] = new Array(4)});
        else node.target[i] = leaf_copy(child);
      }
    }
  }

  return copy;
};

treeProto.add = tree_add;
treeProto.addAll = addAll;
treeProto.cover = tree_cover;
treeProto.data = tree_data;
treeProto.extent = tree_extent;
treeProto.find = tree_find;
treeProto.remove = tree_remove;
treeProto.removeAll = removeAll;
treeProto.root = tree_root;
treeProto.size = tree_size;
treeProto.visit = tree_visit;
treeProto.visitAfter = tree_visitAfter;
treeProto.x = tree_x;
treeProto.y = tree_y;

function constant$9(x) {
  return function() {
    return x;
  };
}

function jiggle() {
  return (Math.random() - 0.5) * 1e-6;
}

function x$2(d) {
  return d.x + d.vx;
}

function y$2(d) {
  return d.y + d.vy;
}

function forceCollide(radius) {
  var nodes,
      radii,
      strength = 1,
      iterations = 1;

  if (typeof radius !== "function") radius = constant$9(radius == null ? 1 : +radius);

  function force() {
    var i, n = nodes.length,
        tree,
        node,
        xi,
        yi,
        ri,
        ri2;

    for (var k = 0; k < iterations; ++k) {
      tree = quadtree(nodes, x$2, y$2).visitAfter(prepare);
      for (i = 0; i < n; ++i) {
        node = nodes[i];
        ri = radii[node.HospitalFacilities], ri2 = ri * ri;
        xi = node.x + node.vx;
        yi = node.y + node.vy;
        tree.visit(apply);
      }
    }

    function apply(quad, x0, y0, x1, y1) {
      var data = quad.data, rj = quad.r, r = ri + rj;
      if (data) {
        if (data.HospitalFacilities > node.HospitalFacilities) {
          var x = xi - data.x - data.vx,
              y = yi - data.y - data.vy,
              l = x * x + y * y;
          if (l < r * r) {
            if (x === 0) x = jiggle(), l += x * x;
            if (y === 0) y = jiggle(), l += y * y;
            l = (r - (l = Math.sqrt(l))) / l * strength;
            node.vx += (x *= l) * (r = (rj *= rj) / (ri2 + rj));
            node.vy += (y *= l) * r;
            data.vx -= x * (r = 1 - r);
            data.vy -= y * r;
          }
        }
        return;
      }
      return x0 > xi + r || x1 < xi - r || y0 > yi + r || y1 < yi - r;
    }
  }

  function prepare(quad) {
    if (quad.data) return quad.r = radii[quad.data.HospitalFacilities];
    for (var i = quad.r = 0; i < 4; ++i) {
      if (quad[i] && quad[i].r > quad.r) {
        quad.r = quad[i].r;
      }
    }
  }

  function initialize() {
    if (!nodes) return;
    var i, n = nodes.length, node;
    radii = new Array(n);
    for (i = 0; i < n; ++i) node = nodes[i], radii[node.HospitalFacilities] = +radius(node, i, nodes);
  }

  force.initialize = function(_) {
    nodes = _;
    initialize();
  };

  force.iterations = function(_) {
    return arguments.length ? (iterations = +_, force) : iterations;
  };

  force.strength = function(_) {
    return arguments.length ? (strength = +_, force) : strength;
  };

  force.radius = function(_) {
    return arguments.length ? (radius = typeof _ === "function" ? _ : constant$9(+_), initialize(), force) : radius;
  };

  return force;
}

function index(d) {
  return d.HospitalFacilities;
}

function find(nodeById, nodeId) {
  var node = nodeById.get(nodeId);
  if (!node) throw new Error("missing: " + nodeId);
  return node;
}

function forceLink(links) {
  var id = index,
      strength = defaultStrength,
      strengths,
      distance = constant$9(30),
      distances,
      nodes,
      count,
      bias,
      iterations = 1;

  if (links == null) links = [];

  function defaultStrength(link) {
    return 1 / Math.min(count[link.source.HospitalFacilities], count[link.target.HospitalFacilities]);
  }

  function force(alpha) {
    for (var k = 0, n = links.length; k < iterations; ++k) {
      for (var i = 0, link, source, target, x, y, l, b; i < n; ++i) {
        link = links[i], source = link.source, target = link.target;
        x = target.x + target.vx - source.x - source.vx || jiggle();
        y = target.y + target.vy - source.y - source.vy || jiggle();
        l = Math.sqrt(x * x + y * y);
        l = (l - distances[i]) / l * alpha * strengths[i];
        x *= l, y *= l;
        target.vx -= x * (b = bias[i]);
        target.vy -= y * b;
        source.vx += x * (b = 1 - b);
        source.vy += y * b;
      }
    }
  }

  function initialize() {
    if (!nodes) return;

    var i,
        n = nodes.length,
        m = links.length,
        nodeById = new Map(nodes.map((d, i) => [id(d, i, nodes), d])),
        link;

    for (i = 0, count = new Array(n); i < m; ++i) {
      link = links[i], link.index = i;
      if (typeof link.source !== "object") link.source = find(nodeById, link.source);
      if (typeof link.target !== "object") link.target = find(nodeById, link.target);
      count[link.source.HospitalFacilities] = (count[link.source.HospitalFacilities] || 0) + 1;
      count[link.target.HospitalFacilities] = (count[link.target.HospitalFacilities] || 0) + 1;
    }

    for (i = 0, bias = new Array(m); i < m; ++i) {
      link = links[i], bias[i] = count[link.source.HospitalFacilities] / (count[link.source.HospitalFacilities] + count[link.target.HospitalFacilities]);
    }

    strengths = new Array(m), initializeStrength();
    distances = new Array(m), initializeDistance();
  }

  function initializeStrength() {
    if (!nodes) return;

    for (var i = 0, n = links.length; i < n; ++i) {
      strengths[i] = +strength(links[i], i, links);
    }
  }

  function initializeDistance() {
    if (!nodes) return;

    for (var i = 0, n = links.length; i < n; ++i) {
      distances[i] = +distance(links[i], i, links);
    }
  }

  force.initialize = function(_) {
    nodes = _;
    initialize();
  };

  force.links = function(_) {
    return arguments.length ? (links = _, initialize(), force) : links;
  };

  force.id = function(_) {
    return arguments.length ? (id = _, force) : id;
  };

  force.iterations = function(_) {
    return arguments.length ? (iterations = +_, force) : iterations;
  };

  force.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : constant$9(+_), initializeStrength(), force) : strength;
  };

  force.distance = function(_) {
    return arguments.length ? (distance = typeof _ === "function" ? _ : constant$9(+_), initializeDistance(), force) : distance;
  };

  return force;
}

function x$3(d) {
  return d.x;
}

function y$3(d) {
  return d.y;
}

var initialRadius = 10,
    initialAngle = Math.PI * (3 - Math.sqrt(5));

function forceSimulation(nodes) {
  var simulation,
      alpha = 1,
      alphaMin = 0.001,
      alphaDecay = 1 - Math.pow(alphaMin, 1 / 300),
      alphaTarget = 0,
      velocityDecay = 0.6,
      forces = new Map(),
      stepper = timer(step),
      event = dispatch("tick", "end");

  if (nodes == null) nodes = [];

  function step() {
    tick();
    event.call("tick", simulation);
    if (alpha < alphaMin) {
      stepper.stop();
      event.call("end", simulation);
    }
  }

  function tick(iterations) {
    var i, n = nodes.length, node;

    if (iterations === undefined) iterations = 1;

    for (var k = 0; k < iterations; ++k) {
      alpha += (alphaTarget - alpha) * alphaDecay;

      forces.forEach(function(force) {
        force(alpha);
      });

      for (i = 0; i < n; ++i) {
        node = nodes[i];
        if (node.fx == null) node.x += node.vx *= velocityDecay;
        else node.x = node.fx, node.vx = 0;
        if (node.fy == null) node.y += node.vy *= velocityDecay;
        else node.y = node.fy, node.vy = 0;
      }
    }

    return simulation;
  }

  function initializeNodes() {
    for (var i = 0, n = nodes.length, node; i < n; ++i) {
      node = nodes[i], node.index = i;
      if (node.fx != null) node.x = node.fx;
      if (node.fy != null) node.y = node.fy;
      if (isNaN(node.x) || isNaN(node.y)) {
        var radius = initialRadius * Math.sqrt(i), angle = i * initialAngle;
        node.x = radius * Math.cos(angle);
        node.y = radius * Math.sin(angle);
      }
      if (isNaN(node.vx) || isNaN(node.vy)) {
        node.vx = node.vy = 0;
      }
    }
  }

  function initializeForce(force) {
    if (force.initialize) force.initialize(nodes);
    return force;
  }

  initializeNodes();

  return simulation = {
    tick: tick,

    restart: function() {
      return stepper.restart(step), simulation;
    },

    stop: function() {
      return stepper.stop(), simulation;
    },

    nodes: function(_) {
      return arguments.length ? (nodes = _, initializeNodes(), forces.forEach(initializeForce), simulation) : nodes;
    },

    alpha: function(_) {
      return arguments.length ? (alpha = +_, simulation) : alpha;
    },

    alphaMin: function(_) {
      return arguments.length ? (alphaMin = +_, simulation) : alphaMin;
    },

    alphaDecay: function(_) {
      return arguments.length ? (alphaDecay = +_, simulation) : +alphaDecay;
    },

    alphaTarget: function(_) {
      return arguments.length ? (alphaTarget = +_, simulation) : alphaTarget;
    },

    velocityDecay: function(_) {
      return arguments.length ? (velocityDecay = 1 - _, simulation) : 1 - velocityDecay;
    },

    force: function(name, _) {
      return arguments.length > 1 ? ((_ == null ? forces.delete(name) : forces.set(name, initializeForce(_))), simulation) : forces.get(name);
    },

    find: function(x, y, radius) {
      var i = 0,
          n = nodes.length,
          dx,
          dy,
          d2,
          node,
          closest;

      if (radius == null) radius = Infinity;
      else radius *= radius;

      for (i = 0; i < n; ++i) {
        node = nodes[i];
        dx = x - node.x;
        dy = y - node.y;
        d2 = dx * dx + dy * dy;
        if (d2 < radius) closest = node, radius = d2;
      }

      return closest;
    },

    on: function(name, _) {
      return arguments.length > 1 ? (event.on(name, _), simulation) : event.on(name);
    }
  };
}

function forceManyBody() {
  var nodes,
      node,
      alpha,
      strength = constant$9(-30),
      strengths,
      distanceMin2 = 1,
      distanceMax2 = Infinity,
      theta2 = 0.81;

  function force(_) {
    var i, n = nodes.length, tree = quadtree(nodes, x$3, y$3).visitAfter(accumulate);
    for (alpha = _, i = 0; i < n; ++i) node = nodes[i], tree.visit(apply);
  }

  function initialize() {
    if (!nodes) return;
    var i, n = nodes.length, node;
    strengths = new Array(n);
    for (i = 0; i < n; ++i) node = nodes[i], strengths[node.HospitalFacilities] = +strength(node, i, nodes);
  }

  function accumulate(quad) {
    var strength = 0, q, c, weight = 0, x, y, i;

    // For internal nodes, accumulate forces from child quadrants.
    if (quad.length) {
      for (x = y = i = 0; i < 4; ++i) {
        if ((q = quad[i]) && (c = Math.abs(q.value))) {
          strength += q.value, weight += c, x += c * q.x, y += c * q.y;
        }
      }
      quad.x = x / weight;
      quad.y = y / weight;
    }

    // For leaf nodes, accumulate forces from coincident quadrants.
    else {
      q = quad;
      q.x = q.data.x;
      q.y = q.data.y;
      do strength += strengths[q.data.HospitalFacilities];
      while (q = q.next);
    }

    quad.value = strength;
  }

  function apply(quad, x1, _, x2) {
    if (!quad.value) return true;

    var x = quad.x - node.x,
        y = quad.y - node.y,
        w = x2 - x1,
        l = x * x + y * y;

    // Apply the Barnes-Hut approximation if possible.
    // Limit forces for very close nodes; randomize direction if coincident.
    if (w * w / theta2 < l) {
      if (l < distanceMax2) {
        if (x === 0) x = jiggle(), l += x * x;
        if (y === 0) y = jiggle(), l += y * y;
        if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);
        node.vx += x * quad.value * alpha / l;
        node.vy += y * quad.value * alpha / l;
      }
      return true;
    }

    // Otherwise, process points directly.
    else if (quad.length || l >= distanceMax2) return;

    // Limit forces for very close nodes; randomize direction if coincident.
    if (quad.data !== node || quad.next) {
      if (x === 0) x = jiggle(), l += x * x;
      if (y === 0) y = jiggle(), l += y * y;
      if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);
    }

    do if (quad.data !== node) {
      w = strengths[quad.data.HospitalFacilities] * alpha / l;
      node.vx += x * w;
      node.vy += y * w;
    } while (quad = quad.next);
  }

  force.initialize = function(_) {
    nodes = _;
    initialize();
  };

  force.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : constant$9(+_), initialize(), force) : strength;
  };

  force.distanceMin = function(_) {
    return arguments.length ? (distanceMin2 = _ * _, force) : Math.sqrt(distanceMin2);
  };

  force.distanceMax = function(_) {
    return arguments.length ? (distanceMax2 = _ * _, force) : Math.sqrt(distanceMax2);
  };

  force.theta = function(_) {
    return arguments.length ? (theta2 = _ * _, force) : Math.sqrt(theta2);
  };

  return force;
}

function forceX(x) {
  var strength = constant$9(0.1),
      nodes,
      strengths,
      xz;

  if (typeof x !== "function") x = constant$9(x == null ? 0 : +x);

  function force(alpha) {
    for (var i = 0, n = nodes.length, node; i < n; ++i) {
      node = nodes[i], node.vx += (xz[i] - node.x) * strengths[i] * alpha;
    }
  }

  function initialize() {
    if (!nodes) return;
    var i, n = nodes.length;
    strengths = new Array(n);
    xz = new Array(n);
    for (i = 0; i < n; ++i) {
      strengths[i] = isNaN(xz[i] = +x(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
    }
  }

  force.initialize = function(_) {
    nodes = _;
    initialize();
  };

  force.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : constant$9(+_), initialize(), force) : strength;
  };

  force.x = function(_) {
    return arguments.length ? (x = typeof _ === "function" ? _ : constant$9(+_), initialize(), force) : x;
  };

  return force;
}

function forceY(y) {
  var strength = constant$9(0.1),
      nodes,
      strengths,
      yz;

  if (typeof y !== "function") y = constant$9(y == null ? 0 : +y);

  function force(alpha) {
    for (var i = 0, n = nodes.length, node; i < n; ++i) {
      node = nodes[i], node.vy += (yz[i] - node.y) * strengths[i] * alpha;
    }
  }

  function initialize() {
    if (!nodes) return;
    var i, n = nodes.length;
    strengths = new Array(n);
    yz = new Array(n);
    for (i = 0; i < n; ++i) {
      strengths[i] = isNaN(yz[i] = +y(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
    }
  }

  force.initialize = function(_) {
    nodes = _;
    initialize();
  };

  force.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : constant$9(+_), initialize(), force) : strength;
  };

  force.y = function(_) {
    return arguments.length ? (y = typeof _ === "function" ? _ : constant$9(+_), initialize(), force) : y;
  };

  return force;
}

const swarmLayout = ({
  iterations = 120,
  r,
  strength,
  customMark,
  data,
  renderMode,
  eventListenersGenerator,
  styleFn,
  projection,
  classFn,
  adjustedSize,
  chartSize,
  margin,
  baseMarkProps,
  rScale
}) => {
  let allCalculatedPieces = [];
  const columnKeys = Object.keys(data);
  columnKeys.forEach((key, ordsetI) => {
    const oColumn = data[key];
    const anglePiece = 1 / columnKeys.length;
    const oData = oColumn.pieceData;
    const adjustedColumnWidth = oColumn.width;
    const circleRadius = r || Math.max(2, Math.min(5, 4 * adjustedColumnWidth / oData.length));
    const simulation = forceSimulation(oData).force('y', forceY(d => d.scaledValue).strength(strength || 2)).force('x', forceX(oColumn.middle)).force('collide', forceCollide(circleRadius)).stop();

    if (projection === 'vertical') {
      simulation.force('y', forceY(d => d.scaledVerticalValue).strength(strength || 2));
    }

    for (let i = 0; i < iterations; ++i) simulation.tick();

    const calculatedPieces = oData.map((piece, i) => {
      const renderValue = renderMode && renderMode(piece.data, i);
      let xPosition = piece.x;
      let yPosition = piece.y;

      if (projection === 'horizontal') {
        yPosition = piece.x;
        xPosition = piece.y;
      } else if (projection === 'radial') {
        const angle = oColumn.pct_middle;
        xPosition = (piece.x - oColumn.middle) / adjustedColumnWidth * anglePiece;
        const rPosition = piece.scaledValue / 2;
        const xAngle = angle + xPosition;
        const baseCentroid = pointOnArcAtAngle([adjustedSize[0] / 2, adjustedSize[1] / 2], xAngle, rPosition);
        xPosition = baseCentroid[0];
        yPosition = baseCentroid[1];
      }

      const actualCircleRadius = typeof circleRadius === 'function' ? circleRadius(piece, i) : circleRadius;
      const eventListeners = eventListenersGenerator(piece, i);
      const renderElementObject = customMark ? React$1.createElement("g", {
        key: `piece-${piece.renderKey}`,
        transform: `translate(${xPosition},${yPosition})`
      }, customMark({ ...piece.data,
        ...piece,
        x: xPosition,
        y: yPosition
      }, i, {
        x: xPosition,
        y: yPosition,
        r: circleRadius,
        baseMarkProps,
        renderMode,
        styleFn,
        classFn,
        adjustedSize,
        chartSize,
        margin,
        rScale
      })) : {
        className: classFn({ ...piece,
          ...piece.data
        }, i),
        markType: 'rect',
        renderMode: renderValue,
        key: `piece-${piece.renderKey}`,
        height: actualCircleRadius * 2,
        width: actualCircleRadius * 2,
        x: xPosition - actualCircleRadius,
        y: yPosition - actualCircleRadius,
        rx: actualCircleRadius,
        ry: actualCircleRadius,
        style: styleFn({ ...piece,
          ...piece.data
        }, ordsetI),
        ...eventListeners
      };
      const calculatedPiece = {
        o: key,
        xy: {
          x: xPosition,
          y: yPosition
        },
        piece,
        renderElement: renderElementObject
      };
      return calculatedPiece;
    });
    allCalculatedPieces = [...allCalculatedPieces, ...calculatedPieces];
  });
  return allCalculatedPieces;
};

const Swarm = props => {};

Swarm.layout = swarmLayout;
Swarm.propTypes = { ...OrdinalPlot.propTypes,
  r: propTypes.oneOfType([propTypes.number, propTypes.func]),
  iterations: propTypes.number,
  strength: propTypes.number
};
Swarm.defaultProps = { ...OrdinalPlot.defaultProps,
  r: 10,
  iterations: 120,
  strength: 2
};

const NetworkPlot = props => {
  return null;
};

NetworkPlot.propTypes = {
  customMark: propTypes.func,
  nodeUseCanvas: propTypes.bool,
  edgeUseCanvas: propTypes.bool,
  graph: propTypes.oneOfType([propTypes.array, propTypes.func, propTypes.object]),
  nodes: propTypes.oneOfType([propTypes.array, propTypes.object]),
  edges: propTypes.oneOfType([propTypes.array, propTypes.object]),
  nodeIDAccessor: propTypes.oneOfType([propTypes.func, propTypes.string]),
  nodeLabels: propTypes.oneOfType([propTypes.bool, propTypes.func]),
  nodeRenderMode: propTypes.oneOfType([propTypes.func, propTypes.string]),
  nodeStyle: propTypes.oneOfType([propTypes.func, propTypes.object]),
  nodeClass: propTypes.oneOfType([propTypes.func, propTypes.string]),
  nodeSizeAccessor: propTypes.oneOfType([propTypes.func, propTypes.number]),
  customNodeIcon: propTypes.func,
  sourceAccessor: propTypes.oneOfType([propTypes.string, propTypes.func]),
  targetAccessor: propTypes.oneOfType([propTypes.string, propTypes.func]),
  //A string (One of 'none', 'curve', 'linearc','ribbon','arrowhead','halfarrow','nail','comet','taffy')
  edgeType: propTypes.oneOfType([propTypes.string, propTypes.func, propTypes.object]),
  edgeStyle: propTypes.oneOfType([propTypes.func, propTypes.object]),
  edgeClass: propTypes.oneOfType([propTypes.func, propTypes.string]),
  edgeRenderMode: propTypes.oneOfType([propTypes.func, propTypes.string]),
  customEdgeIcon: propTypes.func,
  filterRenderedNodes: propTypes.func,
  edgeRenderKey: propTypes.func,
  nodeRenderKey: propTypes.func,
  hierarchyChildren: propTypes.func
};
NetworkPlot.defaultProps = {
  filterRenderedNodes: d => d.id !== 'root-generated'
};
NetworkPlot.layout = null;

const PathDiagram = props => {};

PathDiagram.propTypes = { ...NetworkPlot.propTypes,
  zoom: propTypes.bool,
  projection: propTypes.oneOf(['vertical', 'horizontal']),
  orient: propTypes.oneOf(['left', 'right', 'justify', 'center']),
  iterations: propTypes.number,
  nodeWidth: propTypes.number,
  nodePaddingRatio: propTypes.number,
  nodePadding: propTypes.number,
  padAngle: propTypes.number,
  sortGroups: propTypes.func,
  groupWidth: propTypes.number
};
PathDiagram.defaultProps = { ...NetworkPlot.defaultProps,
  groupWidth: 20,
  zoom: true,
  // Zoom the laid out nodes in or out so that they fit the specified size, can also be "stretch" if you want zoom not to maintain aspect ratio
  projection: 'horizontal',
  // Accepts (horizontal|vertical) direction of flow in the diagram
  orient: 'center',
  // Accepts (left|right|justify|center) sankey node alignment strategy
  iterations: 100,
  // How many times to run the layout algorithm
  nodeWidth: 24,
  // Thickness of node along the axis of flow
  nodePaddingRatio: 0.5 // The ratio of nodes to available space, only if nodePadding is not set

};

const arcEdgeGenerator = ({
  size
}) => {
  const yAdjust = size[1] / size[0];

  function arcDiagramArc(d) {
    const draw = line$1().curve(curveBasis);
    const midX = (d.source.x + d.target.x) / 2;
    const midY = d.source.x - d.target.x;
    return draw([[d.source.x, 0], [midX, midY * yAdjust], [d.target.x, 0]]);
  }

  return ({
    d,
    i,
    styleFn,
    renderMode,
    key,
    className,
    baseMarkProps
  }) => {
    return React$1.createElement(lib_2, _extends({}, baseMarkProps, {
      renderMode: renderMode ? renderMode(d, i) : undefined,
      key: key,
      className: className,
      simpleInterpolate: true,
      markType: "path",
      transform: `translate(0,${size[1] / 2})`,
      d: arcDiagramArc(d),
      style: styleFn(d, i),
      "aria-label": `Connection from ${d.source.id} to ${d.target.id}`,
      tabIndex: -1
    }));
  };
};

const Arc = props => {};

Arc.edgeGenerator = arcEdgeGenerator;
Arc.propTypes = { ...PathDiagram.propTypes
};
Arc.defaultProps = { ...PathDiagram.defaultProps
};

const chordNodeGenerator = ({
  size
}) => ({
  d,
  i,
  styleFn,
  renderMode,
  key,
  className,
  baseMarkProps
}) => React$1.createElement(lib_2, _extends({}, baseMarkProps, {
  renderMode: renderMode ? renderMode(d, i) : undefined,
  key: key,
  className: className,
  transform: `translate(${size[0] / 2},${size[1] / 2})`,
  markType: "path",
  d: d.d,
  style: styleFn(d, i),
  "aria-label": `Node ${d.id}`,
  tabIndex: -1
}));

const chordEdgeGenerator = ({
  size
}) => ({
  d,
  i,
  styleFn,
  renderMode,
  key,
  className,
  baseMarkProps
}) => React$1.createElement(lib_2, _extends({}, baseMarkProps, {
  renderMode: renderMode ? renderMode(d, i) : undefined,
  key: key,
  className: className,
  simpleInterpolate: true,
  transform: `translate(${size[0] / 2},${size[1] / 2})`,
  markType: "path",
  d: d.d,
  style: styleFn(d, i),
  "aria-label": `Connection from ${d.source.id} to ${d.target.id}`,
  tabIndex: -1
}));

const Chord = props => {
  return null;
};

Chord.nodeGenerator = chordNodeGenerator;
Chord.edgeGenerator = chordEdgeGenerator;
Chord.propTypes = { ...PathDiagram.propTypes
};
Chord.defaultProps = { ...PathDiagram.defaultProps
};

const HierarchicalDiagram = props => {};

HierarchicalDiagram.propTypes = { ...NetworkPlot.propTypes,
  zoom: propTypes.bool,
  padding: propTypes.number,
  projection: propTypes.oneOf(['vertical', 'horizontal']),
  hierarhcySum: propTypes.func,
  hierarchyChildren: propTypes.func
};
HierarchicalDiagram.defaultProps = { ...NetworkPlot.defaultProps,
  zoom: true,
  // Zoom the laid out nodes in or out so that they fit the specified size, can also be "stretch" if you want zoom not to maintain aspect ratio
  padding: 0,
  // Pixel value to separate individual nodes from each other
  projection: 'vertical',
  // Accepts (vertical|horizontal|radial) whether to display the chart with steps laid out on the y axis (vertical) or the x axis (horizontal)
  hierarhcySum: d => d.value,
  // Function for summing up children values into parent totals
  hierarchyChildren: d => d.children
};

const circleNodeGenerator = () => ({
  d,
  i,
  styleFn,
  renderMode,
  key,
  className,
  transform,
  baseMarkProps
}) => {
  //this is repetitious
  return React$1__default.createElement(lib_2, _extends({}, baseMarkProps, {
    key: key,
    transform: transform,
    markType: "rect",
    width: d.nodeSize * 2,
    height: d.nodeSize * 2,
    ry: d.nodeSize * 2,
    rx: d.nodeSize * 2,
    x: -d.nodeSize,
    y: -d.nodeSize,
    style: styleFn(d, i),
    renderMode: renderMode ? renderMode(d, i) : undefined,
    className: className,
    "aria-label": `Node ${d.id}`,
    tabIndex: -1
  }));
};

const CirclePack = props => {};

CirclePack.nodeGenerator = circleNodeGenerator;
CirclePack.propTypes = { ...HierarchicalDiagram.propTypes
};
CirclePack.defaultProps = { ...HierarchicalDiagram.defaultProps
};

const Cluster = props => {};

Cluster.propTypes = { ...HierarchicalDiagram.propTypes
};
Cluster.defaultProps = { ...HierarchicalDiagram.defaultProps
};

const dedupeRibbonPoints = (weight = 1) => (p, c) => {
  const l = p[p.length - 1];

  if (!l || Math.round(l.x / weight) !== Math.round(c.x / weight) || Math.round(l.y / weight) !== Math.round(c.y / weight)) {
    p.push(c);
  }

  return p;
}; // FROM d3-svg-ribbon


const linearRibbon = () => {
  const _lineConstructor = line$1();

  let _xAccessor = function (d) {
    return d.x;
  };

  let _yAccessor = function (d) {
    return d.y;
  };

  let _rAccessor = function (d) {
    return d.r;
  };

  let _interpolator = curveLinearClosed;

  function _ribbon(pathData) {
    if (pathData.multiple) {
      const original_r = _rAccessor;
      const parallelTotal = pathData.multiple.reduce((p, c) => p + c.weight, 0);

      _rAccessor = () => parallelTotal;

      const totalPoints = buildRibbon(pathData.points);
      let currentPoints = totalPoints.filter(d => d.direction === 'forward').reduce(dedupeRibbonPoints(), []);
      const allRibbons = [];
      pathData.multiple.forEach((siblingPath, siblingI) => {
        _rAccessor = () => siblingPath.weight;

        const currentRibbon = buildRibbon(currentPoints);
        allRibbons.push(currentRibbon);
        const nextSibling = pathData.multiple[siblingI + 1];

        if (nextSibling) {
          const currentLeftSide = currentRibbon.reverse().filter(d => d.direction === 'back').reduce(dedupeRibbonPoints(), []);

          _rAccessor = () => nextSibling.weight;

          const leftHandInflatedRibbon = buildRibbon(currentLeftSide);
          currentPoints = leftHandInflatedRibbon.reverse().filter(d => d.direction === 'back').reduce(dedupeRibbonPoints(), []);
        }
      });
      _rAccessor = original_r;
      return allRibbons.map(d => _lineConstructor.x(_xAccessor).y(_yAccessor).curve(_interpolator)(d));
    }

    const bothPoints = buildRibbon(pathData).reduce(dedupeRibbonPoints(), []);
    return _lineConstructor.x(_xAccessor).y(_yAccessor).curve(_interpolator)(bothPoints);
  }

  _ribbon.x = function (_value) {
    if (!arguments.length) return _xAccessor;
    _xAccessor = _value;
    return _ribbon;
  };

  _ribbon.y = function (_value) {
    if (!arguments.length) return _yAccessor;
    _yAccessor = _value;
    return _ribbon;
  };

  _ribbon.r = function (_value) {
    if (!arguments.length) return _rAccessor;
    _rAccessor = _value;
    return _ribbon;
  };

  _ribbon.interpolate = function (_value) {
    if (!arguments.length) return _interpolator;
    _interpolator = _value;
    return _ribbon;
  };

  return _ribbon;

  function offsetEdge(d) {
    const diffX = _yAccessor(d.target) - _yAccessor(d.source);

    const diffY = _xAccessor(d.target) - _xAccessor(d.source);

    const angle0 = Math.atan2(diffY, diffX) + Math.PI / 2;
    const angle1 = angle0 + Math.PI * 0.5;
    const angle2 = angle0 + Math.PI * 0.5;
    const x1 = _xAccessor(d.source) + _rAccessor(d.source) * Math.cos(angle1);
    const y1 = _yAccessor(d.source) - _rAccessor(d.source) * Math.sin(angle1);
    const x2 = _xAccessor(d.target) + _rAccessor(d.target) * Math.cos(angle2);
    const y2 = _yAccessor(d.target) - _rAccessor(d.target) * Math.sin(angle2);
    return {
      x1: x1,
      y1: y1,
      x2: x2,
      y2: y2
    };
  }

  function buildRibbon(points) {
    const bothCode = [];
    let x = 0;
    let transformedPoints = {
      x1: 0,
      y1: 0,
      x2: 0,
      y2: 0
    };

    while (x < points.length) {
      if (x !== points.length - 1) {
        transformedPoints = offsetEdge({
          source: points[x],
          target: points[x + 1]
        });
        const p1 = {
          x: transformedPoints.x1,
          y: transformedPoints.y1,
          direction: 'forward'
        };
        const p2 = {
          x: transformedPoints.x2,
          y: transformedPoints.y2,
          direction: 'forward'
        };
        bothCode.push(p1, p2);

        if (bothCode.length > 3) {
          const l = bothCode.length - 1;
          const lineA = {
            a: bothCode[l - 3],
            b: bothCode[l - 2]
          };
          const lineB = {
            a: bothCode[l - 1],
            b: bothCode[l]
          };
          const intersect = findIntersect(lineA.a.x, lineA.a.y, lineA.b.x, lineA.b.y, lineB.a.x, lineB.a.y, lineB.b.x, lineB.b.y);

          if (intersect.found === true) {
            lineA.b.x = intersect.x;
            lineA.b.y = intersect.y;
            lineB.a.x = intersect.x;
            lineB.a.y = intersect.y;
          }
        }
      }

      x++;
    }

    x--; //Back

    while (x >= 0) {
      if (x !== 0) {
        transformedPoints = offsetEdge({
          source: points[x],
          target: points[x - 1]
        });
        const p1 = {
          x: transformedPoints.x1,
          y: transformedPoints.y1,
          direction: 'back'
        };
        const p2 = {
          x: transformedPoints.x2,
          y: transformedPoints.y2,
          direction: 'back'
        };
        bothCode.push(p1, p2);

        if (bothCode.length > 3) {
          const l = bothCode.length - 1;
          const lineA = {
            a: bothCode[l - 3],
            b: bothCode[l - 2]
          };
          const lineB = {
            a: bothCode[l - 1],
            b: bothCode[l]
          };
          const intersect = findIntersect(lineA.a.x, lineA.a.y, lineA.b.x, lineA.b.y, lineB.a.x, lineB.a.y, lineB.b.x, lineB.b.y);

          if (intersect.found === true) {
            lineA.b.x = intersect.x;
            lineA.b.y = intersect.y;
            lineB.a.x = intersect.x;
            lineB.a.y = intersect.y;
          }
        }
      }

      x--;
    }

    return bothCode;
  }

  function findIntersect(l1x1, l1y1, l1x2, l1y2, l2x1, l2y1, l2x2, l2y2) {
    let a, b;
    const result = {
      x: null,
      y: null,
      found: false
    };
    const d = (l2y2 - l2y1) * (l1x2 - l1x1) - (l2x2 - l2x1) * (l1y2 - l1y1);

    if (d === 0) {
      return result;
    }

    a = l1y1 - l2y1;
    b = l1x1 - l2x1;
    const n1 = (l2x2 - l2x1) * a - (l2y2 - l2y1) * b;
    const n2 = (l1x2 - l1x1) * a - (l1y2 - l1y1) * b;
    a = n1 / d;
    b = n2 / d;
    result.x = l1x1 + a * (l1x2 - l1x1);
    result.y = l1y1 + a * (l1y2 - l1y1);

    if (a > 0 && a < 1 && b > 0 && b < 1) {
      result.found = true;
    }

    return result;
  }
};

const horizontalDagreLineGenerator = line$1().curve(monotoneX$1).x(d => d.x).y(d => d.y);
const verticalDagreLineGenerator = line$1().curve(monotoneY$1).x(d => d.x).y(d => d.y);

const dagreEdgeGenerator = direction => {
  const dagreLineGenerator = direction === 'LR' || direction === 'RL' ? horizontalDagreLineGenerator : verticalDagreLineGenerator;
  return ({
    d,
    i,
    styleFn,
    renderMode,
    key,
    className,
    baseMarkProps
  }) => {
    if (d.ribbon || d.parallelEdges) {
      const ribbonGenerator = linearRibbon();
      ribbonGenerator.x(p => p.x);
      ribbonGenerator.y(p => p.y);
      ribbonGenerator.r(() => d.weight || 1);

      if (d.parallelEdges) {
        const sortedParallelEdges = d.parallelEdges.sort((a, b) => b.weight - a.weight);
        return React$1.createElement("g", {
          key: `${key}`
        }, ribbonGenerator({
          points: d.points,
          multiple: d.parallelEdges
        }).map((ribbonD, ribbonI) => React$1.createElement(lib_2, _extends({}, baseMarkProps, {
          renderMode: renderMode ? renderMode(d, i) : undefined,
          key: `${key}-${ribbonI}`,
          className: className,
          simpleInterpolate: true,
          markType: "path",
          d: ribbonD,
          style: styleFn(sortedParallelEdges[ribbonI], i),
          "aria-label": `Connection from ${d.source.id} to ${d.target.id}`,
          tabIndex: -1
        }))));
      }

      return React$1.createElement(lib_2, _extends({}, baseMarkProps, {
        renderMode: renderMode ? renderMode(d, i) : undefined,
        key: key,
        className: className,
        simpleInterpolate: true,
        markType: "path",
        d: ribbonGenerator(d.points),
        style: styleFn(d, i),
        "aria-label": `Connection from ${d.source.id} to ${d.target.id}`,
        tabIndex: -1
      }));
    }

    return React$1.createElement(lib_2, _extends({}, baseMarkProps, {
      renderMode: renderMode ? renderMode(d, i) : undefined,
      key: key,
      className: className,
      simpleInterpolate: true,
      markType: "path",
      d: dagreLineGenerator(d.points),
      style: styleFn(d, i),
      "aria-label": `Connection from ${d.source.id} to ${d.target.id}`,
      tabIndex: -1
    }));
  };
};

const hierarchicalRectNodeGenerator = () => ({
  d,
  i,
  styleFn,
  renderMode,
  key,
  className,
  baseMarkProps
}) => {
  //this is repetitious
  return React$1.createElement(lib_2, _extends({}, baseMarkProps, {
    key: key,
    transform: `translate(0,0)`,
    markType: "rect",
    width: d.x1 - d.x0,
    height: d.y1 - d.y0,
    x: d.x0,
    y: d.y0,
    rx: 0,
    ry: 0,
    style: styleFn(d, i),
    renderMode: renderMode ? renderMode(d, i) : undefined,
    className: className,
    "aria-label": `Node ${d.id}`,
    tabIndex: -1
  }));
};

const Dagre = props => {};

Dagre.edgeGenerator = ({
  graph
}) => graph ? dagreEdgeGenerator(graph.graph().rankdir) : null;

Dagre.nodeGenerator = hierarchicalRectNodeGenerator;
Dagre.propTypes = { ...PathDiagram.propTypes
};
Dagre.defaultProps = { ...PathDiagram.defaultProps
};

const ForceLayout = props => {};

ForceLayout.propTypes = { ...NetworkPlot.propTypes,
  zoom: propTypes.bool,
  iterations: propTypes.number,
  edgeStrength: propTypes.number,
  distanceMax: propTypes.number,
  edgeDistance: propTypes.number,
  forceManyBody: propTypes.oneOfType([propTypes.number, propTypes.func])
};
ForceLayout.defaultProps = { ...NetworkPlot.defaultProps,
  zoom: true,
  // Zoom the laid out nodes in or out so that they fit the specified size, can also be "stretch" if you want zoom not to maintain aspect ratio
  iterations: 500,
  // How many times to run forceSimulation
  edgeStrength: 0.1,
  // What modifier to use for the strength of connection between nodes with edges
  forceManyBody: d => -25 * nodeSizeAccessor(d) // Strength of the built in charge

};

const Force = props => {};

Force.propTypes = { ...ForceLayout.propTypes
};
Force.defaultProps = { ...ForceLayout.defaultProps
};

const matrixNodeGenerator = () => (size, nodes) => {
  const gridSize = Math.min(...size);
  const stepSize = gridSize / (nodes.length + 1);
  return ({
    d,
    i,
    styleFn,
    renderMode,
    key,
    className,
    baseMarkProps
  }) => {
    const showText = stepSize > 6;
    const showLine = stepSize > 3;
    const showRect = stepSize > 0.5;
    const textProps = {
      textAnchor: 'end',
      fontSize: `${stepSize / 2}px`
    };
    const style = styleFn(d, i);
    const renderModeValue = renderMode ? renderMode(d, i) : undefined;
    return React$1__default.createElement("g", {
      key: key,
      className: className
    }, showRect && React$1__default.createElement(lib_2, {
      markType: "rect",
      x: stepSize / 2,
      y: d.y - stepSize / 2,
      width: gridSize - stepSize,
      height: stepSize,
      style: { ...style,
        stroke: 'none'
      },
      renderMode: renderModeValue,
      forceUpdate: true,
      baseMarkProps: baseMarkProps
    }), showRect && React$1__default.createElement(lib_2, {
      markType: "rect",
      y: stepSize / 2,
      x: d.y - stepSize / 2,
      height: gridSize - stepSize,
      width: stepSize,
      style: { ...style,
        stroke: 'none'
      },
      renderMode: renderModeValue,
      forceUpdate: true,
      baseMarkProps: baseMarkProps
    }), showLine && React$1__default.createElement(lib_2, {
      markType: "line",
      stroke: "black",
      x1: 0,
      x2: gridSize - stepSize / 2,
      y1: d.y - stepSize / 2,
      y2: d.y - stepSize / 2,
      style: style,
      renderMode: renderModeValue,
      forceUpdate: true,
      baseMarkProps: baseMarkProps
    }), showLine && React$1__default.createElement(lib_2, {
      markType: "line",
      stroke: "black",
      y1: 0,
      y2: gridSize - stepSize / 2,
      x1: d.y - stepSize / 2,
      x2: d.y - stepSize / 2,
      style: style,
      renderMode: renderModeValue,
      forceUpdate: true,
      baseMarkProps: baseMarkProps
    }), showLine && i === nodes.length - 1 && React$1__default.createElement(lib_2, {
      markType: "line",
      stroke: "black",
      x1: 0,
      x2: gridSize - stepSize / 2,
      y1: d.y + stepSize / 2,
      y2: d.y + stepSize / 2,
      style: style,
      renderMode: renderModeValue,
      forceUpdate: true,
      baseMarkProps: baseMarkProps
    }), showLine && i === nodes.length - 1 && React$1__default.createElement(lib_2, {
      markType: "line",
      stroke: "black",
      y1: 0,
      y2: gridSize - stepSize / 2,
      x1: d.y + stepSize / 2,
      x2: d.y + stepSize / 2,
      style: style,
      renderMode: renderModeValue,
      forceUpdate: true,
      baseMarkProps: baseMarkProps
    }), showText && React$1__default.createElement("text", _extends({
      x: 0,
      y: d.y + stepSize / 5
    }, textProps), d.id), showText && React$1__default.createElement("text", _extends({
      transform: `translate(${d.y}) rotate(90) translate(0,${stepSize / 5})`
    }, textProps, {
      y: 0
    }), d.id));
  };
};

const matrixEdgeGenerator = ({
  size,
  nodes
}) => ({
  d,
  i,
  styleFn,
  renderMode,
  key,
  className,
  baseMarkProps
}) => {
  const gridSize = Math.min(...size) / nodes.length;
  return React$1__default.createElement("g", {
    key: key
  }, React$1__default.createElement(lib_2, _extends({}, baseMarkProps, {
    renderMode: renderMode ? renderMode(d, i) : undefined,
    key: key,
    className: className,
    simpleInterpolate: true,
    transform: `translate(${d.source.y},${d.target.y})`,
    markType: "rect",
    x: -gridSize / 2,
    y: -gridSize / 2,
    width: gridSize,
    height: gridSize,
    style: styleFn(d, i),
    "aria-label": `Connection from ${d.source.id} to ${d.target.id}`,
    tabIndex: -1
  })), React$1__default.createElement(lib_2, _extends({}, baseMarkProps, {
    renderMode: renderMode ? renderMode(d, i) : undefined,
    key: `${key}-mirror`,
    className: className,
    simpleInterpolate: true,
    transform: `translate(${d.target.y},${d.source.y})`,
    markType: "rect",
    x: -gridSize / 2,
    y: -gridSize / 2,
    width: gridSize,
    height: gridSize,
    style: styleFn(d, i),
    "aria-label": `Connection from ${d.source.id} to ${d.target.id}`,
    tabIndex: -1
  })));
};

const Matrix$1 = props => {};

Matrix$1.nodeGenerator = matrixNodeGenerator;
Matrix$1.edgeGenerator = matrixEdgeGenerator;
Matrix$1.propTypes = { ...NetworkPlot.propTypes
};
Matrix$1.defaultProps = { ...NetworkPlot.defaultProps
};

const Motifs = props => {};

Motifs.propTypes = { ...ForceLayout.propTypes
};
Motifs.defaultProps = { ...ForceLayout.defaultProps
};

const radialRectNodeGenerator = (size, center, angleRange = [0, 360]) => {
  const radialArc = arc$2();
  const rangePct = angleRange.map(d => d / 360);
  const rangeMod = rangePct[1] - rangePct[0];
  const adjustedPct = rangeMod < 1 ? linear$1().domain([0, 1]).range(rangePct) : d => d;
  return ({
    d,
    i,
    styleFn,
    renderMode,
    key,
    className,
    baseMarkProps
  }) => {
    radialArc.innerRadius(d.y0 / 2).outerRadius(d.y1 / 2);
    return React$1.createElement(lib_2, _extends({}, baseMarkProps, {
      key: key,
      transform: `translate(${center})`,
      markType: "path",
      d: radialArc({
        startAngle: adjustedPct(d.x0 / size[0]) * Math.PI * 2,
        endAngle: adjustedPct(d.x1 / size[0]) * Math.PI * 2
      }),
      customTween: {
        fn: arcTweener,
        props: {
          startAngle: adjustedPct(d.x0 / size[0]) * Math.PI * 2,
          endAngle: adjustedPct(d.x1 / size[0]) * Math.PI * 2,
          innerRadius: d.y0 / 2,
          outerRadius: d.y1 / 2
        }
      },
      style: styleFn(d, i),
      renderMode: renderMode ? renderMode(d, i) : undefined,
      className: className,
      "aria-label": `Node ${d.id}`,
      tabIndex: -1
    }));
  };
};

const Partition = props => {};

Partition.nodeGenerator = ({
  size,
  center,
  projection,
  angleRange
}) => projection === 'radial' ? radialRectNodeGenerator(size, center, angleRange) : hierarchicalRectNodeGenerator;

Partition.propTypes = { ...HierarchicalDiagram.propTypes
};
Partition.defaultProps = { ...HierarchicalDiagram.defaultProps
};

const sankeyNodeGenerator = () => ({
  d,
  i,
  styleFn,
  renderMode,
  key,
  className,
  transform,
  baseMarkProps
}) => {
  const height = d.direction !== 'down' ? d.height : d.width;
  const width = d.direction !== 'down' ? d.width : d.height;
  return React$1.createElement(lib_2, _extends({}, baseMarkProps, {
    renderMode: renderMode ? renderMode(d, i) : undefined,
    key: key,
    className: className,
    transform: transform,
    markType: "rect",
    height: height,
    width: width,
    x: -width / 2,
    y: -height / 2,
    rx: 0,
    ry: 0,
    style: styleFn(d),
    "aria-label": `Node ${d.id}`,
    tabIndex: -1
  }));
};

const Sankey = props => {};

Sankey.nodeGenerator = sankeyNodeGenerator;
Sankey.propTypes = { ...PathDiagram.propTypes
};
Sankey.defaultProps = { ...PathDiagram.defaultProps
};

const Tree$1 = props => {};

Tree$1.propTypes = { ...HierarchicalDiagram.propTypes
};
Tree$1.defaultProps = { ...HierarchicalDiagram.defaultProps
};

const Treemap = props => {};

Treemap.nodeGenerator = ({
  size,
  center,
  projection,
  angleRange
}) => projection === 'radial' ? radialRectNodeGenerator(size, center, angleRange) : hierarchicalRectNodeGenerator;

Treemap.propTypes = { ...HierarchicalDiagram.propTypes
};
Treemap.defaultProps = { ...HierarchicalDiagram.defaultProps
};

const horizontalTornTickGenerator = (width, ticks, y, orient) => {
  const step = width / ticks;
  let currentStep = 0;
  let tickPath = `M0,${y}`;
  const mod = orient === 'right' ? -1 : 1;

  while (currentStep <= width) {
    tickPath += `L${currentStep},${y}`;

    if (currentStep < width) {
      tickPath += `L${currentStep + step / 2},${y + 10 * mod}`;
    }

    currentStep += step;
  }

  return tickPath;
};

const generateTornBaseline = (orient, baselineSettings) => {
  let tornD = '';
  const {
    x1,
    x2,
    y1,
    y2
  } = baselineSettings;

  if (orient === 'left' || orient === 'right') {
    const calcWidth = Math.abs(x2 - x1);
    const ticks = Math.ceil(calcWidth / 40);
    tornD = horizontalTornTickGenerator(calcWidth, ticks, orient === 'right' ? 0 : y1, orient);
  } else {
    const calcHeight = Math.abs(y2 - y1);
    const ticks = Math.ceil(calcHeight / 40);
    tornD = verticalTornTickGenerator(calcHeight, ticks, x1, orient);
  }

  return tornD;
};

const defaultTickLineGenerator = ({
  xy,
  orient,
  i,
  baseMarkProps,
  className = '',
  jaggedBase
}) => {
  const genD = jaggedBase && i === 0 ? generateTornBaseline(orient, xy) : `M${xy.x1},${xy.y1}L${xy.x2},${xy.y2}`;
  return React$1.createElement(lib_2, _extends({
    key: i,
    markType: "path",
    renderMode: xy.renderMode,
    stroke: "black",
    strokeWidth: "1px",
    simpleInterpolate: true,
    d: genD,
    className: `tick-line tick ${orient} ${className}`
  }, baseMarkProps));
};

function generateTickValues(tickValues, ticks, scale) {
  const axisSize = Math.abs(scale.range()[1] - scale.range()[0]);

  if (!tickValues) {
    if (!ticks) {
      ticks = Math.max(1, Math.floor(axisSize / 40));
    }

    tickValues = scale.ticks(ticks);
  }

  return tickValues;
}
function axisPieces({
  renderMode = () => undefined,
  padding = 5,
  scale,
  ticks,
  tickValues = generateTickValues(undefined, ticks, scale),
  orient = 'left',
  size,
  footer = false,
  tickSize = footer ? -10 : ['top', 'bottom'].find(d => d === orient) ? size[1] : size[0]
}) {
  //returns x1 (start of line), x2 (end of line) associated with the value of the tick
  let axisDomain = [],
      position1,
      position2,
      domain1,
      domain2,
      tposition1,
      tposition2,
      textPositionMod = 0,
      textPositionMod2 = 0,
      defaultAnchor = 'middle';

  switch (orient) {
    case 'top':
      position1 = 'x1';
      position2 = 'x2';
      domain1 = 'y1';
      domain2 = 'y2';
      axisDomain = [0, tickSize];
      tposition1 = 'tx';
      tposition2 = 'ty';
      textPositionMod -= 20 - padding;
      break;

    case 'bottom':
      position1 = 'x1';
      position2 = 'x2';
      domain1 = 'y2';
      domain2 = 'y1';
      axisDomain = [size[1], size[1] - tickSize];
      tposition1 = 'tx';
      tposition2 = 'ty';
      textPositionMod += 20 + padding;
      break;

    case 'right':
      position1 = 'y2';
      position2 = 'y1';
      domain1 = 'x2';
      domain2 = 'x1';
      axisDomain = [size[0], size[0] - tickSize];
      tposition1 = 'ty';
      tposition2 = 'tx';
      textPositionMod += 5 + padding;
      textPositionMod2 += 5;
      defaultAnchor = 'start';
      break;
    //left

    default:
      position1 = 'y1';
      position2 = 'y2';
      domain1 = 'x1';
      domain2 = 'x2';
      axisDomain = [0, tickSize];
      tposition1 = 'ty';
      tposition2 = 'tx';
      textPositionMod -= 5 + padding;
      textPositionMod2 += 5;
      defaultAnchor = 'end';
      break;
  }

  const generatedTicks = tickValues instanceof Function ? tickValues({
    orient
  }) : tickValues;
  return generatedTicks.map((tick, i) => {
    const tickPosition = scale(tick);
    return {
      [position1]: tickPosition,
      [position2]: tickPosition,
      [domain1]: axisDomain[0],
      [domain2]: axisDomain[1],
      [tposition1]: tickPosition + textPositionMod2,
      [tposition2]: axisDomain[0] + textPositionMod,
      defaultAnchor,
      renderMode: renderMode(tick, i),
      value: tick
    };
  });
}
const axisLabels = ({
  axisParts,
  tickFormat,
  rotate = 0,
  center = false,
  orient
}) => {
  return axisParts.map((axisPart, i) => {
    let renderedValue = tickFormat(axisPart.value, i);

    if (typeof renderedValue !== 'object' || renderedValue instanceof Date) {
      renderedValue = React$1.createElement("text", {
        textAnchor: axisPart.defaultAnchor,
        className: "axis-label"
      }, renderedValue.toString ? renderedValue.toString() : renderedValue);
    }

    let textX = axisPart.tx;
    let textY = axisPart.ty;

    if (center) {
      switch (orient) {
        case 'right':
          textX -= (axisPart.x2 - axisPart.x1) / 2;
          break;

        case 'left':
          textX += (axisPart.x2 - axisPart.x1) / 2;
          break;

        case 'top':
          textY += (axisPart.y2 - axisPart.y1) / 2;
          break;

        case 'bottom':
          textY -= (axisPart.y2 - axisPart.y1) / 2;
          break;
      }
    }

    return React$1.createElement("g", {
      key: i,
      pointerEvents: "none",
      transform: `translate(${textX},${textY}) rotate(${rotate})`,
      className: "axis-label"
    }, renderedValue);
  });
};
const axisLines = ({
  axisParts,
  orient,
  tickLineGenerator = defaultTickLineGenerator,
  baseMarkProps,
  className,
  jaggedBase
}) => {
  return axisParts.map((axisPart, i) => tickLineGenerator({
    xy: axisPart,
    orient,
    i,
    baseMarkProps,
    className,
    jaggedBase
  }));
};

const contourMap = d => [d.xy.x, d.xy.y];

const contouring = ({
  summaryType,
  data,
  finalXExtent,
  finalYExtent
}) => {
  let projectedSummaries = [];

  if (!summaryType.type) {
    summaryType = {
      type: summaryType
    };
  }

  const {
    resolution = 500,
    thresholds = 10,
    bandwidth = 20,
    neighborhood
  } = summaryType;
  const xScale = linear$1().domain(finalXExtent).rangeRound([0, resolution]).nice();
  const yScale = linear$1().domain(finalYExtent).rangeRound([resolution, 0]).nice();
  data.forEach(contourData => {
    let contourProjectedSummaries = contourDensity().size([resolution, resolution]).x(d => xScale(d[0])).y(d => yScale(d[1])).thresholds(thresholds).bandwidth(bandwidth)(contourData._xyfCoordinates);

    if (neighborhood) {
      contourProjectedSummaries = [contourProjectedSummaries[0]];
    }

    const max = Math.max(...contourProjectedSummaries.map(d => d.value));
    contourProjectedSummaries.forEach(summary => {
      summary.parentSummary = contourData;
      summary.bounds = [];
      summary.percent = summary.value / max;
      summary.coordinates.forEach(poly => {
        poly.forEach((subpoly, i) => {
          poly[i] = subpoly.map(coordpair => {
            coordpair = [xScale.invert(coordpair[0]), yScale.invert(coordpair[1])];
            return coordpair;
          }); //Only push bounds for the main poly, not its interior rings, otherwise you end up labeling interior cutouts

          if (i === 0) {
            summary.bounds.push(shapeBounds$1(poly[i]));
          }
        });
      });
    });
    projectedSummaries = [...projectedSummaries, ...contourProjectedSummaries];
  });
  return projectedSummaries;
};

const contourRenderFn = ({
  data,
  type,
  renderMode,
  eventListenersGenerator,
  styleFn,
  classFn,
  adjustedSize,
  baseMarkProps
}) => {
  const keys = Object.keys(data);
  const renderedSummaryMarks = [];
  const summaryXYCoords = [];
  keys.forEach((key, ordsetI) => {
    const ordset = data[key];
    const renderValue = renderMode && renderMode(ordset, ordsetI);
    type.thresholds = type.thresholds || 8;
    type.bandwidth = type.bandwidth || 12;
    type.resolution = type.resolution || 1000;
    const projectedOrd = [{
      id: ordset,
      _xyfCoordinates: ordset.xyData.map(contourMap)
    }];
    const oContours = contouring({
      summaryType: type,
      data: projectedOrd,
      finalXExtent: [0, adjustedSize[0]],
      finalYExtent: [0, adjustedSize[1]]
    });
    const contourMarks = [];
    oContours.forEach((d, i) => {
      d.coordinates.forEach((coords, ii) => {
        const eventListeners = eventListenersGenerator(d, i);
        contourMarks.push(React$1__default.createElement(lib_2, _extends({}, baseMarkProps, eventListeners, {
          renderMode: renderValue,
          simpleInterpolate: true,
          key: `${i}-${ii}`,
          style: styleFn(ordset.pieceData[0].data, ordsetI),
          className: classFn(ordset.pieceData[0].data, ordsetI),
          markType: 'path',
          d: `M${d.coordinates[0].map(p => p.join(',')).join('L')}Z`
        })));
      });
    });
    renderedSummaryMarks.push(React$1__default.createElement("g", {
      key: `contour-container-${ordsetI}`,
      role: "img",
      tabIndex: -1,
      "data-o": key,
      "aria-label": `${key} Contour plot`
    }, contourMarks));
  });
  return {
    marks: renderedSummaryMarks,
    xyPoints: summaryXYCoords
  };
};

const emptyObjectReturnFn = () => ({});

const boxplotRenderFn = ({
  data,
  type,
  renderMode,
  eventListenersGenerator,
  styleFn,
  classFn,
  positionFn = position => position,
  projection,
  adjustedSize,
  baseMarkProps
}) => {
  const summaryElementStylingFn = type.elementStyleFn || emptyObjectReturnFn;
  const keys = Object.keys(data);
  const renderedSummaryMarks = [];
  const summaryXYCoords = [];
  keys.forEach((key, summaryI) => {
    const summary = data[key];
    const eventListeners = eventListenersGenerator(summary, summaryI);
    const columnWidth = summary.width;
    const thisSummaryData = summary.pieceData;
    const calculatedSummaryStyle = styleFn(thisSummaryData[0].data, summaryI);
    const calculatedSummaryClass = classFn(thisSummaryData[0].data, summaryI);
    let summaryPositionNest, summaryValueNest, translate, extentlineX1, extentlineX2, extentlineY1, extentlineY2, topLineX1, topLineX2, midLineX1, midLineX2, bottomLineX1, bottomLineX2, rectTopWidth, rectTopHeight, rectTopY, rectTopX, rectBottomWidth, rectBottomHeight, rectBottomY, rectBottomX, rectWholeWidth, rectWholeHeight, rectWholeY, rectWholeX, topLineY1, topLineY2, bottomLineY1, bottomLineY2, midLineY1, midLineY2;
    const renderValue = renderMode ? renderMode(summary, summaryI) : undefined;
    summaryValueNest = thisSummaryData.map(p => p.value).sort((a, b) => a - b);
    summaryValueNest = [quantile(summaryValueNest, 0.0), quantile(summaryValueNest, 0.25), quantile(summaryValueNest, 0.5), quantile(summaryValueNest, 0.75), quantile(summaryValueNest, 1.0)];

    if (projection === 'vertical') {
      summaryPositionNest = thisSummaryData.map(p => p.scaledVerticalValue).sort((a, b) => b - a);
      summaryPositionNest = [quantile(summaryPositionNest, 0.0), quantile(summaryPositionNest, 0.25), quantile(summaryPositionNest, 0.5), quantile(summaryPositionNest, 0.75), quantile(summaryPositionNest, 1.0)];
      const xPosition = positionFn(summary.middle, key, summaryI);
      translate = `translate(${xPosition},0)`;
      extentlineX1 = 0;
      extentlineX2 = 0;
      extentlineY1 = summaryPositionNest[0];
      extentlineY2 = summaryPositionNest[4];
      topLineX1 = -columnWidth / 2;
      topLineX2 = columnWidth / 2;
      midLineX1 = -columnWidth / 2;
      midLineX2 = columnWidth / 2;
      bottomLineX1 = -columnWidth / 2;
      bottomLineX2 = columnWidth / 2;
      rectBottomWidth = columnWidth;
      rectBottomHeight = summaryPositionNest[1] - summaryPositionNest[2];
      rectBottomY = summaryPositionNest[2];
      rectBottomX = -columnWidth / 2;
      rectTopWidth = columnWidth;
      rectTopHeight = summaryPositionNest[2] - summaryPositionNest[3];
      rectWholeWidth = columnWidth;
      rectWholeHeight = summaryPositionNest[1] - summaryPositionNest[3];
      rectWholeY = summaryPositionNest[3];
      rectWholeX = -columnWidth / 2;
      rectTopY = summaryPositionNest[3];
      rectTopX = -columnWidth / 2;
      topLineY1 = summaryPositionNest[0];
      topLineY2 = summaryPositionNest[0];
      bottomLineY1 = summaryPositionNest[4];
      bottomLineY2 = summaryPositionNest[4];
      midLineY1 = summaryPositionNest[2];
      midLineY2 = summaryPositionNest[2];
      summaryXYCoords.push({
        label: 'Maximum',
        key,
        summaryPieceName: 'max',
        x: xPosition,
        y: summaryPositionNest[4],
        value: summaryValueNest[4]
      }, {
        label: '3rd Quartile',
        key,
        summaryPieceName: 'q3area',
        x: xPosition,
        y: summaryPositionNest[3],
        value: summaryValueNest[3]
      }, {
        label: 'Median',
        key,
        summaryPieceName: 'median',
        x: xPosition,
        y: summaryPositionNest[2],
        value: summaryValueNest[2]
      }, {
        label: '1st Quartile',
        key,
        summaryPieceName: 'q1area',
        x: xPosition,
        y: summaryPositionNest[1],
        value: summaryValueNest[1]
      }, {
        label: 'Minimum',
        key,
        summaryPieceName: 'min',
        x: xPosition,
        y: summaryPositionNest[0],
        value: summaryValueNest[0]
      });
    } else if (projection === 'horizontal') {
      summaryPositionNest = thisSummaryData.map(p => p.scaledValue).sort((a, b) => a - b);
      summaryPositionNest = [quantile(summaryPositionNest, 0.0), quantile(summaryPositionNest, 0.25), quantile(summaryPositionNest, 0.5), quantile(summaryPositionNest, 0.75), quantile(summaryPositionNest, 1.0)];
      const yPosition = positionFn(summary.middle, key, summaryI);
      translate = `translate(0,${yPosition})`;
      extentlineY1 = 0;
      extentlineY2 = 0;
      extentlineX1 = summaryPositionNest[0];
      extentlineX2 = summaryPositionNest[4];
      topLineY1 = -columnWidth / 2;
      topLineY2 = columnWidth / 2;
      midLineY1 = -columnWidth / 2;
      midLineY2 = columnWidth / 2;
      bottomLineY1 = -columnWidth / 2;
      bottomLineY2 = columnWidth / 2;
      rectTopHeight = columnWidth;
      rectTopWidth = summaryPositionNest[3] - summaryPositionNest[2];
      rectTopX = summaryPositionNest[2];
      rectTopY = -columnWidth / 2;
      rectBottomHeight = columnWidth;
      rectBottomWidth = summaryPositionNest[2] - summaryPositionNest[1];
      rectBottomX = summaryPositionNest[1];
      rectBottomY = -columnWidth / 2;
      rectWholeHeight = columnWidth;
      rectWholeWidth = summaryPositionNest[3] - summaryPositionNest[1];
      rectWholeX = summaryPositionNest[1];
      rectWholeY = -columnWidth / 2;
      topLineX1 = summaryPositionNest[0];
      topLineX2 = summaryPositionNest[0];
      bottomLineX1 = summaryPositionNest[4];
      bottomLineX2 = summaryPositionNest[4];
      midLineX1 = summaryPositionNest[2];
      midLineX2 = summaryPositionNest[2];
      summaryXYCoords.push({
        label: 'Maximum',
        key,
        summaryPieceName: 'max',
        x: summaryPositionNest[4],
        y: yPosition,
        value: summaryValueNest[4]
      }, {
        label: '3rd Quartile',
        key,
        summaryPieceName: 'q3area',
        x: summaryPositionNest[3],
        y: yPosition,
        value: summaryValueNest[3]
      }, {
        label: 'Median',
        key,
        summaryPieceName: 'median',
        x: summaryPositionNest[2],
        y: yPosition,
        value: summaryValueNest[2]
      }, {
        label: '1st Quartile',
        key,
        summaryPieceName: 'q1area',
        x: summaryPositionNest[1],
        y: yPosition,
        value: summaryValueNest[1]
      }, {
        label: 'Minimum',
        key,
        summaryPieceName: 'min',
        x: summaryPositionNest[0],
        y: yPosition,
        value: summaryValueNest[0]
      });
    }

    if (projection === 'radial') {
      summaryPositionNest = thisSummaryData.map(p => p.scaledValue).sort((a, b) => a - b);
      summaryPositionNest = [quantile(summaryPositionNest, 0.0), quantile(summaryPositionNest, 0.25), quantile(summaryPositionNest, 0.5), quantile(summaryPositionNest, 0.75), quantile(summaryPositionNest, 1.0)];
      extentlineX1 = 0;
      extentlineX2 = 0;
      extentlineY1 = summaryPositionNest[0];
      extentlineY2 = summaryPositionNest[4];
      topLineX1 = -columnWidth / 2;
      topLineX2 = columnWidth / 2;
      midLineX1 = -columnWidth / 2;
      midLineX2 = columnWidth / 2;
      bottomLineX1 = -columnWidth / 2;
      bottomLineX2 = columnWidth / 2;
      rectTopWidth = columnWidth;
      rectTopHeight = summaryPositionNest[1] - summaryPositionNest[3];
      rectTopY = summaryPositionNest[3];
      rectTopX = -columnWidth / 2;
      rectBottomWidth = columnWidth;
      rectBottomHeight = summaryPositionNest[1] - summaryPositionNest[3];
      rectBottomY = summaryPositionNest[3];
      rectBottomX = -columnWidth / 2;
      topLineY1 = summaryPositionNest[0];
      topLineY2 = summaryPositionNest[0];
      bottomLineY1 = summaryPositionNest[4];
      bottomLineY2 = summaryPositionNest[4];
      midLineY1 = summaryPositionNest[2];
      midLineY2 = summaryPositionNest[2];
      const twoPI = Math.PI * 2;
      const bottomLineArcGenerator = arc().innerRadius(bottomLineY1 / 2).outerRadius(bottomLineY1 / 2); //        .padAngle(summary.pct_padding * twoPI);

      const topLineArcGenerator = arc().innerRadius(topLineY1 / 2).outerRadius(topLineY1 / 2); //        .padAngle(summary.pct_padding * twoPI);

      const midLineArcGenerator = arc().innerRadius(midLineY1 / 2).outerRadius(midLineY1 / 2); //        .padAngle(summary.pct_padding * twoPI);

      const bodyArcTopGenerator = arc().innerRadius(summaryPositionNest[1] / 2).outerRadius(midLineY1 / 2); //        .padAngle(summary.pct_padding * twoPI);

      const bodyArcBottomGenerator = arc().innerRadius(midLineY1 / 2).outerRadius(summaryPositionNest[3] / 2); //        .padAngle(summary.pct_padding * twoPI);

      const bodyArcWholeGenerator = arc().innerRadius(summaryPositionNest[1] / 2).outerRadius(summaryPositionNest[3] / 2); //        .padAngle(summary.pct_padding * twoPI);

      let startAngle = summary.pct_start + summary.pct_padding / 2;
      let endAngle = summary.pct + summary.pct_start - summary.pct_padding / 2;
      const midAngle = summary.pct / 2 + summary.pct_start;
      startAngle *= twoPI;
      endAngle *= twoPI;
      const radialAdjustX = adjustedSize[0] / 2;
      const radialAdjustY = adjustedSize[1] / 2; //        const bottomPoint = bottomLineArcGenerator.centroid({ startAngle, endAngle })
      //        const topPoint = topLineArcGenerator.centroid({ startAngle, endAngle })

      const bottomPoint = pointOnArcAtAngle([0, 0], midAngle, summaryPositionNest[4] / 2);
      const topPoint = pointOnArcAtAngle([0, 0], midAngle, summaryPositionNest[0] / 2);
      const thirdPoint = pointOnArcAtAngle([0, 0], midAngle, summaryPositionNest[3] / 2);
      const midPoint = pointOnArcAtAngle([0, 0], midAngle, summaryPositionNest[2] / 2);
      const firstPoint = pointOnArcAtAngle([0, 0], midAngle, summaryPositionNest[1] / 2);
      summaryXYCoords.push({
        label: 'Minimum',
        key,
        summaryPieceName: 'min',
        x: topPoint[0] + radialAdjustX,
        y: topPoint[1] + radialAdjustY,
        value: summaryValueNest[0]
      }, {
        label: '1st Quartile',
        key,
        summaryPieceName: 'q3area',
        x: firstPoint[0] + radialAdjustX,
        y: firstPoint[1] + radialAdjustY,
        value: summaryValueNest[1]
      }, {
        label: 'Median',
        key,
        summaryPieceName: 'median',
        x: midPoint[0] + radialAdjustX,
        y: midPoint[1] + radialAdjustY,
        value: summaryValueNest[2]
      }, {
        label: '3rd Quartile',
        key,
        summaryPieceName: 'q1area',
        x: thirdPoint[0] + radialAdjustX,
        y: thirdPoint[1] + radialAdjustY,
        value: summaryValueNest[3]
      }, {
        label: 'Maximum',
        key,
        summaryPieceName: 'max',
        x: bottomPoint[0] + radialAdjustX,
        y: bottomPoint[1] + radialAdjustY,
        value: summaryValueNest[4]
      });
      translate = `translate(${radialAdjustX},${radialAdjustY})`;
      renderedSummaryMarks.push(React$1__default.createElement("g", _extends({}, eventListeners, {
        className: calculatedSummaryClass,
        transform: translate,
        key: `summaryPiece-${summaryI}`,
        role: "img",
        tabIndex: -1,
        "data-o": key,
        "aria-label": `${key} boxplot showing ${summaryXYCoords.filter(d => d.key === key).map(d => `${d.label} ${d.value}`)}`
      }), React$1__default.createElement(lib_2, _extends({}, baseMarkProps, {
        renderMode: renderValue,
        markType: "line",
        x1: bottomPoint[0],
        x2: topPoint[0],
        y1: bottomPoint[1],
        y2: topPoint[1],
        style: Object.assign({
          strokeWidth: 2
        }, calculatedSummaryStyle, summaryElementStylingFn('whisker'))
      })), React$1__default.createElement(lib_2, _extends({}, baseMarkProps, {
        renderMode: renderValue,
        markType: "path",
        d: topLineArcGenerator({
          startAngle,
          endAngle
        }),
        style: Object.assign({
          strokeWidth: 4
        }, calculatedSummaryStyle, {
          fill: 'none'
        }, summaryElementStylingFn('max'))
      })), React$1__default.createElement(lib_2, _extends({}, baseMarkProps, {
        renderMode: renderValue,
        markType: "path",
        d: midLineArcGenerator({
          startAngle,
          endAngle
        }),
        style: Object.assign({
          strokeWidth: 4
        }, calculatedSummaryStyle, {
          fill: 'none'
        }, summaryElementStylingFn('median'))
      })), React$1__default.createElement(lib_2, _extends({}, baseMarkProps, {
        renderMode: renderValue,
        markType: "path",
        d: bottomLineArcGenerator({
          startAngle,
          endAngle
        }),
        style: Object.assign({
          strokeWidth: 4
        }, calculatedSummaryStyle, {
          fill: 'none'
        }, summaryElementStylingFn('min'))
      })), React$1__default.createElement(lib_2, _extends({}, baseMarkProps, {
        renderMode: renderValue,
        markType: "path",
        d: bodyArcWholeGenerator({
          startAngle,
          endAngle
        }),
        style: Object.assign({
          strokeWidth: 4
        }, calculatedSummaryStyle, summaryElementStylingFn('iqrarea'))
      })), React$1__default.createElement(lib_2, _extends({}, baseMarkProps, {
        renderMode: renderValue,
        markType: "path",
        d: bodyArcTopGenerator({
          startAngle,
          endAngle
        }),
        style: Object.assign({}, calculatedSummaryStyle, {
          fill: 'none',
          stroke: 'none'
        }, summaryElementStylingFn('q3area'))
      })), React$1__default.createElement(lib_2, _extends({}, baseMarkProps, {
        renderMode: renderValue,
        markType: "path",
        d: bodyArcBottomGenerator({
          startAngle,
          endAngle
        }),
        style: Object.assign({}, calculatedSummaryStyle, {
          fill: 'none',
          stroke: 'none'
        }, summaryElementStylingFn('q1area'))
      }))));
    } else {
      renderedSummaryMarks.push(React$1__default.createElement("g", _extends({}, eventListeners, {
        className: calculatedSummaryClass,
        transform: translate,
        key: `summaryPiece-${summaryI}`,
        role: "img",
        tabIndex: -1,
        "data-o": key,
        "aria-label": `${key} boxplot showing ${summaryXYCoords.filter(d => d.key === key).map(d => `${d.label} ${d.value}`).join(', ')}`
      }), React$1__default.createElement(lib_2, _extends({}, baseMarkProps, {
        renderMode: renderValue,
        markType: "line",
        x1: extentlineX1,
        x2: extentlineX2,
        y1: extentlineY1,
        y2: extentlineY2,
        style: Object.assign({
          strokeWidth: '2px'
        }, calculatedSummaryStyle, summaryElementStylingFn('whisker'))
      })), React$1__default.createElement(lib_2, _extends({}, baseMarkProps, {
        renderMode: renderValue,
        markType: "line",
        x1: topLineX1,
        x2: topLineX2,
        y1: topLineY1,
        y2: topLineY2,
        style: Object.assign({
          strokeWidth: '2px'
        }, calculatedSummaryStyle, summaryElementStylingFn('min'))
      })), React$1__default.createElement(lib_2, _extends({}, baseMarkProps, {
        renderMode: renderValue,
        markType: "line",
        x1: bottomLineX1,
        x2: bottomLineX2,
        y1: bottomLineY1,
        y2: bottomLineY2,
        style: Object.assign({
          strokeWidth: '2px'
        }, calculatedSummaryStyle, summaryElementStylingFn('max'))
      })), React$1__default.createElement(lib_2, _extends({}, baseMarkProps, {
        renderMode: renderValue,
        markType: "rect",
        x: rectWholeX,
        width: rectWholeWidth,
        y: rectWholeY,
        height: rectWholeHeight,
        style: Object.assign({
          strokeWidth: '1px'
        }, calculatedSummaryStyle, summaryElementStylingFn('iqrarea'))
      })), React$1__default.createElement(lib_2, _extends({}, baseMarkProps, {
        renderMode: renderValue,
        markType: "rect",
        x: rectTopX,
        width: rectTopWidth,
        y: rectTopY,
        height: rectTopHeight,
        style: Object.assign({}, calculatedSummaryStyle, {
          fill: 'none',
          stroke: 'none'
        }, summaryElementStylingFn('q3area'))
      })), React$1__default.createElement(lib_2, _extends({}, baseMarkProps, {
        renderMode: renderValue,
        markType: "rect",
        x: rectBottomX,
        width: rectBottomWidth,
        y: rectBottomY,
        height: rectBottomHeight,
        style: Object.assign({}, calculatedSummaryStyle, {
          fill: 'none',
          stroke: 'none'
        }, summaryElementStylingFn('q1area'))
      })), React$1__default.createElement(lib_2, _extends({}, baseMarkProps, {
        renderMode: renderValue,
        markType: "line",
        x1: midLineX1,
        x2: midLineX2,
        y1: midLineY1,
        y2: midLineY2,
        style: Object.assign({
          strokeWidth: '2px'
        }, calculatedSummaryStyle, summaryElementStylingFn('median'))
      }))));
    }
  });
  return {
    marks: renderedSummaryMarks,
    xyPoints: summaryXYCoords
  };
};

const createSummaryAxis = ({
  summary,
  summaryI,
  axisSettings,
  axisCreator,
  projection,
  actualMax,
  adjustedSize,
  columnWidth
}) => {
  let axisTranslate = `translate(${summary.x},0)`;
  let axisDomain = [0, actualMax];

  if (projection === 'horizontal') {
    axisTranslate = `translate(${0},${summary.x})`;
    axisDomain = [actualMax, 0];
  } else if (projection === 'radial') {
    axisTranslate = 'translate(0, 0)';
  }

  const axisWidth = projection === 'horizontal' ? adjustedSize[0] : columnWidth;
  const axisHeight = projection === 'vertical' ? adjustedSize[1] : columnWidth;
  axisSettings.size = [axisWidth, axisHeight];
  const axisScale = linear$1().domain(axisDomain).range([0, columnWidth]);
  const renderedSummaryAxis = axisCreator(axisSettings, summaryI, axisScale);
  return React$1__default.createElement("g", {
    className: "summary-axis",
    key: `summaryPiece-axis-${summaryI}`,
    transform: axisTranslate
  }, renderedSummaryAxis);
};

const emptyObjectReturnFn$1 = () => ({});

const verticalXYSorting = (a, b) => a.xy.y - b.xy.y;

const horizontalXYSorting = (a, b) => b.xy.x - a.xy.x;

const groupBarMark = ({
  bins,
  binMax,
  relativeBuckets,
  columnWidth,
  projection,
  adjustedSize,
  summaryI,
  summary,
  renderValue,
  summaryStyle,
  type,
  baseMarkProps
}) => {
  const mappedBins = [];
  const mappedPoints = [];
  const actualMax = relativeBuckets && relativeBuckets[summary.name] || binMax;
  const summaryElementStylingFn = type.elementStyleFn || emptyObjectReturnFn$1;
  const barPadding = type.padding || 0;
  bins.forEach((d, i) => {
    const opacity = d.value / actualMax;
    const additionalStyle = summaryElementStylingFn(d.value, opacity, d.pieces);
    const finalStyle = type.type === 'heatmap' ? {
      opacity: opacity,
      fill: summaryStyle.fill,
      ...additionalStyle
    } : { ...summaryStyle,
      ...additionalStyle
    };
    const thickness = Math.max(1, d.y1 - barPadding * 2);
    const finalColumnWidth = type.type === 'heatmap' ? columnWidth : columnWidth * opacity;
    let yProp = d.y + barPadding;
    let xProp = type.type === 'heatmap' || type.flip ? -columnWidth / 2 : columnWidth / 2 - finalColumnWidth;
    let height = thickness;
    let width = finalColumnWidth;
    let xOffset = type.type === 'heatmap' ? finalColumnWidth / 2 : finalColumnWidth;
    let yOffset = d.y1 / 2;

    if (projection === 'horizontal') {
      yProp = type.type === 'heatmap' ? -columnWidth / 2 : type.flip ? -columnWidth / 2 : columnWidth / 2 - finalColumnWidth;
      xProp = d.y - d.y1 + barPadding;
      height = finalColumnWidth;
      width = thickness;
      yOffset = type.type === 'heatmap' ? finalColumnWidth / 2 : finalColumnWidth;
      xOffset = d.y1 / 2;
    } else if (projection === 'radial') {
      const arcGenerator = arc$2().innerRadius(d.y / 2).outerRadius((d.y + d.y1) / 2);
      const angle = summary.pct - summary.pct_padding;
      let startAngle = summary.pct_middle - summary.pct_padding;
      let endAngle = type.type === 'heatmap' ? startAngle + angle : startAngle + angle * opacity;
      startAngle *= twoPI;
      endAngle *= twoPI;
      const arcAdjustX = adjustedSize[0] / 2;
      const arcAdjustY = adjustedSize[1] / 2;
      const arcTranslate = `translate(${arcAdjustX},${arcAdjustY})`;
      const arcCenter = arcGenerator.centroid({
        startAngle,
        endAngle
      });
      mappedPoints.push({
        key: summary.name,
        value: d.value,
        pieces: d.pieces.map(p => p.piece),
        label: 'Heatmap',
        x: arcCenter[0] + arcAdjustX,
        y: arcCenter[1] + arcAdjustY
      });
      mappedBins.push(React$1__default.createElement(lib_2, _extends({}, baseMarkProps, {
        markType: "path",
        transform: arcTranslate,
        renderMode: renderValue,
        key: `groupIcon-${summaryI}-${i}`,
        d: arcGenerator({
          startAngle,
          endAngle
        }),
        style: finalStyle
      })));
    }

    if (projection !== 'radial') {
      mappedPoints.push({
        key: summary.name,
        value: d.value,
        pieces: d.pieces.map(p => p.piece),
        label: 'Heatmap',
        x: xProp + xOffset,
        y: yProp + yOffset
      });
      mappedBins.push(React$1__default.createElement(lib_2, _extends({}, baseMarkProps, {
        markType: "rect",
        renderMode: renderValue,
        key: `groupIcon-${summaryI}-${i}`,
        x: xProp,
        y: yProp,
        height: height,
        width: width,
        style: finalStyle
      })));
    }
  });
  return {
    marks: mappedBins,
    points: mappedPoints
  };
};

const bucketizedRenderingFn = ({
  data,
  type,
  renderMode,
  eventListenersGenerator,
  styleFn,
  classFn,
  projection,
  adjustedSize,
  chartSize,
  baseMarkProps
}) => {
  const renderedSummaryMarks = [];
  const summaryXYCoords = [];
  const buckets = type.bins || 25;
  const relativeBuckets = type.relative ? {} : false;

  const summaryValueAccessor = type.binValue || (d => d.length);

  let axisCreator;

  if (type.axis) {
    type.axis.orient = projection === 'horizontal' && ['left', 'right'].indexOf(type.axis.orient) === -1 ? 'left' : type.axis.orient;
    type.axis.orient = projection === 'vertical' && ['bottom', 'top'].indexOf(type.axis.orient) === -1 ? 'bottom' : type.axis.orient;
    axisCreator = axisGenerator;

    if (projection === 'radial') {
      console.error('Summary axes cannot be drawn for radial histograms');

      axisCreator = () => null;
    }
  }

  let bucketSize = chartSize / buckets;
  const keys = Object.keys(data);
  let binMax = 0;
  const calculatedBins = keys.map((key, summaryI) => {
    const summary = data[key];
    const thisSummaryData = summary.xyData;
    const xySorting = projection === 'vertical' ? verticalXYSorting : horizontalXYSorting;
    const summaryPositionNest = thisSummaryData.sort(xySorting);
    const violinHist = histogram();
    const binDomain = projection === 'vertical' ? [0, chartSize] : [0, chartSize];
    const binOffset = 0;
    const binBuckets = [];

    for (let x = 0; x < buckets; x++) {
      binBuckets.push(binDomain[0] + x / buckets * (chartSize - binOffset));
    } //    binBuckets.push(binDomain[1]);


    const xyValue = projection === 'vertical' ? p => p.piece.scaledVerticalValue : p => p.piece.scaledValue;
    let keyBins;

    if (type.useBins === false) {
      const calculatedValues = summaryPositionNest.map(value => xyValue(value));
      keyBins = summaryPositionNest.map((value, i) => {
        const bucketArray = [];
        bucketArray.x0 = calculatedValues[i] - 1;
        bucketArray.x1 = calculatedValues[i] + 1;
        bucketArray.push(value);
        return bucketArray;
      }).sort((a, b) => a.x0 - b.x0);
      bucketSize = chartSize / keyBins.length;
    } else {
      keyBins = violinHist.domain(binDomain).thresholds(binBuckets).value(xyValue)(summaryPositionNest);
    }

    keyBins = keyBins.map(d => ({
      y: d.x0,
      y1: d.x1 - d.x0,
      pieces: d,
      value: summaryValueAccessor(d.map(p => p.piece.data))
    }));

    if (type.type === 'histogram' || type.type === 'heatmap') {
      keyBins = keyBins.filter(d => d.value !== 0);
    }

    const relativeMax = keyBins.length === 0 ? 0 : max(keyBins.map(d => d.value));

    if (relativeBuckets) {
      relativeBuckets[key] = relativeMax;
    }

    binMax = Math.max(binMax, relativeMax);
    return {
      bins: keyBins,
      summary,
      summaryI,
      thisSummaryData
    };
  });
  calculatedBins.forEach(({
    bins,
    summary,
    summaryI,
    thisSummaryData
  }) => {
    const eventListeners = eventListenersGenerator(summary, summaryI);
    const columnWidth = summary.width;
    const renderValue = renderMode && renderMode(summary, summaryI);
    let calculatedSummaryStyle = thisSummaryData[0] ? styleFn(thisSummaryData[0].piece.data, summaryI) : {};
    let calculatedSummaryClass = thisSummaryData[0] ? classFn(thisSummaryData[0].piece.data, summaryI) : '';
    let translate = [summary.middle, 0];

    if (projection === 'horizontal') {
      translate = [bucketSize, summary.middle];
    } else if (projection === 'radial') {
      translate = [adjustedSize[0] / 2, adjustedSize[1] / 2];
    }

    const actualMax = relativeBuckets && relativeBuckets[summary.name] || binMax;

    if (type.type === 'heatmap' || type.type === 'histogram') {
      const mappedBars = groupBarMark({
        bins,
        binMax,
        relativeBuckets,
        columnWidth,
        projection,
        adjustedSize,
        summaryI,
        summary,
        renderValue,
        summaryStyle: calculatedSummaryStyle,
        type,
        baseMarkProps
      });
      const tiles = mappedBars.marks;

      if (projection === 'radial') {
        translate = [0, 0];
      }

      if (type.axis && type.type === 'histogram') {
        renderedSummaryMarks.push(createSummaryAxis({
          summary,
          summaryI,
          axisSettings: type.axis,
          axisCreator,
          projection,
          actualMax,
          adjustedSize,
          columnWidth
        }));
      }

      mappedBars.points.forEach(d => {
        d.x += translate[0];
        d.y += translate[1];
      });
      summaryXYCoords.push(...mappedBars.points);
      renderedSummaryMarks.push(React$1__default.createElement("g", _extends({}, eventListeners, {
        transform: `translate(${translate})`,
        key: `summaryPiece-${summaryI}`,
        role: "img",
        tabIndex: -1,
        "data-o": summary.name,
        "aria-label": `${summary.name} ${type.type}`
      }), tiles));
    } else if (type.type === 'violin') {
      const subsets = type.subsets || [false];
      bins[0].y = bins[0].y - bucketSize / 2;
      bins[bins.length - 1].y = bins[bins.length - 1].y + bucketSize / 2;
      subsets.forEach((subsettingFn, subsettingIndex) => {
        let actualBins = bins;

        if (subsettingFn) {
          calculatedSummaryStyle = thisSummaryData[0] ? styleFn(thisSummaryData[0].piece.data, summaryI, subsettingIndex) : {};
          calculatedSummaryClass = thisSummaryData[0] ? classFn(thisSummaryData[0].piece.data, summaryI, subsettingIndex) : '';
          actualBins = bins.map(d => {
            const actualPieces = d.pieces.filter((p, pi) => subsettingFn(p.piece, pi)).map(d => d);
            const actualValue = summaryValueAccessor(actualPieces);
            return { ...d,
              pieces: actualPieces,
              value: actualValue
            };
          });
        }

        let violinArea = area$1().curve(type.curve || curveCatmullRom);
        let violinPoints = [];

        if (projection === 'horizontal') {
          actualBins.forEach(summaryPoint => {
            const xValue = summaryPoint.y - bucketSize / 2;
            const yValue = summaryPoint.value / actualMax * columnWidth / 2;
            violinPoints.push({
              x: xValue,
              y0: -yValue,
              y1: yValue
            });
            summaryXYCoords.push({
              key: summary.name,
              x: xValue + translate[0],
              y: yValue + translate[1],
              pieces: summaryPoint.pieces.map(d => d.piece),
              value: summaryPoint.value
            });
          });
          violinArea.x(d => d.x).y0(d => d.y0).y1(d => d.y1).defined((d, i) => d.y0 !== 0 || violinPoints[i - 1] && violinPoints[i - 1].y0 !== 0 || violinPoints[i + 1] && violinPoints[i + 1].y0 !== 0);
        } else if (projection === 'vertical') {
          actualBins.forEach(summaryPoint => {
            const yValue = summaryPoint.y + bucketSize / 2;
            const xValue = summaryPoint.value / actualMax * columnWidth / 2;
            violinPoints.push({
              y: yValue,
              x0: -xValue,
              x1: xValue
            });
            summaryXYCoords.push({
              key: summary.name,
              x: xValue + translate[0],
              y: yValue + translate[1],
              pieces: summaryPoint.pieces.map(d => d.piece),
              value: summaryPoint.value
            });
          });
          violinArea.y(d => d.y).x0(d => d.x0).x1(d => d.x1).defined((d, i) => d.x0 !== 0 || violinPoints[i - 1] && violinPoints[i - 1].x0 !== 0 || violinPoints[i + 1] && violinPoints[i + 1].x0 !== 0);
        } else if (projection === 'radial') {
          const angle = summary.pct - summary.pct_padding / 2;
          const midAngle = summary.pct_middle;
          violinPoints = actualBins;

          violinArea = inbins => {
            const forward = [];
            const backward = [];
            inbins.forEach(bin => {
              const outsidePoint = pointOnArcAtAngle([0, 0], midAngle + angle * bin.value / actualMax / 2, (bin.y + bin.y1 - bucketSize / 2) / 2);
              const insidePoint = pointOnArcAtAngle([0, 0], midAngle - angle * bin.value / actualMax / 2, (bin.y + bin.y1 - bucketSize / 2) / 2); //Ugh a terrible side effect has appeared

              summaryXYCoords.push({
                key: summary.name,
                x: insidePoint[0] + translate[0],
                y: insidePoint[1] + translate[1],
                pieces: bin.pieces.map(d => d.piece),
                value: bin.value
              });
              summaryXYCoords.push({
                key: summary.name,
                x: outsidePoint[0] + translate[0],
                y: outsidePoint[1] + translate[1],
                pieces: bin.pieces.map(d => d.piece),
                value: bin.value
              });
              forward.push(outsidePoint);
              backward.push(insidePoint);
            });
            return `M${forward.map(d => d.join(',')).join('L')}L${backward.reverse().map(d => d.join(',')).join('L')}Z`;
          };
        }

        renderedSummaryMarks.push(React$1__default.createElement(lib_2, _extends({}, baseMarkProps, {
          transform: `translate(${translate})`,
          key: `summaryPiece-${summaryI}-${subsettingIndex}`
        }, eventListeners, {
          renderMode: renderValue,
          markType: "path",
          className: calculatedSummaryClass,
          style: calculatedSummaryStyle,
          d: violinArea(violinPoints),
          role: "img",
          tabIndex: -1,
          "data-o": summary.name,
          "aria-label": `${summary.name} distribution`
        })));
      });
    } else if (type.type === 'joy' || type.type === 'ridgeline') {
      const zeroedStart = Object.assign({}, bins[0], {
        value: 0
      });
      const zeroedEnd = Object.assign({}, bins[bins.length - 1], {
        value: 0
      }); //Ridgeline plots need to visually signify the zero baseline with their start and end position

      zeroedStart.y = zeroedStart.y - bucketSize / 2;
      zeroedEnd.y = zeroedEnd.y + bucketSize / 2;
      const joyBins = [zeroedStart, ...bins, zeroedEnd];
      let joyPoints = [];
      const interpolatorSetting = type.curve || type.interpolator;
      const actualInterpolator = typeof interpolatorSetting === 'string' ? curveHash[interpolatorSetting] : interpolatorSetting;
      let joyArea = line$1().curve(actualInterpolator || curveCatmullRom).x(d => d.x).y(d => d.y);
      const joyHeight = type.amplitude || 0;

      if (type.axis && type.type === 'histogram') {
        renderedSummaryMarks.push(createSummaryAxis({
          summary,
          summaryI,
          axisSettings: {
            baseline: false,
            ...type.axis
          },
          axisCreator,
          projection,
          actualMax,
          adjustedSize,
          columnWidth
        }));
      }

      if (projection === 'horizontal') {
        joyBins.forEach((summaryPoint, i) => {
          const xValue = summaryPoint.y - bucketSize / 2;
          const yValue = type.flip ? summaryPoint.value / actualMax * (columnWidth + joyHeight) - columnWidth / 2 : -summaryPoint.value / actualMax * (columnWidth + joyHeight) + columnWidth / 2;
          joyPoints.push({
            y: yValue,
            x: xValue
          }); //Don't make an interaction point for the first or last

          if (i !== 0 && i !== joyBins.length - 1) {
            summaryXYCoords.push({
              key: summary.name,
              x: xValue + translate[0],
              y: yValue + translate[1],
              pieces: summaryPoint.pieces.map(d => d.piece),
              value: summaryPoint.value
            });
          }
        });
      } else if (projection === 'vertical') {
        joyBins.forEach(summaryPoint => {
          const yValue = summaryPoint.y + bucketSize / 2;
          const xValue = type.flip === true ? summaryPoint.value / actualMax * (columnWidth + joyHeight) - columnWidth / 2 : -summaryPoint.value / actualMax * (columnWidth + joyHeight) + columnWidth / 2;
          joyPoints.push({
            y: yValue,
            x: xValue
          });
          summaryXYCoords.push({
            key: summary.name,
            x: xValue + translate[0],
            y: yValue + translate[1],
            pieces: summaryPoint.pieces.map(d => d.piece),
            value: summaryPoint.value
          });
        });
      } else if (projection === 'radial') {
        const angle = summary.pct - summary.pct_padding / 2;
        const midAngle = summary.pct_start + summary.pct_padding / 2;
        translate = [0, 0];
        joyPoints = joyBins;

        joyArea = inbins => {
          const forward = [];
          inbins.forEach(bin => {
            const outsidePoint = pointOnArcAtAngle([adjustedSize[0] / 2, adjustedSize[1] / 2], midAngle + angle * bin.value / actualMax, (bin.y + bin.y1 - bucketSize / 2) / 2); //Ugh a terrible side effect has appeared

            summaryXYCoords.push({
              key: summary.name,
              x: outsidePoint[0] + translate[0],
              y: outsidePoint[1] + translate[1],
              pieces: bin.pieces.map(d => d.piece),
              value: bin.value
            });
            forward.push(outsidePoint);
          });
          return `M${forward.map(d => d.join(',')).join('L')}Z`;
        };
      }

      if (type.axis) {
        renderedSummaryMarks.push(createSummaryAxis({
          summary,
          summaryI,
          axisSettings: type.axis,
          axisCreator,
          projection,
          actualMax,
          adjustedSize,
          columnWidth
        }));
      }

      renderedSummaryMarks.push(React$1__default.createElement(lib_2, _extends({}, baseMarkProps, {
        transform: `translate(${translate})`,
        key: `summaryPiece-${summaryI}`
      }, eventListeners, {
        renderMode: renderValue,
        markType: "path",
        className: calculatedSummaryClass,
        style: calculatedSummaryStyle,
        d: joyArea(joyPoints),
        role: "img",
        tabIndex: -1,
        "data-o": summary.name,
        "aria-label": `${summary.name} distribution`
      })));
    }
  });
  return {
    marks: renderedSummaryMarks,
    xyPoints: summaryXYCoords
  };
};

const summaryRenderHash = {
  contour: contourRenderFn,
  boxplot: boxplotRenderFn,
  violin: bucketizedRenderingFn,
  heatmap: bucketizedRenderingFn,
  joy: bucketizedRenderingFn,
  ridgeline: bucketizedRenderingFn,
  histogram: bucketizedRenderingFn
};

const orFrameSummaryRenderer = ({
  data,
  type,
  renderMode,
  eventListenersGenerator,
  styleFn,
  classFn,
  positionFn,
  projection,
  adjustedSize,
  chartSize,
  baseMarkProps,
  margin
}) => {
  let summaryRenderFn;

  if (typeof type.type === 'function') {
    summaryRenderFn = type.type;
  } else if (summaryRenderHash[type.type]) {
    summaryRenderFn = summaryRenderHash[type.type];
  } else {
    console.error(`Invalid summary type: ${type.type} - Must be a function or one of the following strings: ${Object.keys(summaryRenderHash).join(', ')}`);
    return;
  }

  return summaryRenderFn({
    data,
    type,
    renderMode,
    eventListenersGenerator,
    styleFn,
    classFn,
    positionFn,
    projection,
    adjustedSize,
    chartSize,
    baseMarkProps,
    margin
  });
};

const drawSummaries = ({
  data,
  type,
  renderMode,
  eventListenersGenerator,
  styleFn,
  classFn,
  positionFn,
  projection,
  adjustedSize,
  margin,
  baseMarkProps
}) => {
  if (!type || !type.type) return;
  type = typeof type === 'string' ? {
    type
  } : type;
  const chartSize = projection === 'vertical' ? adjustedSize[1] : adjustedSize[0];
  return orFrameSummaryRenderer({
    data,
    type,
    renderMode,
    eventListenersGenerator,
    styleFn,
    classFn,
    positionFn,
    projection,
    adjustedSize,
    chartSize,
    margin,
    baseMarkProps
  });
};

const ORIENTATIONS = ['top', 'bottom', 'left', 'right'];

const marginalPointMapper = (orient, width, data) => {
  const xMod = orient === 'left' || orient === 'right' ? width / 2 : 0;
  const yMod = orient === 'bottom' || orient === 'top' ? width / 2 : 0;
  return data.map(p => [p.xy.x + xMod, p.xy.y + yMod]);
};

const formatValue = (value, props) => {
  if (props.tickFormat) {
    return props.tickFormat(value);
  }

  if (value.toString) {
    return value.toString();
  }

  return value;
};

const Axis = props => {
  const [hoverAnnotation, setHoverAnnotation] = React$1.useState(0);
  const [calculatedLabelPosition, setCalculatedLabelPosition] = React$1.useState(null);
  let axisRef = null;

  const boundingBoxMax = () => {
    // && this.props.dynamicLabel ???
    if (!axisRef) return 30;
    const {
      orient = 'left'
    } = props;
    const positionType = orient === 'left' || orient === 'right' ? 'width' : 'height';
    return Math.max(...[...axisRef.querySelectorAll('.axis-label')].map(l => l.getBBox && l.getBBox() || {
      height: 30,
      width: 30
    }).map(d => d[positionType])) + 25;
  };

  React$1.useEffect(() => {
    const {
      label,
      dynamicLabelPosition
    } = props;

    if (!label.position && dynamicLabelPosition) {
      const newBBMax = boundingBoxMax();

      if (newBBMax !== calculatedLabelPosition) {
        setCalculatedLabelPosition(newBBMax);
      }
    }
  });
  const {
    rotate,
    label,
    orient,
    size,
    width,
    height,
    className,
    padding,
    tickValues,
    scale,
    ticks,
    footer,
    tickSize,
    tickLineGenerator,
    baseline,
    margin,
    center,
    annotationFunction,
    glyphFunction,
    marginalSummaryType,
    tickFormat = marginalSummaryType ? () => '' : d => d,
    jaggedBase,
    showLabels
  } = props;
  let {
    axisParts,
    position = [0, 0]
  } = props;
  let axisTickLines;

  if (!axisParts) {
    axisParts = axisPieces({
      padding: padding,
      tickValues,
      scale,
      ticks,
      orient,
      size: [width, height],
      footer,
      tickSize
    });
    axisTickLines = React$1__default.createElement("g", {
      className: `axis ${className}`
    }, axisLines({
      axisParts,
      orient,
      tickLineGenerator,
      className,
      jaggedBase
    }));
  }

  if (axisParts.length === 0) {
    return null;
  }

  let hoverWidth = 50;
  let hoverHeight = height;
  let hoverX = -50;
  let hoverY = 0;
  let baselineX = 0;
  let baselineY = 0;
  let baselineX2 = 0;
  let baselineY2 = height;

  let hoverFunction = e => setHoverAnnotation(e.nativeEvent.offsetY);

  let circleX = 25;
  let textX = -25;
  let textY = 18;
  let lineWidth = width + 25;
  let lineHeight = 0;
  let circleY = hoverAnnotation;
  let annotationOffset = 0;
  let annotationType = 'y';

  switch (orient) {
    case 'right':
      position = [position[0], position[1]];
      hoverX = width;
      baselineX2 = baselineX = width;
      annotationOffset = margin.top;
      lineWidth = -width - 25;
      textX = 5;

      hoverFunction = e => setHoverAnnotation(e.nativeEvent.offsetY - annotationOffset);

      if (center === true) {
        baselineX2 = baselineX = width / 2;
      }

      break;

    case 'top':
      position = [position[0], 0];
      hoverWidth = width;
      hoverHeight = 50;
      hoverY = -50;
      hoverX = 0;
      annotationOffset = margin.left;
      annotationType = 'x';
      baselineX2 = width;
      baselineY2 = 0;

      if (center === true) {
        baselineY2 = baselineY = height / 2;
      }

      hoverFunction = e => setHoverAnnotation(e.nativeEvent.offsetX - annotationOffset);

      circleX = hoverAnnotation;
      circleY = 25;
      textX = 0;
      textY = -10;
      lineWidth = 0;
      lineHeight = height + 25;
      break;

    case 'bottom':
      position = [position[0], 0];
      hoverWidth = width;
      hoverHeight = 50;
      baselineY = baselineY2 = hoverY = height;
      baselineX = hoverX = 0;
      baselineX2 = width;
      annotationOffset = margin.left;

      hoverFunction = e => setHoverAnnotation(e.nativeEvent.offsetX - annotationOffset);

      circleX = hoverAnnotation;
      circleY = 25;
      textX = 0;
      textY = 15;
      lineWidth = 0;
      lineHeight = -height - 25;
      annotationType = 'x';

      if (center === true) {
        baselineY2 = baselineY = height / 2;
      }

      break;

    default:
      position = [position[0], position[1]];
      annotationOffset = margin.top;

      if (center === true) {
        baselineX2 = baselineX = width / 2;
      }

      hoverFunction = e => setHoverAnnotation(e.nativeEvent.offsetY - annotationOffset);

  }

  let annotationBrush;

  if (annotationFunction) {
    const formattedValue = formatValue(scale.invert(hoverAnnotation), props);
    const hoverGlyph = glyphFunction ? glyphFunction({
      lineHeight,
      lineWidth,
      value: scale.invert(hoverAnnotation)
    }) : React$1__default.createElement("g", null, React$1__default.isValidElement(formattedValue) ? React$1__default.createElement("g", {
      transform: `translate(${textX},${textY})`
    }, formattedValue) : React$1__default.createElement("text", {
      x: textX,
      y: textY
    }, formattedValue), React$1__default.createElement("circle", {
      r: 5
    }), React$1__default.createElement("line", {
      x1: lineWidth,
      y1: lineHeight,
      style: {
        stroke: 'black'
      }
    }));
    const annotationSymbol = hoverAnnotation ? React$1__default.createElement("g", {
      style: {
        pointerEvents: 'none'
      },
      transform: `translate(${circleX},${circleY})`
    }, hoverGlyph) : null;
    annotationBrush = React$1__default.createElement("g", {
      className: "annotation-brush",
      transform: `translate(${hoverX},${hoverY})`
    }, React$1__default.createElement("rect", {
      style: {
        fillOpacity: 0
      },
      height: hoverHeight,
      width: hoverWidth,
      onMouseMove: hoverFunction,
      onClick: () => annotationFunction({
        className: 'dynamic-axis-annotation',
        type: annotationType,
        value: scale.invert(hoverAnnotation)
      }),
      onMouseOut: () => setHoverAnnotation(undefined)
    }), annotationSymbol);
  } // margin Summaries


  let summaryGraphic;
  const {
    xyPoints
  } = props;

  if (marginalSummaryType && xyPoints) {
    const summaryWidth = Math.max(margin[orient] - 6, 5);
    const decoratedSummaryType = typeof marginalSummaryType === 'string' ? {
      type: marginalSummaryType
    } : marginalSummaryType;

    if (decoratedSummaryType.flip === undefined && (orient === 'bottom' || orient === 'right')) {
      decoratedSummaryType.flip = true;
    }

    const summaryStyle = decoratedSummaryType.summaryStyle ? typeof decoratedSummaryType.summaryStyle === 'function' ? decoratedSummaryType.summaryStyle : () => decoratedSummaryType.summaryStyle : () => ({
      fill: 'black',
      fillOpacity: 0.5,
      stroke: 'black',
      strokeDasharray: '0'
    });
    const summaryRenderMode = decoratedSummaryType.renderMode ? () => decoratedSummaryType.renderMode : () => undefined;
    const summaryClass = decoratedSummaryType.summaryClass ? () => decoratedSummaryType.summaryClass : () => '';

    const dataFilter = decoratedSummaryType.filter || (() => true);

    const forSummaryData = xyPoints.filter(p => p.x !== undefined && p.y !== undefined && dataFilter(p.data)).map(d => ({ ...d,
      xy: {
        x: orient === 'top' || orient === 'bottom' ? scale(d.x) : 0,
        y: orient === 'left' || orient === 'right' ? scale(d.y) : 0
      },
      piece: {
        scaledVerticalValue: scale(d.y),
        scaledValue: scale(d.x)
      },
      value: orient === 'top' || orient === 'bottom' ? scale(d.y) : scale(d.x),
      scaledValue: scale(d.x),
      scaledVerticalValue: scale(d.y)
    }));
    const renderedSummary = drawSummaries({
      data: {
        column: {
          middle: summaryWidth / 2,
          pieceData: forSummaryData,
          width: summaryWidth,
          xyData: forSummaryData
        }
      },
      type: decoratedSummaryType,
      renderMode: summaryRenderMode,
      eventListenersGenerator: decoratedSummaryType.eventListenersGenerator || (() => ({})),
      styleFn: summaryStyle,
      classFn: summaryClass,
      positionFn: () => [0, 0],
      projection: orient === 'top' || orient === 'bottom' ? 'horizontal' : 'vertical',
      adjustedSize: size,
      margin: {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0
      },
      baseMarkProps: {}
    });
    let points;

    if (decoratedSummaryType.showPoints === true) {
      const mappedPoints = marginalPointMapper(orient, summaryWidth, forSummaryData);
      points = mappedPoints.map((d, i) => React$1__default.createElement("circle", {
        key: `axis-summary-point-${i}`,
        cx: d[0],
        cy: d[1],
        r: decoratedSummaryType.r || 3,
        style: decoratedSummaryType.pointStyle || {
          fill: 'black',
          fillOpacity: 0.1
        }
      }));
    }

    const translation = {
      left: [-margin.left + 2, 0],
      right: [size[0] + 2, 0],
      top: [0, -margin.top + 2],
      bottom: [0, size[1] + 2]
    };
    summaryGraphic = React$1__default.createElement("g", {
      transform: `translate(${translation[orient]})`
    }, React$1__default.createElement("g", {
      transform: `translate(${(decoratedSummaryType.type === 'contour' || decoratedSummaryType.type === 'boxplot') && (orient === 'left' || orient === 'right') ? summaryWidth / 2 : 0},${(decoratedSummaryType.type === 'contour' || decoratedSummaryType.type === 'boxplot') && (orient === 'top' || orient === 'bottom') ? summaryWidth / 2 : 0})`
    }, renderedSummary.marks), points);
  }

  let axisTitle;
  const axisTickLabels = showLabels === true ? axisLabels({
    tickFormat,
    axisParts,
    orient,
    rotate,
    center
  }) : null;

  if (label) {
    let labelName = '';

    if (typeof label === 'string' || label instanceof String) {
      labelName = label;
    } else if (label.name) {
      labelName = label.name;
    } else if (React$1__default.isValidElement(label)) {
      labelName = label;
    }

    const labelPosition = label.position || {};
    const locationMod = labelPosition.location || 'outside';
    let anchorMod = labelPosition.anchor || 'middle';
    const distance = label.locationDistance || calculatedLabelPosition;
    const rotateHash = {
      left: -90,
      right: 90,
      top: 0,
      bottom: 0
    };
    const rotation = labelPosition.rotation || rotateHash[orient];
    const positionHash = {
      left: {
        start: [0, size[1]],
        middle: [0, size[1] / 2],
        end: [0, 0],
        inside: [distance || 15, 0],
        outside: [-(distance || 45), 0]
      },
      right: {
        start: [size[0] + 0, size[1]],
        middle: [size[0] + 0, size[1] / 2],
        end: [size[0] + 0, 0],
        inside: [-(distance || 15), 0],
        outside: [distance || 45, 0]
      },
      top: {
        start: [0, 0],
        middle: [0 + size[0] / 2, 0],
        end: [0 + size[0], 0],
        inside: [0, distance || 15],
        outside: [0, -(distance || 40)]
      },
      bottom: {
        start: [0, size[1]],
        middle: [0 + size[0] / 2, size[1]],
        end: [0 + size[0], size[1]],
        inside: [0, -(distance || 5)],
        outside: [0, distance || 50]
      }
    };
    const translation = positionHash[orient][anchorMod];
    const location = positionHash[orient][locationMod];
    translation[0] = translation[0] + location[0];
    translation[1] = translation[1] + location[1];

    if (anchorMod === 'start' && orient === 'right') {
      anchorMod = 'end';
    } else if (anchorMod === 'end' && orient === 'right') {
      anchorMod = 'start';
    }

    axisTitle = React$1__default.createElement("g", {
      className: `axis-title ${className}`,
      transform: `translate(${[translation[0] + position[0], translation[1] + position[1]]}) rotate(${rotation})`
    }, React$1__default.isValidElement(labelName) ? labelName : React$1__default.createElement("text", {
      textAnchor: anchorMod
    }, labelName));
  }

  const axisAriaLabel = `${orient} axis ${axisParts && axisParts.length > 0 && `from ${tickFormat(axisParts[0].value, 0)} to ${tickFormat(axisParts[axisParts.length - 1].value, axisParts.length - 1)}` || 'without ticks'}`;
  return React$1__default.createElement("g", {
    className: className,
    "aria-label": axisAriaLabel,
    ref: node => axisRef = node
  }, annotationBrush, axisTickLabels, axisTickLines, baseline ? React$1__default.createElement("line", {
    key: "baseline",
    className: `axis-baseline ${className}`,
    stroke: "black",
    strokeLinecap: "square",
    x1: baselineX,
    x2: baselineX2,
    y1: baselineY,
    y2: baselineY2
  }) : null, axisTitle, summaryGraphic);
};

Axis.propTypes = {
  orient: propTypes.oneOf(ORIENTATIONS),
  size: propTypes.array,
  footer: propTypes.bool,
  tickSize: propTypes.number,
  baseline: propTypes.bool,
  center: propTypes.bool,
  glyphFunction: propTypes.func,
  label: propTypes.oneOfType([propTypes.string, propTypes.object]),
  tickValues: propTypes.array,
  ticks: propTypes.number,
  tickFormat: propTypes.func,
  tickLineGenerator: propTypes.func,
  rotate: propTypes.number,
  padding: propTypes.number,
  scale: propTypes.func,
  annotationFunction: propTypes.func,
  className: propTypes.string,
  margin: propTypes.object,
  name: propTypes.string,
  showLineTicks: propTypes.bool,
  showLabels: propTypes.bool,
  xyPoints: propTypes.array,
  jaggedBase: propTypes.bool,
  marginalSummaryType: propTypes.object
};
Axis.defaultProps = {
  rotate: 0,
  label: {
    position: false
  },
  tickFormat: d => d,
  size: null,
  className: '',
  padding: 0,
  tickValues: null,
  ticks: null,
  footer: false,
  tickSize: -10,
  baseline: true,
  margin: {
    top: 0,
    bottom: 0,
    left: 0,
    right: 0
  },
  center: false,
  showLineTicks: true,
  showLabels: true,
  jaggedBase: false
};

const XAxis = props => {
  return React$1__default.createElement(Axis, props);
};

XAxis.propTypes = { ...Axis.propTypes,
  orient: propTypes.oneOf(['top', 'bottom'])
};
XAxis.defaultProps = {
  orient: 'bottom'
};

const YAxis = props => {
  return React$1__default.createElement(Axis, props);
};

YAxis.propTypes = { ...Axis.propTypes,
  orient: propTypes.oneOf(['left', 'right'])
};
YAxis.defaultProps = {
  orient: 'left'
};

const getAdjustedPositionSize = ({
  size = [500, 500],
  position = [0, 0],
  margin,
  projection
}) => {
  const heightAdjust = margin.top + margin.bottom;
  const widthAdjust = margin.left + margin.right;
  const adjustedPosition = [position[0], position[1]];
  let adjustedSize = [size[0] - widthAdjust, size[1] - heightAdjust];

  if (projection === 'radial') {
    const minSize = Math.min(adjustedSize[0], adjustedSize[1]);
    adjustedSize = [minSize, minSize];
  }

  return {
    adjustedPosition,
    adjustedSize
  };
};

const drawMarginPath = ({
  margin,
  size,
  inset = 0
}) => {
  const iSize = [size[0] - inset, size[1] - inset];
  return `M0,0 h${size[0]} v${size[1]} h-${size[0]}Z M${margin.left - inset},${margin.top - inset} v${size[1] + inset * 2 - margin.top - margin.bottom} h${iSize[0] + inset * 3 - margin.left - margin.right} v-${iSize[1] + inset * 3 - margin.top - margin.bottom}Z`;
};

const toMarginGraphic = ({
  matte,
  size,
  margin,
  name
}) => {
  let marginGraphic = null;

  if (typeof matte === 'function') {
    marginGraphic = matte({
      size,
      margin
    });
  } else if (React$1__default.isValidElement(matte)) {
    marginGraphic = matte;
  } else if (matte === true) {
    marginGraphic = React$1__default.createElement("path", {
      fill: "white",
      transform: `translate(${-margin.left},${-margin.top})`,
      d: drawMarginPath({
        margin,
        size,
        inset: 0
      }),
      className: `${name}-matte`
    });
  }

  return marginGraphic;
};

const generateFrameTitle = ({
  title: rawTitle = {
    title: '',
    orient: 'top'
  },
  size
}) => {
  let finalTitle = null;
  const {
    title,
    orient = 'top'
  } = rawTitle;
  let x = 0,
      y = 0,
      transform;

  switch (orient) {
    case 'top':
      x = size[0] / 2;
      y = 25;
      break;

    case 'bottom':
      x = size[0] / 2;
      y = size[1] - 25;
      break;

    case 'left':
      x = 25;
      y = size[1] / 2;
      transform = 'rotate(-90)';
      break;

    case 'right':
      x = size[0] - 25;
      y = size[1] / 2;
      transform = 'rotate(90)';
      break;
  }

  const gTransform = `translate(${x},${y})`;

  if (typeof title === 'string' && title.length > 0) {
    finalTitle = React$1__default.createElement("g", {
      transform: gTransform
    }, React$1__default.createElement("text", {
      className: 'frame-title',
      transform: transform,
      style: {
        textAnchor: 'middle',
        pointerEvents: 'none'
      }
    }, title));
  } else if (title) {
    //assume if defined then its an svg mark of some sort
    finalTitle = React$1__default.createElement("g", {
      transform: gTransform
    }, title);
  }

  return finalTitle;
};

const extentValue = extent => extent && extent.extent || Array.isArray(extent) && extent || [];

const trimExtent = ({
  xExtent,
  yExtent,
  calculatedXExtent,
  calculatedYExtent
}) => {
  const userDefinedXExtent = extentValue(xExtent);
  const userDefinedYExtent = extentValue(yExtent);
  const xMin = userDefinedXExtent && userDefinedXExtent[0] !== undefined ? userDefinedXExtent[0] : calculatedXExtent[0];
  const xMax = userDefinedXExtent && userDefinedXExtent[1] !== undefined ? userDefinedXExtent[1] : calculatedXExtent[1];
  const yMin = userDefinedYExtent && userDefinedYExtent[0] !== undefined ? userDefinedYExtent[0] : calculatedYExtent[0];
  const yMax = userDefinedYExtent && userDefinedYExtent[1] !== undefined ? userDefinedYExtent[1] : calculatedYExtent[1];
  const finalYExtent = [yMin, yMax];
  const finalXExtent = [xMin, xMax];
  return {
    yExtent: finalYExtent,
    xExtent: finalXExtent
  };
};

const getFrameScopeExtent = plotChildren => {
  // frame scope scales
  return plotChildren.map(d => {
    const calculatedXExtent = extent(d.props.data, d.props.xAccessor);
    const calculatedYExtent = extent(d.props.data, d.props.yAccessor);
    return trimExtent({
      xExtent: d.props.xExtent,
      yExtent: d.props.yExtent,
      calculatedXExtent,
      calculatedYExtent
    });
  }).reduce((acc, cur) => {
    if (acc === null) {
      acc = Object.assign({}, cur);
    } else {
      acc.xExtent[0] = Math.min(acc.xExtent[0], cur.xExtent[0]);
      acc.xExtent[1] = Math.max(acc.xExtent[1], cur.xExtent[1]);
      acc.yExtent[0] = Math.min(acc.yExtent[0], cur.yExtent[0]);
      acc.yExtent[1] = Math.max(acc.yExtent[1], cur.yExtent[1]);
    }

    return acc;
  }, null);
};

const toRenderedAreas = ({
  data,
  xScale,
  yScale,
  useCanvas,
  styleFn = () => ({}),
  classFn = () => '',
  renderKeyFn,
  renderFn,
  customMark
}) => {
  const canvasPipeline = [];
  const svgPipeline = [];
  const svgPipe = [];
  data.forEach((d, i) => {
    let drawD = '';
    let shouldBeValid = false;

    if (d.customMark) {
      drawD = d.customMark;
      shouldBeValid = true;
    } else if (d.type === 'MultiPolygon') {
      d.coordinates.forEach(coord => {
        coord.forEach(c => {
          drawD += `M${c.map(p => `${xScale(p[0])},${yScale(p[1])}`).join('L')}Z `;
        });
      });
    } else if (customMark) {
      const projectedCoordinates = d._xyCoordinates.map(p => [xScale(p[0]), yScale(p[1])]);

      drawD = customMark({
        d,
        projectedCoordinates,
        xScale,
        yScale,
        bounds: shapeBounds(projectedCoordinates)
      });
      shouldBeValid = true;
    } else {
      drawD = `M${d._xyCoordinates.map(p => `${xScale(p[0])},${yScale(p[1])}`).join('L')}Z`;
    }

    const renderKey = renderKeyFn ? renderKeyFn(d, i) : `area-${i}`;
    const className = classFn ? `xyframe-area ${classFn(d)}` : 'xyframe-area';

    if (shouldBeValid && React$1__default.isValidElement(drawD)) {
      renderedAreas.push(drawD);
    } else if (useCanvas === true) {
      const canvasPipe = {
        type: 'area',
        baseClass: 'xyframe-area',
        tx: 0,
        ty: 0,
        d,
        i,
        markProps: {
          markType: 'path',
          d: drawD
        },
        styleFn,
        renderFn,
        classFn: () => className
      };
      canvasPipeline.push(canvasPipe);
    } else {
      svgPipe.push(React$1__default.createElement(lib_2, {
        key: renderKey,
        forceUpdate: true,
        renderMode: renderFn ? renderFn(d, i) : undefined,
        className: className,
        markType: "path",
        d: drawD,
        style: styleFn(d, i)
      }));
    }
  });

  if (useCanvas === false) {
    svgPipeline.push(React$1__default.createElement("g", {
      key: 'area',
      className: 'area',
      role: 'group',
      tabIndex: 0
    }, svgPipe));
  }

  return {
    svgPipeline,
    canvasPipeline
  };
};

const toRenderedPoints = ({
  xScale,
  yScale,
  data,
  customMark,
  useCanvas,
  styleFn,
  classFn,
  renderKeyFn,
  renderMode,
  baseMarkProps
}) => {
  const x = projectedX;
  const y = projectedY;
  const xMiddle = projectedXMiddle;
  const yMiddle = projectedYMiddle;
  const canvasPipeline = [];
  const svgPipeline = [];
  data.forEach((d, i) => {
    const dX = xScale(d[xMiddle] || d[x]);
    const dY = yScale(d[yMiddle] || d[y]);
    const pointAriaLabel = `Point at x ${d.x} and y ${d.y}`;
    const renderedCustomMark = !customMark ? undefined : React.isValidElement(customMark) ? customMark : customMark({
      d: d.data,
      xy: d,
      i,
      xScale,
      yScale
    });
    const markProps = customMark ? Object.assign(baseMarkProps, renderedCustomMark.props, {
      'aria-label': pointAriaLabel
    }) : { ...baseMarkProps,
      key: `piece-${i}`,
      markType: 'circle',
      r: 2,
      'aria-label': pointAriaLabel
    };

    if (renderedCustomMark && renderedCustomMark.props && !renderedCustomMark.props.markType && useCanvas !== true) {
      svgPipeline.push(React.createElement("g", {
        transform: `translate(${dX},${dY})`,
        key: renderKeyFn ? renderKeyFn(d.data, i) : `custom-point-mark-${i}`,
        style: styleFn ? styleFn(d.data, i) : {},
        className: classFn ? classFn(d.data, i) : ''
      }, renderedCustomMark));
    } else {
      if (useCanvas === true) {
        const canvasPoint = {
          type: 'point',
          baseClass: 'frame-piece',
          tx: dX,
          ty: dY,
          d,
          i,
          markProps,
          styleFn,
          renderFn: renderMode,
          classFn
        };
        canvasPipeline.push(canvasPoint);
      } else {
        const yCoordinates = Array.isArray(d[y]) ? d[y].map(p => yScale(p)) : [dY];
        yCoordinates.forEach((yc, yi) => {
          const xCoordinates = Array.isArray(d[x]) ? d[x].map(p => xScale(p)) : [dX];
          xCoordinates.forEach((xc, xi) => {
            svgPipeline.push(clonedAppliedElement({
              baseClass: 'frame-piece',
              tx: xc,
              ty: yc,
              d: d.data && { ...d,
                ...d.data
              } || d,
              i: yi === 0 && xi === 0 ? i : `${i}-${yi}-${xi}`,
              markProps,
              styleFn,
              renderFn: renderMode,
              renderKeyFn,
              classFn,
              yi
            }));
          });
        });
      }
    }
  });
  return {
    svgPipeline,
    canvasPipeline
  };
};

const stringToFn = (accessor, defaultAccessor, raw) => {
  if (!accessor && defaultAccessor) {
    return defaultAccessor;
  } else if (typeof accessor === 'object') {
    return () => accessor;
  } else if (accessor instanceof Function) {
    return accessor;
  } else if (raw === true) {
    const castAccessor = accessor;
    return () => castAccessor;
  } else if (typeof accessor === 'string') {
    return d => d[accessor];
  }

  return () => undefined;
};

const emptyObjectReturnFunction = () => ({});

const emptyStringReturnFunction = () => '';

const naturalLanguageLineType = {
  line: {
    items: 'line',
    chart: 'line chart'
  },
  area: {
    items: 'summary',
    chart: 'summary chart'
  },
  cumulative: {
    items: 'line',
    chart: 'cumulative chart'
  },
  'cumulative-reverse': {
    items: 'line',
    chart: 'cumulative chart'
  },
  linepercent: {
    items: 'line',
    chart: 'line chart'
  },
  stackedarea: {
    items: 'stacked area',
    chart: 'stacked area chart'
  },
  'stackedarea-invert': {
    items: 'stacked area',
    chart: 'stacked area chart'
  },
  stackedpercent: {
    items: 'stacked area',
    chart: 'stacked area chart'
  },
  'stackedpercent-invert': {
    items: 'stacked area',
    chart: 'stacked area chart'
  },
  bumparea: {
    items: 'ranked area',
    chart: 'ranked area chart'
  },
  'bumparea-invert': {
    items: 'ranked area',
    chart: 'ranked area chart'
  },
  bumpline: {
    items: 'ranked line',
    chart: 'ranked line chart'
  },
  difference: {
    items: 'line',
    chart: 'difference chart'
  }
};

const toPipeline = props => {
  const {
    lineStyle,
    lineClass,
    lineCustomMarks,
    lineRenderMode,
    lineType,
    areaStyle,
    areaClass,
    areaRenderMode,
    areaCustomMarks,
    pointStyle,
    pointClass,
    pointCustomMarks,
    pointRenderMode,
    areaUseCanvas,
    lineUseCanvas,
    pointUseCanvas,
    showPoints,
    frameXScale: xScale,
    frameYScale: yScale,
    yExtent
  } = props;
  const {
    projection,
    ...rest
  } = props;
  const {
    projectedLines,
    projectedAreas,
    projectedPoints
  } = projection({
    frameXScale: xScale,
    frameYScale: yScale,
    ...rest,
    showPoints: true
  });
  const lineAriaLabel = lineType && lineType.type !== undefined && typeof lineType.type === 'string' && naturalLanguageLineType[lineType.type];

  if (lineType && lineType.type && Object.keys(naturalLanguageLineType).includes(lineType.type)) {
    const maxY = projectedLines.map(d => max(d._xyCoordinates, d => d.yTop));

    if (yExtent && yExtent.length > 0) {
      yScale.domain([yExtent[0], Math.max(...maxY)]);
    } else {
      yScale.domain([0, Math.max(...maxY)]);
    }
  }

  const {
    svgPipeline: lineSvg,
    canvasPipeline: lineCanvas
  } = toRenderedLines({
    useCanvas: lineUseCanvas,
    xScale,
    yScale,
    styleFn: stringToFn(lineStyle, emptyObjectReturnFunction, true),
    classFn: stringToFn(lineClass, emptyStringReturnFunction, true),
    renderFn: stringToFn(lineRenderMode, undefined, true),
    customMarks: lineCustomMarks,
    type: lineType,
    data: projectedLines,
    ariaLabel: lineAriaLabel,
    baseMarkProps: {}
  });
  const {
    svgPipeline: areaSvg,
    canvasPipeline: areaCanvas
  } = toRenderedAreas({
    useCanvas: areaUseCanvas,
    xScale,
    yScale,
    styleFn: stringToFn(areaStyle, emptyObjectReturnFunction, true),
    classFn: stringToFn(areaClass, emptyStringReturnFunction, true),
    renderFn: stringToFn(areaRenderMode, undefined, true),
    customMarks: areaCustomMarks,
    data: projectedAreas
  });
  const {
    svgPipeline: pointsSvg,
    canvasPipeline: pointsCanvas
  } = showPoints === true ? toRenderedPoints({
    useCanvas: pointUseCanvas,
    xScale,
    yScale,
    styleFn: stringToFn(pointStyle, emptyObjectReturnFunction, true),
    classFn: stringToFn(pointClass, emptyStringReturnFunction, true),
    renderFn: stringToFn(pointRenderMode, undefined, true),
    customMarks: pointCustomMarks,
    data: projectedPoints
  }) : {
    svgPipeline: [],
    canvasPipeline: []
  };
  const svgPipe = [...areaSvg, ...lineSvg, ...pointsSvg];
  const canvasPipe = [...areaCanvas, ...lineCanvas, ...pointsCanvas];
  return {
    svgPipe,
    canvasPipe,
    xyPoints: projectedPoints
  };
};

const FilterDefs = ({
  matte,
  key,
  additionalDefs
}) => React$1__default.createElement("defs", null, React$1__default.createElement("filter", {
  id: "paintyFilterHeavy"
}, React$1__default.createElement("feGaussianBlur", {
  id: "gaussblurrer",
  in: "SourceGraphic",
  stdDeviation: 4,
  colorInterpolationFilters: "sRGB",
  result: "blur"
}), React$1__default.createElement("feColorMatrix", {
  in: "blur",
  mode: "matrix",
  values: "1 0 0 0 0  0 1 0 0 0  0 0 1 0 0  0 0 0 34 -7",
  result: "gooey"
})), React$1__default.createElement("filter", {
  id: "paintyFilterLight"
}, React$1__default.createElement("feGaussianBlur", {
  id: "gaussblurrer",
  in: "SourceGraphic",
  stdDeviation: 2,
  colorInterpolationFilters: "sRGB",
  result: "blur"
}), React$1__default.createElement("feColorMatrix", {
  in: "blur",
  mode: "matrix",
  values: "1 0 0 0 0  0 1 0 0 0  0 0 1 0 0  0 0 0 34 -7",
  result: "gooey"
})), React$1__default.createElement("clipPath", {
  id: `matte-clip-${key}`
}, matte), additionalDefs);

var canvas = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RoughCanvasAsync = exports.RoughCanvas = undefined;



var _regenerator2 = _interopRequireDefault(regenerator);

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();





function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var RoughCanvas = exports.RoughCanvas = function () {
  function RoughCanvas(canvas, config) {
    _classCallCheck(this, RoughCanvas);

    this.canvas = canvas;
    this.ctx = this.canvas.getContext("2d");
    this._init(config);
  }

  _createClass(RoughCanvas, [{
    key: '_init',
    value: function _init(config) {
      this.gen = new generator.RoughGenerator(config, this.canvas);
    }
  }, {
    key: 'line',
    value: function line(x1, y1, x2, y2, options) {
      var d = this.gen.line(x1, y1, x2, y2, options);
      this.draw(d);
      return d;
    }
  }, {
    key: 'rectangle',
    value: function rectangle(x, y, width, height, options) {
      var d = this.gen.rectangle(x, y, width, height, options);
      this.draw(d);
      return d;
    }
  }, {
    key: 'ellipse',
    value: function ellipse(x, y, width, height, options) {
      var d = this.gen.ellipse(x, y, width, height, options);
      this.draw(d);
      return d;
    }
  }, {
    key: 'circle',
    value: function circle(x, y, diameter, options) {
      var d = this.gen.circle(x, y, diameter, options);
      this.draw(d);
      return d;
    }
  }, {
    key: 'linearPath',
    value: function linearPath(points, options) {
      var d = this.gen.linearPath(points, options);
      this.draw(d);
      return d;
    }
  }, {
    key: 'polygon',
    value: function polygon(points, options) {
      var d = this.gen.polygon(points, options);
      this.draw(d);
      return d;
    }
  }, {
    key: 'arc',
    value: function arc(x, y, width, height, start, stop, closed, options) {
      var d = this.gen.arc(x, y, width, height, start, stop, closed, options);
      this.draw(d);
      return d;
    }
  }, {
    key: 'curve',
    value: function curve(points, options) {
      var d = this.gen.curve(points, options);
      this.draw(d);
      return d;
    }
  }, {
    key: 'path',
    value: function path(d, options) {
      var drawing = this.gen.path(d, options);
      this.draw(drawing);
      return drawing;
    }
  }, {
    key: 'draw',
    value: function draw(drawable) {
      var sets = drawable.sets || [];
      var o = drawable.options || this.gen.defaultOptions;
      var ctx = this.ctx;
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = sets[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var drawing = _step.value;

          switch (drawing.type) {
            case 'path':
              ctx.save();
              ctx.strokeStyle = o.stroke;
              ctx.lineWidth = o.strokeWidth;
              this._drawToContext(ctx, drawing);
              ctx.restore();
              break;
            case 'fillPath':
              ctx.save();
              ctx.fillStyle = o.fill;
              this._drawToContext(ctx, drawing, o);
              ctx.restore();
              break;
            case 'fillSketch':
              this._fillSketch(ctx, drawing, o);
              break;
            case 'path2Dfill':
              {
                this.ctx.save();
                this.ctx.fillStyle = o.fill;
                var p2d = new Path2D(drawing.path);
                this.ctx.fill(p2d);
                this.ctx.restore();
                break;
              }
            case 'path2Dpattern':
              {
                var size = drawing.size;
                var hcanvas = document.createElement('canvas');
                var hcontext = hcanvas.getContext("2d");
                var bbox = this._computeBBox(drawing.path);
                if (bbox && (bbox.width || bbox.height)) {
                  hcanvas.width = this.canvas.width;
                  hcanvas.height = this.canvas.height;
                  hcontext.translate(bbox.x || 0, bbox.y || 0);
                } else {
                  hcanvas.width = size[0];
                  hcanvas.height = size[1];
                }
                this._fillSketch(hcontext, drawing, o);
                this.ctx.save();
                this.ctx.fillStyle = this.ctx.createPattern(hcanvas, 'repeat');
                var _p2d = new Path2D(drawing.path);
                this.ctx.fill(_p2d);
                this.ctx.restore();
                break;
              }
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
  }, {
    key: '_computeBBox',
    value: function _computeBBox(d) {
      if (self.document) {
        try {
          var ns = "http://www.w3.org/2000/svg";
          var svg = self.document.createElementNS(ns, "svg");
          svg.setAttribute("width", "0");
          svg.setAttribute("height", "0");
          var pathNode = self.document.createElementNS(ns, "path");
          pathNode.setAttribute('d', d);
          svg.appendChild(pathNode);
          self.document.body.appendChild(svg);
          var bbox = pathNode.getBBox();
          self.document.body.removeChild(svg);
          return bbox;
        } catch (err) {}
      }
      return null;
    }
  }, {
    key: '_fillSketch',
    value: function _fillSketch(ctx, drawing, o) {
      var fweight = o.fillWeight;
      if (fweight < 0) {
        fweight = o.strokeWidth / 2;
      }
      ctx.save();
      ctx.strokeStyle = o.fill;
      ctx.lineWidth = fweight;
      this._drawToContext(ctx, drawing);
      ctx.restore();
    }
  }, {
    key: '_drawToContext',
    value: function _drawToContext(ctx, drawing) {
      ctx.beginPath();
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = drawing.ops[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var item = _step2.value;

          var data = item.data;
          switch (item.op) {
            case 'move':
              ctx.moveTo(data[0], data[1]);
              break;
            case 'bcurveTo':
              ctx.bezierCurveTo(data[0], data[1], data[2], data[3], data[4], data[5]);
              break;
            case 'qcurveTo':
              ctx.quadraticCurveTo(data[0], data[1], data[2], data[3]);
              break;
            case 'lineTo':
              ctx.lineTo(data[0], data[1]);
              break;
          }
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      if (drawing.type === 'fillPath') {
        ctx.fill();
      } else {
        ctx.stroke();
      }
    }
  }, {
    key: 'generator',
    get: function get() {
      return this.gen;
    }
  }], [{
    key: 'createRenderer',
    value: function createRenderer() {
      return new renderer.RoughRenderer();
    }
  }]);

  return RoughCanvas;
}();

var RoughCanvasAsync = exports.RoughCanvasAsync = function (_RoughCanvas) {
  _inherits(RoughCanvasAsync, _RoughCanvas);

  function RoughCanvasAsync() {
    _classCallCheck(this, RoughCanvasAsync);

    return _possibleConstructorReturn(this, (RoughCanvasAsync.__proto__ || Object.getPrototypeOf(RoughCanvasAsync)).apply(this, arguments));
  }

  _createClass(RoughCanvasAsync, [{
    key: '_init',
    value: function _init(config) {
      this.gen = new generator.RoughGeneratorAsync(config, this.canvas);
    }
  }, {
    key: 'line',
    value: function () {
      var _ref = _asyncToGenerator( /*#__PURE__*/_regenerator2.default.mark(function _callee(x1, y1, x2, y2, options) {
        var d;
        return _regenerator2.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return this.gen.line(x1, y1, x2, y2, options);

              case 2:
                d = _context.sent;

                this.draw(d);
                return _context.abrupt('return', d);

              case 5:
              case 'end':
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function line(_x, _x2, _x3, _x4, _x5) {
        return _ref.apply(this, arguments);
      }

      return line;
    }()
  }, {
    key: 'rectangle',
    value: function () {
      var _ref2 = _asyncToGenerator( /*#__PURE__*/_regenerator2.default.mark(function _callee2(x, y, width, height, options) {
        var d;
        return _regenerator2.default.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this.gen.rectangle(x, y, width, height, options);

              case 2:
                d = _context2.sent;

                this.draw(d);
                return _context2.abrupt('return', d);

              case 5:
              case 'end':
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function rectangle(_x6, _x7, _x8, _x9, _x10) {
        return _ref2.apply(this, arguments);
      }

      return rectangle;
    }()
  }, {
    key: 'ellipse',
    value: function () {
      var _ref3 = _asyncToGenerator( /*#__PURE__*/_regenerator2.default.mark(function _callee3(x, y, width, height, options) {
        var d;
        return _regenerator2.default.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return this.gen.ellipse(x, y, width, height, options);

              case 2:
                d = _context3.sent;

                this.draw(d);
                return _context3.abrupt('return', d);

              case 5:
              case 'end':
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function ellipse(_x11, _x12, _x13, _x14, _x15) {
        return _ref3.apply(this, arguments);
      }

      return ellipse;
    }()
  }, {
    key: 'circle',
    value: function () {
      var _ref4 = _asyncToGenerator( /*#__PURE__*/_regenerator2.default.mark(function _callee4(x, y, diameter, options) {
        var d;
        return _regenerator2.default.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return this.gen.circle(x, y, diameter, options);

              case 2:
                d = _context4.sent;

                this.draw(d);
                return _context4.abrupt('return', d);

              case 5:
              case 'end':
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function circle(_x16, _x17, _x18, _x19) {
        return _ref4.apply(this, arguments);
      }

      return circle;
    }()
  }, {
    key: 'linearPath',
    value: function () {
      var _ref5 = _asyncToGenerator( /*#__PURE__*/_regenerator2.default.mark(function _callee5(points, options) {
        var d;
        return _regenerator2.default.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                _context5.next = 2;
                return this.gen.linearPath(points, options);

              case 2:
                d = _context5.sent;

                this.draw(d);
                return _context5.abrupt('return', d);

              case 5:
              case 'end':
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function linearPath(_x20, _x21) {
        return _ref5.apply(this, arguments);
      }

      return linearPath;
    }()
  }, {
    key: 'polygon',
    value: function () {
      var _ref6 = _asyncToGenerator( /*#__PURE__*/_regenerator2.default.mark(function _callee6(points, options) {
        var d;
        return _regenerator2.default.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                _context6.next = 2;
                return this.gen.polygon(points, options);

              case 2:
                d = _context6.sent;

                this.draw(d);
                return _context6.abrupt('return', d);

              case 5:
              case 'end':
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function polygon(_x22, _x23) {
        return _ref6.apply(this, arguments);
      }

      return polygon;
    }()
  }, {
    key: 'arc',
    value: function () {
      var _ref7 = _asyncToGenerator( /*#__PURE__*/_regenerator2.default.mark(function _callee7(x, y, width, height, start, stop, closed, options) {
        var d;
        return _regenerator2.default.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                _context7.next = 2;
                return this.gen.arc(x, y, width, height, start, stop, closed, options);

              case 2:
                d = _context7.sent;

                this.draw(d);
                return _context7.abrupt('return', d);

              case 5:
              case 'end':
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function arc(_x24, _x25, _x26, _x27, _x28, _x29, _x30, _x31) {
        return _ref7.apply(this, arguments);
      }

      return arc;
    }()
  }, {
    key: 'curve',
    value: function () {
      var _ref8 = _asyncToGenerator( /*#__PURE__*/_regenerator2.default.mark(function _callee8(points, options) {
        var d;
        return _regenerator2.default.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                _context8.next = 2;
                return this.gen.curve(points, options);

              case 2:
                d = _context8.sent;

                this.draw(d);
                return _context8.abrupt('return', d);

              case 5:
              case 'end':
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function curve(_x32, _x33) {
        return _ref8.apply(this, arguments);
      }

      return curve;
    }()
  }, {
    key: 'path',
    value: function () {
      var _ref9 = _asyncToGenerator( /*#__PURE__*/_regenerator2.default.mark(function _callee9(d, options) {
        var drawing;
        return _regenerator2.default.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                _context9.next = 2;
                return this.gen.path(d, options);

              case 2:
                drawing = _context9.sent;

                this.draw(drawing);
                return _context9.abrupt('return', drawing);

              case 5:
              case 'end':
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function path(_x34, _x35) {
        return _ref9.apply(this, arguments);
      }

      return path;
    }()
  }]);

  return RoughCanvasAsync;
}(RoughCanvas);
});

unwrapExports(canvas);
var canvas_1 = canvas.RoughCanvasAsync;
var canvas_2 = canvas.RoughCanvas;

const chuckCloseCanvasTransform = (canvas, context, size, pixelSize = 10) => {
  const [baseWidth, baseHeight] = size;
  const height = baseHeight + (baseHeight % pixelSize === 0 ? 0 : pixelSize - baseHeight % pixelSize);
  const width = baseWidth + (baseWidth % pixelSize === 0 ? 0 : pixelSize - baseWidth % pixelSize);
  const rgbStep = 4 * pixelSize;
  const imageData = context.getImageData(0, 0, width, height);
  const rgbaArray = [];
  const imageArray = imageData.data;
  const rgbWidth = width * 4;
  const halfPixelSize = pixelSize / 2;

  for (let i = 0; i < imageArray.length; i += rgbStep) {
    let pixelPoint = {};

    if (pixelSize === 1) {
      pixelPoint = {
        r: imageArray[i],
        g: imageArray[i + 1],
        b: imageArray[i + 2],
        a: imageArray[i + 3],
        x: i / 4 % width,
        y: Math.floor(i / 4 / width)
      };
    } else {
      const rgbHash = {};
      let totalHash = 0;

      for (let p = 0; p < pixelSize * 4; p += pixelSize * 4) {
        for (let q = 0; q < pixelSize * rgbWidth; q += rgbWidth) {
          if (imageArray[p + i + q + 3] !== -1) {
            const hashVal = `rgba(${imageArray[p + i + q]},${imageArray[p + i + q + 1]},${imageArray[p + i + q + 2]},${imageArray[p + i + q + 3]})`;
            rgbHash[hashVal] = rgbHash[hashVal] ? rgbHash[hashVal] + 1 : 1;
            totalHash += 1;
          }
        }
      }

      pixelPoint = {
        rgbEntries: Object.entries(rgbHash).sort((a, b) => b[1] - a[1]),
        totalEntries: totalHash,
        x: i / 4 % width,
        y: Math.floor(i / 4 / width),
        rmod: pixelSize
      };
    }

    rgbaArray.push(pixelPoint);

    if (pixelSize !== 1 && (i + rgbStep) % rgbWidth === 0) {
      i += rgbWidth * (pixelSize - 1);
    }
  }

  const scale = 1;
  const r = scale / 2;
  context.clearRect(0, 0, width, height);
  const circleArc = 2 * Math.PI;
  rgbaArray.forEach(point => {
    let currentR = r * pixelSize;
    const rStep = currentR / point.totalEntries;
    const baseX = point.x * scale + halfPixelSize;
    const baseY = point.y * scale + halfPixelSize;
    point.rgbEntries.forEach(e => {
      context.fillStyle = e[0];
      context.beginPath();
      context.arc(baseX, baseY, currentR, 0, circleArc);
      context.fill();
      currentR -= e[1] * rStep;
    });
  });
};

const RoughCanvas = canvas_2;

const drawCanvas = ({
  props,
  canvasDrawing
}) => {
  if (props.frontCanvas && props.backCanvas) {
    const {
      frontCanvas,
      margin,
      width,
      height,
      position,
      canvasPostProcess
    } = props;
    const devicePixelRatio = window.devicePixelRatio || 1;
    const size = [width + margin.left + margin.right, height + margin.top + margin.bottom];
    const context = frontCanvas.getContext('2d');
    context.setTransform(devicePixelRatio, 0, 0, devicePixelRatio, margin.left, margin.top);
    context.clearRect(-margin.left, -margin.top, size[0], size[1]);
    let rc;
    canvasDrawing.forEach(piece => {
      const style = piece.styleFn ? piece.styleFn({ ...piece.d,
        ...piece.d.data
      }, piece.i) || {} : {
        fill: 'black',
        stroke: 'black',
        opacity: 1,
        fillOpacity: 1,
        strokeOpacity: 1,
        strokeWidth: 1
      };
      const fill = style.fill ? style.fill : 'black';
      const stroke = style.stroke ? style.stroke : 'black';
      context.setTransform(devicePixelRatio, 0, 0, devicePixelRatio, margin.left * devicePixelRatio, margin.top * devicePixelRatio);
      context.translate(...position);
      context.translate(piece.tx, piece.ty);
      context.fillStyle = fill;
      context.strokeStyle = stroke;
      context.lineWidth = style.strokeWidth ? style.strokeWidth : 0;
      let rcSettings = {};
      const renderObject = piece.markProps.renderMode || piece.renderFn && piece.renderFn({ ...piece.d,
        ...piece.d.data
      }, piece.i);
      const actualRenderMode = renderObject && renderObject.renderMode || renderObject;

      if (actualRenderMode) {
        rc = rc || new RoughCanvas(frontCanvas);
        const rcExtension = typeof renderObject === 'object' && renderObject || {};
        rcSettings = {
          fill,
          stroke,
          strokeWidth: context.lineWidth,
          ...rcExtension
        };
      }

      if (piece.markProps.markType === 'circle' || piece.markProps.markType === 'rect' && piece.markProps.rx > 0) {
        let vizX = 0,
            vizY = 0,
            r = piece.markProps.r;

        if (piece.markProps.width) {
          const halfWidth = piece.markProps.width / 2;
          vizX = piece.markProps.x + halfWidth;
          vizY = piece.markProps.y + halfWidth;
          r = halfWidth;
        }

        if (actualRenderMode === 'sketchy') {
          if (context.globalAlpha !== 0) rc.circle(vizX, vizY, r, rcSettings);
        } else {
          context.beginPath();
          context.arc(vizX, vizY, r, 0, 2 * Math.PI);
          context.globalAlpha = style.fillOpacity || style.opacity || 1;
          if (style.fill && style.fill !== 'none' && context.globalAlpha !== 0) context.fill();
          context.globalAlpha = style.strokeOpacity || style.opacity || 1;
          if (style.stroke && style.stroke !== 'none' && context.globalAlpha !== 0) context.stroke();
        }
      } else if (piece.markProps.markType === 'rect') {
        if (actualRenderMode === 'sketchy') {
          context.globalAlpha = style.opacity || 1;
          if (context.globalAlpha !== 0) rc.rectangle(piece.markProps.x, piece.markProps.y, piece.markProps.width, piece.markProps.height, rcSettings);
        } else {
          context.globalAlpha = style.fillOpacity || style.opacity || 1;
          if (style.fill && style.fill !== 'none' && context.globalAlpha !== 0) context.fillRect(piece.markProps.x, piece.markProps.y, piece.markProps.width, piece.markProps.height);
          context.globalAlpha = style.strokeOpacity || style.opacity || 1;
          if (style.stroke && style.stroke !== 'none' && context.globalAlpha !== 0) context.strokeRect(piece.markProps.x, piece.markProps.y, piece.markProps.width, piece.markProps.height);
        }
      } else if (piece.markProps.markType === 'path') {
        if (actualRenderMode === 'sketchy') {
          context.globalAlpha = style.opacity || 1;
          rc.path(piece.markProps.d, rcSettings);
        } else {
          const p = new Path2D(piece.markProps.d);
          context.globalAlpha = style.strokeOpacity || style.opacity || 1;
          if (style.stroke && style.stroke !== 'none' && context.globalAlpha !== 0) context.stroke(p);
          context.globalAlpha = style.fillOpacity || style.opacity || 1;
          if (style.fill && style.fill !== 'none' && context.globalAlpha !== 0) context.fill(p);
        }
      } else {
        console.error('CURRENTLY UNSUPPORTED MARKTYPE FOR CANVAS RENDERING');
      }
    });
    context.setTransform(1, 0, 0, 1, 0, 0);
    context.globalAlpha = 1;

    if (canvasPostProcess === 'chuckClose') {
      chuckCloseCanvasTransform(canvasContext, context, size);
    } else if (typeof canvasPostProcess === 'function') {
      canvasPostProcess(canvasContext, context, size);
    }
  }
};

const VisualizationLayer = props => {
  const {
    matte,
    matteClip,
    frameKey,
    margin,
    title,
    ariaTitle,
    children,
    canvasPipeline
  } = props;
  React$1.useEffect(() => {
    drawCanvas({
      props,
      canvasDrawing: canvasPipeline
    });
  });

  const _title = title && ariaTitle || props.title ? title.props && typeof title.props.children === 'string' ? `titled ${title.props.children}` : 'with a complex title' : 'with no title';

  const ariaLabel = `Visualization ${_title}. Use arrow keys to navigate elements.`;
  return children && children.length > 0 && React$1__default.createElement("g", {
    className: "data-visualization",
    key: "visualization-clip-path",
    "aria-label": ariaLabel,
    role: "group",
    clipPath: matteClip && matte ? `url(#matte-clip${frameKey})` : undefined,
    transform: `translate(${margin.left},${margin.top})`
  }, children, matte);
};

VisualizationLayer.defaultProps = {
  position: [0, 0],
  margin: {
    left: 0,
    top: 0,
    right: 0,
    bottom: 0
  },
  matteClip: true
};
VisualizationLayer.propTypes = {
  frameKey: propTypes.string,
  xScale: propTypes.func,
  yScale: propTypes.func,
  margin: propTypes.object,
  size: propTypes.array,
  position: propTypes.array,
  canvasPostProcess: propTypes.oneOfType([propTypes.string, propTypes.func]),
  title: propTypes.oneOfType([propTypes.object, propTypes.string]),
  ariaTitle: propTypes.string,
  matte: propTypes.node,
  matteClip: propTypes.bool,
  frontCanvas: propTypes.object,
  backCanvas: propTypes.object,
  voronoiHover: propTypes.func,
  canvasPipeline: propTypes.array
};

const renderCanvas = ({
  props,
  canvasMap,
  overlayRegions,
  interactionContext
}) => {
  if (interactionContext === null || !overlayRegions) return;
  const {
    svgSize,
    margin
  } = props;
  canvasMap.clear();
  interactionContext = interactionContext.getContext('2d');
  interactionContext.imageSmoothingEnabled = false;
  interactionContext.setTransform(1, 0, 0, 1, margin.left, margin.top);
  interactionContext.clearRect(-margin.left, -margin.top, svgSize[0], svgSize[1]);
  interactionContext.lineWidth = 1;
  overlayRegions.forEach((overlay, oi) => {
    const interactionRGBA = `rgba(${Math.floor(Math.random() * 255)},${Math.floor(Math.random() * 255)},${Math.floor(Math.random() * 255)},255)`;
    canvasMap.set(interactionRGBA, oi);
    interactionContext.fillStyle = interactionRGBA;
    interactionContext.strokeStyle = interactionRGBA;
    const p = new Path2D(overlay.props.d);
    interactionContext.stroke(p);
    interactionContext.fill(p);
  });
};

function constant$a(x) {
  return function() {
    return x;
  };
}

function x$4(d) {
  return d[0];
}

function y$4(d) {
  return d[1];
}

function RedBlackTree() {
  this._ = null; // root node
}

function RedBlackNode(node) {
  node.U = // parent node
  node.C = // color - true for red, false for black
  node.L = // left node
  node.R = // right node
  node.P = // previous node
  node.N = null; // next node
}

RedBlackTree.prototype = {
  constructor: RedBlackTree,

  insert: function(after, node) {
    var parent, grandpa, uncle;

    if (after) {
      node.P = after;
      node.N = after.N;
      if (after.N) after.N.P = node;
      after.N = node;
      if (after.R) {
        after = after.R;
        while (after.L) after = after.L;
        after.L = node;
      } else {
        after.R = node;
      }
      parent = after;
    } else if (this._) {
      after = RedBlackFirst(this._);
      node.P = null;
      node.N = after;
      after.P = after.L = node;
      parent = after;
    } else {
      node.P = node.N = null;
      this._ = node;
      parent = null;
    }
    node.L = node.R = null;
    node.U = parent;
    node.C = true;

    after = node;
    while (parent && parent.C) {
      grandpa = parent.U;
      if (parent === grandpa.L) {
        uncle = grandpa.R;
        if (uncle && uncle.C) {
          parent.C = uncle.C = false;
          grandpa.C = true;
          after = grandpa;
        } else {
          if (after === parent.R) {
            RedBlackRotateLeft(this, parent);
            after = parent;
            parent = after.U;
          }
          parent.C = false;
          grandpa.C = true;
          RedBlackRotateRight(this, grandpa);
        }
      } else {
        uncle = grandpa.L;
        if (uncle && uncle.C) {
          parent.C = uncle.C = false;
          grandpa.C = true;
          after = grandpa;
        } else {
          if (after === parent.L) {
            RedBlackRotateRight(this, parent);
            after = parent;
            parent = after.U;
          }
          parent.C = false;
          grandpa.C = true;
          RedBlackRotateLeft(this, grandpa);
        }
      }
      parent = after.U;
    }
    this._.C = false;
  },

  remove: function(node) {
    if (node.N) node.N.P = node.P;
    if (node.P) node.P.N = node.N;
    node.N = node.P = null;

    var parent = node.U,
        sibling,
        left = node.L,
        right = node.R,
        next,
        red;

    if (!left) next = right;
    else if (!right) next = left;
    else next = RedBlackFirst(right);

    if (parent) {
      if (parent.L === node) parent.L = next;
      else parent.R = next;
    } else {
      this._ = next;
    }

    if (left && right) {
      red = next.C;
      next.C = node.C;
      next.L = left;
      left.U = next;
      if (next !== right) {
        parent = next.U;
        next.U = node.U;
        node = next.R;
        parent.L = node;
        next.R = right;
        right.U = next;
      } else {
        next.U = parent;
        parent = next;
        node = next.R;
      }
    } else {
      red = node.C;
      node = next;
    }

    if (node) node.U = parent;
    if (red) return;
    if (node && node.C) { node.C = false; return; }

    do {
      if (node === this._) break;
      if (node === parent.L) {
        sibling = parent.R;
        if (sibling.C) {
          sibling.C = false;
          parent.C = true;
          RedBlackRotateLeft(this, parent);
          sibling = parent.R;
        }
        if ((sibling.L && sibling.L.C)
            || (sibling.R && sibling.R.C)) {
          if (!sibling.R || !sibling.R.C) {
            sibling.L.C = false;
            sibling.C = true;
            RedBlackRotateRight(this, sibling);
            sibling = parent.R;
          }
          sibling.C = parent.C;
          parent.C = sibling.R.C = false;
          RedBlackRotateLeft(this, parent);
          node = this._;
          break;
        }
      } else {
        sibling = parent.L;
        if (sibling.C) {
          sibling.C = false;
          parent.C = true;
          RedBlackRotateRight(this, parent);
          sibling = parent.L;
        }
        if ((sibling.L && sibling.L.C)
          || (sibling.R && sibling.R.C)) {
          if (!sibling.L || !sibling.L.C) {
            sibling.R.C = false;
            sibling.C = true;
            RedBlackRotateLeft(this, sibling);
            sibling = parent.L;
          }
          sibling.C = parent.C;
          parent.C = sibling.L.C = false;
          RedBlackRotateRight(this, parent);
          node = this._;
          break;
        }
      }
      sibling.C = true;
      node = parent;
      parent = parent.U;
    } while (!node.C);

    if (node) node.C = false;
  }
};

function RedBlackRotateLeft(tree, node) {
  var p = node,
      q = node.R,
      parent = p.U;

  if (parent) {
    if (parent.L === p) parent.L = q;
    else parent.R = q;
  } else {
    tree._ = q;
  }

  q.U = parent;
  p.U = q;
  p.R = q.L;
  if (p.R) p.R.U = p;
  q.L = p;
}

function RedBlackRotateRight(tree, node) {
  var p = node,
      q = node.L,
      parent = p.U;

  if (parent) {
    if (parent.L === p) parent.L = q;
    else parent.R = q;
  } else {
    tree._ = q;
  }

  q.U = parent;
  p.U = q;
  p.L = q.R;
  if (p.L) p.L.U = p;
  q.R = p;
}

function RedBlackFirst(node) {
  while (node.L) node = node.L;
  return node;
}

function createEdge(left, right, v0, v1) {
  var edge = [null, null],
      index = edges.push(edge) - 1;
  edge.left = left;
  edge.right = right;
  if (v0) setEdgeEnd(edge, left, right, v0);
  if (v1) setEdgeEnd(edge, right, left, v1);
  cells[left.HospitalFacilities].halfedges.push(index);
  cells[right.HospitalFacilities].halfedges.push(index);
  return edge;
}

function createBorderEdge(left, v0, v1) {
  var edge = [v0, v1];
  edge.left = left;
  return edge;
}

function setEdgeEnd(edge, left, right, vertex) {
  if (!edge[0] && !edge[1]) {
    edge[0] = vertex;
    edge.left = left;
    edge.right = right;
  } else if (edge.left === right) {
    edge[1] = vertex;
  } else {
    edge[0] = vertex;
  }
}

// Liang–Barsky line clipping.
function clipEdge(edge, x0, y0, x1, y1) {
  var a = edge[0],
      b = edge[1],
      ax = a[0],
      ay = a[1],
      bx = b[0],
      by = b[1],
      t0 = 0,
      t1 = 1,
      dx = bx - ax,
      dy = by - ay,
      r;

  r = x0 - ax;
  if (!dx && r > 0) return;
  r /= dx;
  if (dx < 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  } else if (dx > 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  }

  r = x1 - ax;
  if (!dx && r < 0) return;
  r /= dx;
  if (dx < 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  } else if (dx > 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  }

  r = y0 - ay;
  if (!dy && r > 0) return;
  r /= dy;
  if (dy < 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  } else if (dy > 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  }

  r = y1 - ay;
  if (!dy && r < 0) return;
  r /= dy;
  if (dy < 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  } else if (dy > 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  }

  if (!(t0 > 0) && !(t1 < 1)) return true; // TODO Better check?

  if (t0 > 0) edge[0] = [ax + t0 * dx, ay + t0 * dy];
  if (t1 < 1) edge[1] = [ax + t1 * dx, ay + t1 * dy];
  return true;
}

function connectEdge(edge, x0, y0, x1, y1) {
  var v1 = edge[1];
  if (v1) return true;

  var v0 = edge[0],
      left = edge.left,
      right = edge.right,
      lx = left[0],
      ly = left[1],
      rx = right[0],
      ry = right[1],
      fx = (lx + rx) / 2,
      fy = (ly + ry) / 2,
      fm,
      fb;

  if (ry === ly) {
    if (fx < x0 || fx >= x1) return;
    if (lx > rx) {
      if (!v0) v0 = [fx, y0];
      else if (v0[1] >= y1) return;
      v1 = [fx, y1];
    } else {
      if (!v0) v0 = [fx, y1];
      else if (v0[1] < y0) return;
      v1 = [fx, y0];
    }
  } else {
    fm = (lx - rx) / (ry - ly);
    fb = fy - fm * fx;
    if (fm < -1 || fm > 1) {
      if (lx > rx) {
        if (!v0) v0 = [(y0 - fb) / fm, y0];
        else if (v0[1] >= y1) return;
        v1 = [(y1 - fb) / fm, y1];
      } else {
        if (!v0) v0 = [(y1 - fb) / fm, y1];
        else if (v0[1] < y0) return;
        v1 = [(y0 - fb) / fm, y0];
      }
    } else {
      if (ly < ry) {
        if (!v0) v0 = [x0, fm * x0 + fb];
        else if (v0[0] >= x1) return;
        v1 = [x1, fm * x1 + fb];
      } else {
        if (!v0) v0 = [x1, fm * x1 + fb];
        else if (v0[0] < x0) return;
        v1 = [x0, fm * x0 + fb];
      }
    }
  }

  edge[0] = v0;
  edge[1] = v1;
  return true;
}

function clipEdges(x0, y0, x1, y1) {
  var i = edges.length,
      edge;

  while (i--) {
    if (!connectEdge(edge = edges[i], x0, y0, x1, y1)
        || !clipEdge(edge, x0, y0, x1, y1)
        || !(Math.abs(edge[0][0] - edge[1][0]) > epsilon$4
            || Math.abs(edge[0][1] - edge[1][1]) > epsilon$4)) {
      delete edges[i];
    }
  }
}

function createCell(site) {
  return cells[site.HospitalFacilities] = {
    site: site,
    halfedges: []
  };
}

function cellHalfedgeAngle(cell, edge) {
  var site = cell.site,
      va = edge.left,
      vb = edge.right;
  if (site === vb) vb = va, va = site;
  if (vb) return Math.atan2(vb[1] - va[1], vb[0] - va[0]);
  if (site === va) va = edge[1], vb = edge[0];
  else va = edge[0], vb = edge[1];
  return Math.atan2(va[0] - vb[0], vb[1] - va[1]);
}

function cellHalfedgeStart(cell, edge) {
  return edge[+(edge.left !== cell.site)];
}

function cellHalfedgeEnd(cell, edge) {
  return edge[+(edge.left === cell.site)];
}

function sortCellHalfedges() {
  for (var i = 0, n = cells.length, cell, halfedges, j, m; i < n; ++i) {
    if ((cell = cells[i]) && (m = (halfedges = cell.halfedges).length)) {
      var index = new Array(m),
          array = new Array(m);
      for (j = 0; j < m; ++j) index[j] = j, array[j] = cellHalfedgeAngle(cell, edges[halfedges[j]]);
      index.sort(function(i, j) { return array[j] - array[i]; });
      for (j = 0; j < m; ++j) array[j] = halfedges[index[j]];
      for (j = 0; j < m; ++j) halfedges[j] = array[j];
    }
  }
}

function clipCells(x0, y0, x1, y1) {
  var nCells = cells.length,
      iCell,
      cell,
      site,
      iHalfedge,
      halfedges,
      nHalfedges,
      start,
      startX,
      startY,
      end,
      endX,
      endY,
      cover = true;

  for (iCell = 0; iCell < nCells; ++iCell) {
    if (cell = cells[iCell]) {
      site = cell.site;
      halfedges = cell.halfedges;
      iHalfedge = halfedges.length;

      // Remove any dangling clipped edges.
      while (iHalfedge--) {
        if (!edges[halfedges[iHalfedge]]) {
          halfedges.splice(iHalfedge, 1);
        }
      }

      // Insert any border edges as necessary.
      iHalfedge = 0, nHalfedges = halfedges.length;
      while (iHalfedge < nHalfedges) {
        end = cellHalfedgeEnd(cell, edges[halfedges[iHalfedge]]), endX = end[0], endY = end[1];
        start = cellHalfedgeStart(cell, edges[halfedges[++iHalfedge % nHalfedges]]), startX = start[0], startY = start[1];
        if (Math.abs(endX - startX) > epsilon$4 || Math.abs(endY - startY) > epsilon$4) {
          halfedges.splice(iHalfedge, 0, edges.push(createBorderEdge(site, end,
              Math.abs(endX - x0) < epsilon$4 && y1 - endY > epsilon$4 ? [x0, Math.abs(startX - x0) < epsilon$4 ? startY : y1]
              : Math.abs(endY - y1) < epsilon$4 && x1 - endX > epsilon$4 ? [Math.abs(startY - y1) < epsilon$4 ? startX : x1, y1]
              : Math.abs(endX - x1) < epsilon$4 && endY - y0 > epsilon$4 ? [x1, Math.abs(startX - x1) < epsilon$4 ? startY : y0]
              : Math.abs(endY - y0) < epsilon$4 && endX - x0 > epsilon$4 ? [Math.abs(startY - y0) < epsilon$4 ? startX : x0, y0]
              : null)) - 1);
          ++nHalfedges;
        }
      }

      if (nHalfedges) cover = false;
    }
  }

  // If there weren’t any edges, have the closest site cover the extent.
  // It doesn’t matter which corner of the extent we measure!
  if (cover) {
    var dx, dy, d2, dc = Infinity;

    for (iCell = 0, cover = null; iCell < nCells; ++iCell) {
      if (cell = cells[iCell]) {
        site = cell.site;
        dx = site[0] - x0;
        dy = site[1] - y0;
        d2 = dx * dx + dy * dy;
        if (d2 < dc) dc = d2, cover = cell;
      }
    }

    if (cover) {
      var v00 = [x0, y0], v01 = [x0, y1], v11 = [x1, y1], v10 = [x1, y0];
      cover.halfedges.push(
        edges.push(createBorderEdge(site = cover.site, v00, v01)) - 1,
        edges.push(createBorderEdge(site, v01, v11)) - 1,
        edges.push(createBorderEdge(site, v11, v10)) - 1,
        edges.push(createBorderEdge(site, v10, v00)) - 1
      );
    }
  }

  // Lastly delete any cells with no edges; these were entirely clipped.
  for (iCell = 0; iCell < nCells; ++iCell) {
    if (cell = cells[iCell]) {
      if (!cell.halfedges.length) {
        delete cells[iCell];
      }
    }
  }
}

var circlePool = [];

var firstCircle;

function Circle() {
  RedBlackNode(this);
  this.x =
  this.y =
  this.arc =
  this.site =
  this.cy = null;
}

function attachCircle(arc) {
  var lArc = arc.P,
      rArc = arc.N;

  if (!lArc || !rArc) return;

  var lSite = lArc.site,
      cSite = arc.site,
      rSite = rArc.site;

  if (lSite === rSite) return;

  var bx = cSite[0],
      by = cSite[1],
      ax = lSite[0] - bx,
      ay = lSite[1] - by,
      cx = rSite[0] - bx,
      cy = rSite[1] - by;

  var d = 2 * (ax * cy - ay * cx);
  if (d >= -epsilon2) return;

  var ha = ax * ax + ay * ay,
      hc = cx * cx + cy * cy,
      x = (cy * ha - ay * hc) / d,
      y = (ax * hc - cx * ha) / d;

  var circle = circlePool.pop() || new Circle;
  circle.arc = arc;
  circle.site = cSite;
  circle.x = x + bx;
  circle.y = (circle.cy = y + by) + Math.sqrt(x * x + y * y); // y bottom

  arc.circle = circle;

  var before = null,
      node = circles._;

  while (node) {
    if (circle.y < node.y || (circle.y === node.y && circle.x <= node.x)) {
      if (node.L) node = node.L;
      else { before = node.P; break; }
    } else {
      if (node.R) node = node.R;
      else { before = node; break; }
    }
  }

  circles.insert(before, circle);
  if (!before) firstCircle = circle;
}

function detachCircle(arc) {
  var circle = arc.circle;
  if (circle) {
    if (!circle.P) firstCircle = circle.N;
    circles.remove(circle);
    circlePool.push(circle);
    RedBlackNode(circle);
    arc.circle = null;
  }
}

var beachPool = [];

function Beach() {
  RedBlackNode(this);
  this.edge =
  this.site =
  this.circle = null;
}

function createBeach(site) {
  var beach = beachPool.pop() || new Beach;
  beach.site = site;
  return beach;
}

function detachBeach(beach) {
  detachCircle(beach);
  beaches.remove(beach);
  beachPool.push(beach);
  RedBlackNode(beach);
}

function removeBeach(beach) {
  var circle = beach.circle,
      x = circle.x,
      y = circle.cy,
      vertex = [x, y],
      previous = beach.P,
      next = beach.N,
      disappearing = [beach];

  detachBeach(beach);

  var lArc = previous;
  while (lArc.circle
      && Math.abs(x - lArc.circle.x) < epsilon$4
      && Math.abs(y - lArc.circle.cy) < epsilon$4) {
    previous = lArc.P;
    disappearing.unshift(lArc);
    detachBeach(lArc);
    lArc = previous;
  }

  disappearing.unshift(lArc);
  detachCircle(lArc);

  var rArc = next;
  while (rArc.circle
      && Math.abs(x - rArc.circle.x) < epsilon$4
      && Math.abs(y - rArc.circle.cy) < epsilon$4) {
    next = rArc.N;
    disappearing.push(rArc);
    detachBeach(rArc);
    rArc = next;
  }

  disappearing.push(rArc);
  detachCircle(rArc);

  var nArcs = disappearing.length,
      iArc;
  for (iArc = 1; iArc < nArcs; ++iArc) {
    rArc = disappearing[iArc];
    lArc = disappearing[iArc - 1];
    setEdgeEnd(rArc.edge, lArc.site, rArc.site, vertex);
  }

  lArc = disappearing[0];
  rArc = disappearing[nArcs - 1];
  rArc.edge = createEdge(lArc.site, rArc.site, null, vertex);

  attachCircle(lArc);
  attachCircle(rArc);
}

function addBeach(site) {
  var x = site[0],
      directrix = site[1],
      lArc,
      rArc,
      dxl,
      dxr,
      node = beaches._;

  while (node) {
    dxl = leftBreakPoint(node, directrix) - x;
    if (dxl > epsilon$4) node = node.L; else {
      dxr = x - rightBreakPoint(node, directrix);
      if (dxr > epsilon$4) {
        if (!node.R) {
          lArc = node;
          break;
        }
        node = node.R;
      } else {
        if (dxl > -epsilon$4) {
          lArc = node.P;
          rArc = node;
        } else if (dxr > -epsilon$4) {
          lArc = node;
          rArc = node.N;
        } else {
          lArc = rArc = node;
        }
        break;
      }
    }
  }

  createCell(site);
  var newArc = createBeach(site);
  beaches.insert(lArc, newArc);

  if (!lArc && !rArc) return;

  if (lArc === rArc) {
    detachCircle(lArc);
    rArc = createBeach(lArc.site);
    beaches.insert(newArc, rArc);
    newArc.edge = rArc.edge = createEdge(lArc.site, newArc.site);
    attachCircle(lArc);
    attachCircle(rArc);
    return;
  }

  if (!rArc) { // && lArc
    newArc.edge = createEdge(lArc.site, newArc.site);
    return;
  }

  // else lArc !== rArc
  detachCircle(lArc);
  detachCircle(rArc);

  var lSite = lArc.site,
      ax = lSite[0],
      ay = lSite[1],
      bx = site[0] - ax,
      by = site[1] - ay,
      rSite = rArc.site,
      cx = rSite[0] - ax,
      cy = rSite[1] - ay,
      d = 2 * (bx * cy - by * cx),
      hb = bx * bx + by * by,
      hc = cx * cx + cy * cy,
      vertex = [(cy * hb - by * hc) / d + ax, (bx * hc - cx * hb) / d + ay];

  setEdgeEnd(rArc.edge, lSite, rSite, vertex);
  newArc.edge = createEdge(lSite, site, null, vertex);
  rArc.edge = createEdge(site, rSite, null, vertex);
  attachCircle(lArc);
  attachCircle(rArc);
}

function leftBreakPoint(arc, directrix) {
  var site = arc.site,
      rfocx = site[0],
      rfocy = site[1],
      pby2 = rfocy - directrix;

  if (!pby2) return rfocx;

  var lArc = arc.P;
  if (!lArc) return -Infinity;

  site = lArc.site;
  var lfocx = site[0],
      lfocy = site[1],
      plby2 = lfocy - directrix;

  if (!plby2) return lfocx;

  var hl = lfocx - rfocx,
      aby2 = 1 / pby2 - 1 / plby2,
      b = hl / plby2;

  if (aby2) return (-b + Math.sqrt(b * b - 2 * aby2 * (hl * hl / (-2 * plby2) - lfocy + plby2 / 2 + rfocy - pby2 / 2))) / aby2 + rfocx;

  return (rfocx + lfocx) / 2;
}

function rightBreakPoint(arc, directrix) {
  var rArc = arc.N;
  if (rArc) return leftBreakPoint(rArc, directrix);
  var site = arc.site;
  return site[1] === directrix ? site[0] : Infinity;
}

var epsilon$4 = 1e-6;
var epsilon2 = 1e-12;
var beaches;
var cells;
var circles;
var edges;

function triangleArea(a, b, c) {
  return (a[0] - c[0]) * (b[1] - a[1]) - (a[0] - b[0]) * (c[1] - a[1]);
}

function lexicographic(a, b) {
  return b[1] - a[1]
      || b[0] - a[0];
}

function Diagram(sites, extent) {
  var site = sites.sort(lexicographic).pop(),
      x,
      y,
      circle;

  edges = [];
  cells = new Array(sites.length);
  beaches = new RedBlackTree;
  circles = new RedBlackTree;

  while (true) {
    circle = firstCircle;
    if (site && (!circle || site[1] < circle.y || (site[1] === circle.y && site[0] < circle.x))) {
      if (site[0] !== x || site[1] !== y) {
        addBeach(site);
        x = site[0], y = site[1];
      }
      site = sites.pop();
    } else if (circle) {
      removeBeach(circle.arc);
    } else {
      break;
    }
  }

  sortCellHalfedges();

  if (extent) {
    var x0 = +extent[0][0],
        y0 = +extent[0][1],
        x1 = +extent[1][0],
        y1 = +extent[1][1];
    clipEdges(x0, y0, x1, y1);
    clipCells(x0, y0, x1, y1);
  }

  this.edges = edges;
  this.cells = cells;

  beaches =
  circles =
  edges =
  cells = null;
}

Diagram.prototype = {
  constructor: Diagram,

  polygons: function() {
    var edges = this.edges;

    return this.cells.map(function(cell) {
      var polygon = cell.halfedges.map(function(i) { return cellHalfedgeStart(cell, edges[i]); });
      polygon.data = cell.site.data;
      return polygon;
    });
  },

  triangles: function() {
    var triangles = [],
        edges = this.edges;

    this.cells.forEach(function(cell, i) {
      if (!(m = (halfedges = cell.halfedges).length)) return;
      var site = cell.site,
          halfedges,
          j = -1,
          m,
          s0,
          e1 = edges[halfedges[m - 1]],
          s1 = e1.left === site ? e1.right : e1.left;

      while (++j < m) {
        s0 = s1;
        e1 = edges[halfedges[j]];
        s1 = e1.left === site ? e1.right : e1.left;
        if (s0 && s1 && i < s0.HospitalFacilities && i < s1.HospitalFacilities && triangleArea(site, s0, s1) < 0) {
          triangles.push([site.data, s0.data, s1.data]);
        }
      }
    });

    return triangles;
  },

  links: function() {
    return this.edges.filter(function(edge) {
      return edge.right;
    }).map(function(edge) {
      return {
        source: edge.left.data,
        target: edge.right.data
      };
    });
  },

  find: function(x, y, radius) {
    var that = this, i0, i1 = that._found || 0, n = that.cells.length, cell;

    // Use the previously-found cell, or start with an arbitrary one.
    while (!(cell = that.cells[i1])) if (++i1 >= n) return null;
    var dx = x - cell.site[0], dy = y - cell.site[1], d2 = dx * dx + dy * dy;

    // Traverse the half-edges to find a closer cell, if any.
    do {
      cell = that.cells[i0 = i1], i1 = null;
      cell.halfedges.forEach(function(e) {
        var edge = that.edges[e], v = edge.left;
        if ((v === cell.site || !v) && !(v = edge.right)) return;
        var vx = x - v[0], vy = y - v[1], v2 = vx * vx + vy * vy;
        if (v2 < d2) d2 = v2, i1 = v.HospitalFacilities;
      });
    } while (i1 !== null);

    that._found = i0;

    return radius == null || d2 <= radius * radius ? cell.site : null;
  }
};

function voronoi() {
  var x = x$4,
      y = y$4,
      extent = null;

  function voronoi(data) {
    return new Diagram(data.map(function(d, i) {
      var s = [Math.round(x(d, i, data) / epsilon$4) * epsilon$4, Math.round(y(d, i, data) / epsilon$4) * epsilon$4];
      s.index = i;
      s.data = d;
      return s;
    }), extent);
  }

  voronoi.polygons = function(data) {
    return voronoi(data).polygons();
  };

  voronoi.links = function(data) {
    return voronoi(data).links();
  };

  voronoi.triangles = function(data) {
    return voronoi(data).triangles();
  };

  voronoi.x = function(_) {
    return arguments.length ? (x = typeof _ === "function" ? _ : constant$a(+_), voronoi) : x;
  };

  voronoi.y = function(_) {
    return arguments.length ? (y = typeof _ === "function" ? _ : constant$a(+_), voronoi) : y;
  };

  voronoi.extent = function(_) {
    return arguments.length ? (extent = _ == null ? null : [[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]], voronoi) : extent && [[extent[0][0], extent[0][1]], [extent[1][0], extent[1][1]]];
  };

  voronoi.size = function(_) {
    return arguments.length ? (extent = _ == null ? null : [[0, 0], [+_[0], +_[1]]], voronoi) : extent && [extent[1][0] - extent[0][0], extent[1][1] - extent[0][1]];
  };

  return voronoi;
}

const constructDataObject = (d, props) => {
  if (d === undefined) return d;
  const {
    points
  } = props;
  return d && d.data ? {
    points,
    ...d.data,
    ...d
  } : {
    points,
    ...d
  };
};

const changeVoronoi = ({
  d,
  customHoverTypes,
  props
}) => {
  const {
    customHoverBehavior,
    voronoiHover
  } = props;
  const dataObject = constructDataObject(d, props);
  if (customHoverBehavior) customHoverBehavior(dataObject);

  if (!d) {
    voronoiHover(null);
  } else if (customHoverTypes === true) {
    const vorD = Object.assign({}, dataObject);
    vorD.type = vorD.type === 'column-hover' ? 'column-hover' : 'frame-hover';
    voronoiHover(vorD);
  } else if (customHoverTypes) {
    const arrayWrappedHoverTypes = Array.isArray(customHoverTypes) ? customHoverTypes : [customHoverTypes];
    const mappedHoverTypes = arrayWrappedHoverTypes.map(c => {
      const finalC = typeof c === 'function' ? c(dataObject) : c;
      if (!finalC) return undefined;
      return Object.assign({}, dataObject, finalC);
    }).filter(d => d);
    voronoiHover(mappedHoverTypes);
  }
};

const clickVoronoi = (d, props) => {
  const dataObject = constructDataObject(d, props);
  if (props.customClickBehavior) props.customClickBehavior(dataObject);
};

const doubleclickVoronoi = (d, props) => {
  const dataObject = constructDataObject(d, props);
  if (props.customDoubleClickBehavior) props.customDoubleClickBehavior(dataObject);
};

const calculateOverlay = props => {
  const {
    xScale,
    yScale,
    data,
    size,
    overlay,
    interactionOverflow = {
      top: 0,
      bottom: 0,
      left: 0,
      right: 0
    },
    customClickBehavior,
    customDoubleClickBehavior,
    hoverAnnotation,
    voronoiHover
  } = props;
  let voronoiPaths = [];
  const pointerStyle = customClickBehavior || customDoubleClickBehavior ? {
    cursor: 'pointer'
  } : {};

  if (data && hoverAnnotation && !overlay) {
    const voronoiDataset = [];
    const voronoiUniqueHash = {};
    data.forEach(d => {
      const xValue = Math.floor(xScale(d.x));
      const yValue = Math.floor(yScale(d.y));

      if (xValue >= 0 && xValue <= size[0] && yValue >= 0 && yValue <= size[1] && xValue !== undefined && yValue !== undefined && isNaN(xValue) === false && isNaN(yValue) === false) {
        const pointKey = `${xValue},${yValue}`;

        if (!voronoiUniqueHash[pointKey]) {
          const voronoiPoint = { ...d,
            points: data,
            coincidentPoints: [d],
            voronoiX: xValue,
            voronoiY: yValue
          };
          voronoiDataset.push(voronoiPoint);
          voronoiUniqueHash[pointKey] = voronoiPoint;
        } else voronoiUniqueHash[pointKey].coincidentPoints.push(d);
      }
    });
    const voronoiXExtent = extent(voronoiDataset.map(d => d.voronoiX));
    const voronoiYExtent = extent(voronoiDataset.map(d => d.voronoiY));
    const voronoiExtent = [[Math.min(voronoiXExtent[0], -interactionOverflow.left), Math.min(voronoiYExtent[0], -interactionOverflow.top)], [Math.max(voronoiXExtent[1], size[0] + interactionOverflow.right), Math.max(voronoiYExtent[1], size[1] + interactionOverflow.bottom)]];
    const voronoiDiagram = voronoi().extent(voronoiExtent).x(d => d.voronoiX).y(d => d.voronoiY);
    const voronoiData = voronoiDiagram.polygons(voronoiDataset);
    voronoiPaths = voronoiData.map((d, i) => {
      return React$1__default.createElement("path", {
        onClick: () => clickVoronoi(voronoiDataset[i], props),
        onDoubleClick: () => doubleclickVoronoi(voronoiDataset[i], props),
        onMouseEnter: () => changeVoronoi({
          d: voronoiDataset[i],
          customHoverTypes: props.hoverAnnotation,
          props
        }),
        onMouseLeave: () => voronoiHover([]),
        key: `interactionVoronoi${i}`,
        d: `M${d.join('L')}Z`,
        style: {
          fillOpacity: 0,
          strokeOpacity: 0,
          stroke: 'none',
          ...pointerStyle
        }
      });
    }, undefined);
    return voronoiPaths;
  } else if (overlay) {
    const renderedOverlay = overlay.map((overlayRegion, i) => {
      const {
        overlayData,
        ...rest
      } = overlayRegion;

      if (React$1__default.isValidElement(overlayRegion.renderElement)) {
        const overlayProps = {
          key: `overlay-${i}`,
          onMouseEnter: () => changeVoronoi({
            d: overlayData,
            customHoverTypes: props.hoverAnnotation,
            props
          }),
          onMouseLeave: () => voronoiHover([]),
          onClick: () => clickVoronoi(overlayData, props),
          onDoubleClick: () => doubleclickVoronoi(overlayData, props),
          style: {
            opacity: 0,
            ...pointerStyle
          }
        };
        return React$1__default.cloneElement(overlayRegion.renderElement, overlayProps);
      } else {
        return React$1__default.createElement(lib_2, _extends({
          forceUpdate: true
        }, rest, {
          key: `overlay-${i}`,
          onMouseEnter: () => changeVoronoi({
            d: overlayData,
            customHoverTypes: props.hoverAnnotation,
            props
          }),
          onMouseLeave: () => voronoiHover([]),
          onClick: () => clickVoronoi(overlayData, props),
          onDoubleClick: () => doubleclickVoronoi(overlayData, props),
          style: {
            opacity: 0,
            ...pointerStyle
          }
        }));
      }
    });
    return renderedOverlay;
  }
};

function noevent() {
  event$1.preventDefault();
  event$1.stopImmediatePropagation();
}

function dragDisable(view) {
  var root = view.document.documentElement,
      selection = select(view).on("dragstart.drag", noevent, true);
  if ("onselectstart" in root) {
    selection.on("selectstart.drag", noevent, true);
  } else {
    root.__noselect = root.style.MozUserSelect;
    root.style.MozUserSelect = "none";
  }
}

function yesdrag(view, noclick) {
  var root = view.document.documentElement,
      selection = select(view).on("dragstart.drag", null);
  if (noclick) {
    selection.on("click.drag", noevent, true);
    setTimeout(function() { selection.on("click.drag", null); }, 0);
  }
  if ("onselectstart" in root) {
    selection.on("selectstart.drag", null);
  } else {
    root.style.MozUserSelect = root.__noselect;
    delete root.__noselect;
  }
}

function constant$b(x) {
  return function() {
    return x;
  };
}

function BrushEvent(target, type, selection) {
  this.target = target;
  this.type = type;
  this.selection = selection;
}

function nopropagation() {
  event$1.stopImmediatePropagation();
}

function noevent$1() {
  event$1.preventDefault();
  event$1.stopImmediatePropagation();
}

var MODE_DRAG = {name: "drag"},
    MODE_SPACE = {name: "space"},
    MODE_HANDLE = {name: "handle"},
    MODE_CENTER = {name: "center"};

function number1(e) {
  return [+e[0], +e[1]];
}

function number2(e) {
  return [number1(e[0]), number1(e[1])];
}

function toucher(identifier) {
  return function(target) {
    return touch(target, event$1.touches, identifier);
  };
}

var X = {
  name: "x",
  handles: ["w", "e"].map(type),
  input: function(x, e) { return x == null ? null : [[+x[0], e[0][1]], [+x[1], e[1][1]]]; },
  output: function(xy) { return xy && [xy[0][0], xy[1][0]]; }
};

var Y = {
  name: "y",
  handles: ["n", "s"].map(type),
  input: function(y, e) { return y == null ? null : [[e[0][0], +y[0]], [e[1][0], +y[1]]]; },
  output: function(xy) { return xy && [xy[0][1], xy[1][1]]; }
};

var cursors = {
  overlay: "crosshair",
  selection: "move",
  n: "ns-resize",
  e: "ew-resize",
  s: "ns-resize",
  w: "ew-resize",
  nw: "nwse-resize",
  ne: "nesw-resize",
  se: "nwse-resize",
  sw: "nesw-resize"
};

var flipX = {
  e: "w",
  w: "e",
  nw: "ne",
  ne: "nw",
  se: "sw",
  sw: "se"
};

var flipY = {
  n: "s",
  s: "n",
  nw: "sw",
  ne: "se",
  se: "ne",
  sw: "nw"
};

var signsX = {
  overlay: +1,
  selection: +1,
  n: null,
  e: +1,
  s: null,
  w: -1,
  nw: -1,
  ne: +1,
  se: +1,
  sw: -1
};

var signsY = {
  overlay: +1,
  selection: +1,
  n: -1,
  e: null,
  s: +1,
  w: null,
  nw: -1,
  ne: -1,
  se: +1,
  sw: +1
};

function type(t) {
  return {type: t};
}

// Ignore right-click, since that should open the context menu.
function defaultFilter() {
  return !event$1.ctrlKey && !event$1.button;
}

function defaultExtent() {
  var svg = this.ownerSVGElement || this;
  if (svg.hasAttribute("viewBox")) {
    svg = svg.viewBox.baseVal;
    return [[svg.x, svg.y], [svg.x + svg.width, svg.y + svg.height]];
  }
  return [[0, 0], [svg.width.baseVal.value, svg.height.baseVal.value]];
}

function defaultTouchable() {
  return navigator.maxTouchPoints || ("ontouchstart" in this);
}

// Like d3.local, but with the name “__brush” rather than auto-generated.
function local$1(node) {
  while (!node.__brush) if (!(node = node.parentNode)) return;
  return node.__brush;
}

function empty$1(extent) {
  return extent[0][0] === extent[1][0]
      || extent[0][1] === extent[1][1];
}

function brushX() {
  return brush(X);
}

function brushY() {
  return brush(Y);
}

function brush(dim) {
  var extent = defaultExtent,
      filter = defaultFilter,
      touchable = defaultTouchable,
      keys = true,
      listeners = dispatch("start", "brush", "end"),
      handleSize = 6,
      touchending;

  function brush(group) {
    var overlay = group
        .property("__brush", initialize)
      .selectAll(".overlay")
      .data([type("overlay")]);

    overlay.enter().append("rect")
        .attr("class", "overlay")
        .attr("pointer-events", "all")
        .attr("cursor", cursors.overlay)
      .merge(overlay)
        .each(function() {
          var extent = local$1(this).extent;
          select(this)
              .attr("x", extent[0][0])
              .attr("y", extent[0][1])
              .attr("width", extent[1][0] - extent[0][0])
              .attr("height", extent[1][1] - extent[0][1]);
        });

    group.selectAll(".selection")
      .data([type("selection")])
      .enter().append("rect")
        .attr("class", "selection")
        .attr("cursor", cursors.selection)
        .attr("fill", "#777")
        .attr("fill-opacity", 0.3)
        .attr("stroke", "#fff")
        .attr("shape-rendering", "crispEdges");

    var handle = group.selectAll(".handle")
      .data(dim.handles, function(d) { return d.type; });

    handle.exit().remove();

    handle.enter().append("rect")
        .attr("class", function(d) { return "handle handle--" + d.type; })
        .attr("cursor", function(d) { return cursors[d.type]; });

    group
        .each(redraw)
        .attr("fill", "none")
        .attr("pointer-events", "all")
        .on("mousedown.brush", started)
      .filter(touchable)
        .on("touchstart.brush", started)
        .on("touchmove.brush", touchmoved)
        .on("touchend.brush touchcancel.brush", touchended)
        .style("touch-action", "none")
        .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }

  brush.move = function(group, selection) {
    if (group.selection) {
      group
          .on("start.brush", function() { emitter(this, arguments).beforestart().start(); })
          .on("interrupt.brush end.brush", function() { emitter(this, arguments).end(); })
          .tween("brush", function() {
            var that = this,
                state = that.__brush,
                emit = emitter(that, arguments),
                selection0 = state.selection,
                selection1 = dim.input(typeof selection === "function" ? selection.apply(this, arguments) : selection, state.extent),
                i = interpolate(selection0, selection1);

            function tween(t) {
              state.selection = t === 1 && selection1 === null ? null : i(t);
              redraw.call(that);
              emit.brush();
            }

            return selection0 !== null && selection1 !== null ? tween : tween(1);
          });
    } else {
      group
          .each(function() {
            var that = this,
                args = arguments,
                state = that.__brush,
                selection1 = dim.input(typeof selection === "function" ? selection.apply(that, args) : selection, state.extent),
                emit = emitter(that, args).beforestart();

            interrupt(that);
            state.selection = selection1 === null ? null : selection1;
            redraw.call(that);
            emit.start().brush().end();
          });
    }
  };

  brush.clear = function(group) {
    brush.move(group, null);
  };

  function redraw() {
    var group = select(this),
        selection = local$1(this).selection;

    if (selection) {
      group.selectAll(".selection")
          .style("display", null)
          .attr("x", selection[0][0])
          .attr("y", selection[0][1])
          .attr("width", selection[1][0] - selection[0][0])
          .attr("height", selection[1][1] - selection[0][1]);

      group.selectAll(".handle")
          .style("display", null)
          .attr("x", function(d) { return d.type[d.type.length - 1] === "e" ? selection[1][0] - handleSize / 2 : selection[0][0] - handleSize / 2; })
          .attr("y", function(d) { return d.type[0] === "s" ? selection[1][1] - handleSize / 2 : selection[0][1] - handleSize / 2; })
          .attr("width", function(d) { return d.type === "n" || d.type === "s" ? selection[1][0] - selection[0][0] + handleSize : handleSize; })
          .attr("height", function(d) { return d.type === "e" || d.type === "w" ? selection[1][1] - selection[0][1] + handleSize : handleSize; });
    }

    else {
      group.selectAll(".selection,.handle")
          .style("display", "none")
          .attr("x", null)
          .attr("y", null)
          .attr("width", null)
          .attr("height", null);
    }
  }

  function emitter(that, args, clean) {
    return (!clean && that.__brush.emitter) || new Emitter(that, args);
  }

  function Emitter(that, args) {
    this.that = that;
    this.args = args;
    this.state = that.__brush;
    this.active = 0;
  }

  Emitter.prototype = {
    beforestart: function() {
      if (++this.active === 1) this.state.emitter = this, this.starting = true;
      return this;
    },
    start: function() {
      if (this.starting) this.starting = false, this.emit("start");
      else this.emit("brush");
      return this;
    },
    brush: function() {
      this.emit("brush");
      return this;
    },
    end: function() {
      if (--this.active === 0) delete this.state.emitter, this.emit("end");
      return this;
    },
    emit: function(type) {
      customEvent(new BrushEvent(brush, type, dim.output(this.state.selection)), listeners.apply, listeners, [type, this.that, this.args]);
    }
  };

  function started() {
    if (touchending && !event$1.touches) return;
    if (!filter.apply(this, arguments)) return;

    var that = this,
        type = event$1.target.__data__.type,
        mode = (keys && event$1.metaKey ? type = "overlay" : type) === "selection" ? MODE_DRAG : (keys && event$1.altKey ? MODE_CENTER : MODE_HANDLE),
        signX = dim === Y ? null : signsX[type],
        signY = dim === X ? null : signsY[type],
        state = local$1(that),
        extent = state.extent,
        selection = state.selection,
        W = extent[0][0], w0, w1,
        N = extent[0][1], n0, n1,
        E = extent[1][0], e0, e1,
        S = extent[1][1], s0, s1,
        dx = 0,
        dy = 0,
        moving,
        shifting = signX && signY && keys && event$1.shiftKey,
        lockX,
        lockY,
        pointer = event$1.touches ? toucher(event$1.changedTouches[0].identifier) : mouse,
        point0 = pointer(that),
        point = point0,
        emit = emitter(that, arguments, true).beforestart();

    if (type === "overlay") {
      if (selection) moving = true;
      state.selection = selection = [
        [w0 = dim === Y ? W : point0[0], n0 = dim === X ? N : point0[1]],
        [e0 = dim === Y ? E : w0, s0 = dim === X ? S : n0]
      ];
    } else {
      w0 = selection[0][0];
      n0 = selection[0][1];
      e0 = selection[1][0];
      s0 = selection[1][1];
    }

    w1 = w0;
    n1 = n0;
    e1 = e0;
    s1 = s0;

    var group = select(that)
        .attr("pointer-events", "none");

    var overlay = group.selectAll(".overlay")
        .attr("cursor", cursors[type]);

    if (event$1.touches) {
      emit.moved = moved;
      emit.ended = ended;
    } else {
      var view = select(event$1.view)
          .on("mousemove.brush", moved, true)
          .on("mouseup.brush", ended, true);
      if (keys) view
          .on("keydown.brush", keydowned, true)
          .on("keyup.brush", keyupped, true);

      dragDisable(event$1.view);
    }

    nopropagation();
    interrupt(that);
    redraw.call(that);
    emit.start();

    function moved() {
      var point1 = pointer(that);
      if (shifting && !lockX && !lockY) {
        if (Math.abs(point1[0] - point[0]) > Math.abs(point1[1] - point[1])) lockY = true;
        else lockX = true;
      }
      point = point1;
      moving = true;
      noevent$1();
      move();
    }

    function move() {
      var t;

      dx = point[0] - point0[0];
      dy = point[1] - point0[1];

      switch (mode) {
        case MODE_SPACE:
        case MODE_DRAG: {
          if (signX) dx = Math.max(W - w0, Math.min(E - e0, dx)), w1 = w0 + dx, e1 = e0 + dx;
          if (signY) dy = Math.max(N - n0, Math.min(S - s0, dy)), n1 = n0 + dy, s1 = s0 + dy;
          break;
        }
        case MODE_HANDLE: {
          if (signX < 0) dx = Math.max(W - w0, Math.min(E - w0, dx)), w1 = w0 + dx, e1 = e0;
          else if (signX > 0) dx = Math.max(W - e0, Math.min(E - e0, dx)), w1 = w0, e1 = e0 + dx;
          if (signY < 0) dy = Math.max(N - n0, Math.min(S - n0, dy)), n1 = n0 + dy, s1 = s0;
          else if (signY > 0) dy = Math.max(N - s0, Math.min(S - s0, dy)), n1 = n0, s1 = s0 + dy;
          break;
        }
        case MODE_CENTER: {
          if (signX) w1 = Math.max(W, Math.min(E, w0 - dx * signX)), e1 = Math.max(W, Math.min(E, e0 + dx * signX));
          if (signY) n1 = Math.max(N, Math.min(S, n0 - dy * signY)), s1 = Math.max(N, Math.min(S, s0 + dy * signY));
          break;
        }
      }

      if (e1 < w1) {
        signX *= -1;
        t = w0, w0 = e0, e0 = t;
        t = w1, w1 = e1, e1 = t;
        if (type in flipX) overlay.attr("cursor", cursors[type = flipX[type]]);
      }

      if (s1 < n1) {
        signY *= -1;
        t = n0, n0 = s0, s0 = t;
        t = n1, n1 = s1, s1 = t;
        if (type in flipY) overlay.attr("cursor", cursors[type = flipY[type]]);
      }

      if (state.selection) selection = state.selection; // May be set by brush.move!
      if (lockX) w1 = selection[0][0], e1 = selection[1][0];
      if (lockY) n1 = selection[0][1], s1 = selection[1][1];

      if (selection[0][0] !== w1
          || selection[0][1] !== n1
          || selection[1][0] !== e1
          || selection[1][1] !== s1) {
        state.selection = [[w1, n1], [e1, s1]];
        redraw.call(that);
        emit.brush();
      }
    }

    function ended() {
      nopropagation();
      if (event$1.touches) {
        if (event$1.touches.length) return;
        if (touchending) clearTimeout(touchending);
        touchending = setTimeout(function() { touchending = null; }, 500); // Ghost clicks are delayed!
      } else {
        yesdrag(event$1.view, moving);
        view.on("keydown.brush keyup.brush mousemove.brush mouseup.brush", null);
      }
      group.attr("pointer-events", "all");
      overlay.attr("cursor", cursors.overlay);
      if (state.selection) selection = state.selection; // May be set by brush.move (on start)!
      if (empty$1(selection)) state.selection = null, redraw.call(that);
      emit.end();
    }

    function keydowned() {
      switch (event$1.keyCode) {
        case 16: { // SHIFT
          shifting = signX && signY;
          break;
        }
        case 18: { // ALT
          if (mode === MODE_HANDLE) {
            if (signX) e0 = e1 - dx * signX, w0 = w1 + dx * signX;
            if (signY) s0 = s1 - dy * signY, n0 = n1 + dy * signY;
            mode = MODE_CENTER;
            move();
          }
          break;
        }
        case 32: { // SPACE; takes priority over ALT
          if (mode === MODE_HANDLE || mode === MODE_CENTER) {
            if (signX < 0) e0 = e1 - dx; else if (signX > 0) w0 = w1 - dx;
            if (signY < 0) s0 = s1 - dy; else if (signY > 0) n0 = n1 - dy;
            mode = MODE_SPACE;
            overlay.attr("cursor", cursors.selection);
            move();
          }
          break;
        }
        default: return;
      }
      noevent$1();
    }

    function keyupped() {
      switch (event$1.keyCode) {
        case 16: { // SHIFT
          if (shifting) {
            lockX = lockY = shifting = false;
            move();
          }
          break;
        }
        case 18: { // ALT
          if (mode === MODE_CENTER) {
            if (signX < 0) e0 = e1; else if (signX > 0) w0 = w1;
            if (signY < 0) s0 = s1; else if (signY > 0) n0 = n1;
            mode = MODE_HANDLE;
            move();
          }
          break;
        }
        case 32: { // SPACE
          if (mode === MODE_SPACE) {
            if (event$1.altKey) {
              if (signX) e0 = e1 - dx * signX, w0 = w1 + dx * signX;
              if (signY) s0 = s1 - dy * signY, n0 = n1 + dy * signY;
              mode = MODE_CENTER;
            } else {
              if (signX < 0) e0 = e1; else if (signX > 0) w0 = w1;
              if (signY < 0) s0 = s1; else if (signY > 0) n0 = n1;
              mode = MODE_HANDLE;
            }
            overlay.attr("cursor", cursors[type]);
            move();
          }
          break;
        }
        default: return;
      }
      noevent$1();
    }
  }

  function touchmoved() {
    emitter(this, arguments).moved();
  }

  function touchended() {
    emitter(this, arguments).ended();
  }

  function initialize() {
    var state = this.__brush || {selection: null};
    state.extent = number2(extent.apply(this, arguments));
    state.dim = dim;
    return state;
  }

  brush.extent = function(_) {
    return arguments.length ? (extent = typeof _ === "function" ? _ : constant$b(number2(_)), brush) : extent;
  };

  brush.filter = function(_) {
    return arguments.length ? (filter = typeof _ === "function" ? _ : constant$b(!!_), brush) : filter;
  };

  brush.touchable = function(_) {
    return arguments.length ? (touchable = typeof _ === "function" ? _ : constant$b(!!_), brush) : touchable;
  };

  brush.handleSize = function(_) {
    return arguments.length ? (handleSize = +_, brush) : handleSize;
  };

  brush.keyModifiers = function(_) {
    return arguments.length ? (keys = !!_, brush) : keys;
  };

  brush.on = function() {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? brush : value;
  };

  return brush;
}

const usePrevious = value => {
  const ref = useRef();
  useEffect(() => {
    ref.current = value;
  });
  return ref.current;
};

const flatten = list => list.reduce((a, b) => a.concat(Array.isArray(b) ? flatten(b.sort((a, b) => a - b)) : b), []);

const flatShortArray = array => {
  if (!Array.isArray(array)) return 'not-array';

  if (!Array.isArray(array[0])) {
    array = array.sort((a, b) => a - b);
  }

  const flat = flatten(array);
  return flat.map(d => d instanceof Date && d.toString() || d && d.toFixed && d.toFixed(2) || 'empty').toString();
};

const createBrush = (svgBrush, node, selectedExtent) => {
  const brush = svgBrush;
  select(node).call(brush);
  let _selectedExtent = selectedExtent;

  if (_selectedExtent) {
    if (Array.isArray(_selectedExtent[0])) {
      const sortedY = [_selectedExtent[0][1], _selectedExtent[1][1]].sort((a, b) => a - b);
      _selectedExtent = [[_selectedExtent[0][0], sortedY[0]], [_selectedExtent[1][0], sortedY[1]]];
    }

    select(node).call(brush.move, _selectedExtent);
  }
};

const Brush = props => {
  const {
    position = [0, 0],
    svgBrush,
    selectedExtent,
    extent
  } = props;
  const node = React$1.useRef(null);
  const {
    extent: prevExtent,
    selectedExtent: prevSelectedExtent
  } = usePrevious({
    extent,
    selectedExtent
  });
  React$1.useEffect(() => {
    if (prevExtent && extent && flatShortArray(prevExtent) !== flatShortArray(extent) || prevSelectedExtent && electedExtent && flatShortArray(prevSelectedExtent) !== flatShortArray(selectedExtent) || !prevSelectedExtent && selectedExtent || prevSelectedExtent && !selectedExtent) {
      createBrush(svgBrush, node, selectedExtent);
    }
  });
  return React$1__default.createElement("g", {
    transform: `translate(${position})`,
    ref: node,
    className: "xybrush"
  });
};

const generateOMappingFn = projectedColumns => d => d ? Object.values(projectedColumns).filter(c => d[1] >= c.x && d[0] <= c.x + c.width) : null;

const generateOEndMappingFn = projectedColumns => d => {
  if (d && event$1.sourceEvent && event$1.sourceEvent.path && event$1.sourceEvent.path[1] && event$1.sourceEvent.path[1].classList.contains('xybrush') && event$1.target.move) {
    const columnValues = Object.values(projectedColumns);
    const foundColumns = columnValues.filter(c => d[1] >= c.x && d[0] <= c.x + c.width);
    const firstColumn = foundColumns[0] || {
      x: 0,
      width: 0
    };
    const lastColumn = foundColumns[foundColumns.length - 1] || {
      x: 0,
      width: 0
    };
    const columnPosition = [firstColumn.x + Math.min(5, firstColumn.width / 10), lastColumn.x + lastColumn.width - Math.min(5, lastColumn.width / 10)];
    select(event$1.sourceEvent.path[1]).transition(750).call(event$1.target.move, columnPosition);
    return foundColumns;
  }

  return null;
};

const brushStart = (e, column, data, props) => {
  if (props.interaction && props.interaction.start) props.interaction.start(e, column, data);
};

const brush$1 = (e, column, data, props) => {
  if (props.interaction && props.interaction.during) props.interaction.during(e, column, data);
};

const brushEnd = (e, column, data, props) => {
  if (props.interaction && props.interaction.end) props.interaction.end(e, column, data);
};

const createBrush$1 = (interaction, props) => {
  let semioticBrush, mappingFn, selectedExtent, endMappingFn;
  const {
    xScale,
    yScale,
    size,
    renderPipeline
  } = props;
  const brushData = {};
  Object.entries(renderPipeline).forEach(([key, value]) => {
    if (value.data && value.data.length > 0) {
      brushData[key] = value.data;
    }
  });
  const {
    projection,
    projectedColumns
  } = interaction;
  const actualBrush = interaction.brush === 'oBrush' ? projection === 'horizontal' ? 'yBrush' : 'xBrush' : interaction.brush;
  const {
    extent = actualBrush === 'xyBrush' ? [[xScale.invert(0), yScale.invert(0)], [xScale.invert(size[0]), yScale.invert(size[1])]] : actualBrush === 'xBrush' ? [xScale.invert(0), xScale.invert(size[0])] : [yScale.invert(0), yScale.invert(size[1])]
  } = interaction;

  if (extent.indexOf && extent.indexOf(undefined) !== -1) {
    return React$1__default.createElement("g", null);
  }

  if (actualBrush === 'xBrush') {
    const castExtent = extent;

    mappingFn = d => !d ? null : [xScale.invert(d[0]), xScale.invert(d[1])];

    semioticBrush = brushX();
    selectedExtent = castExtent.map(d => xScale(d));
    endMappingFn = mappingFn;
  } else if (actualBrush === 'yBrush') {
    const castExtent = extent;

    mappingFn = d => !d ? null : [yScale.invert(d[0]), yScale.invert(d[1])].sort((a, b) => a - b);

    semioticBrush = brushY();
    selectedExtent = castExtent.map(d => yScale(d)).sort((a, b) => a - b);
    endMappingFn = mappingFn;
  } else {
    const castExtent = extent;

    if (castExtent.indexOf(undefined) !== -1 || castExtent[0].indexOf(undefined) !== -1 || castExtent[1].indexOf(undefined) !== -1) {
      return React$1__default.createElement("g", null);
    }

    semioticBrush = brush$1();

    mappingFn = d => {
      if (!d) return null;
      const yValues = [yScale.invert(d[0][1]), yScale.invert(d[1][1])].sort((a, b) => a - b);
      return [[xScale.invert(d[0][0]), yValues[0]], [xScale.invert(d[1][0]), yValues[1]]];
    };

    const yValues = [yScale(extent[0][1]), yScale(extent[1][1])].sort((a, b) => a - b);
    selectedExtent = castExtent.map((d, i) => [xScale(d[0]), yValues[i]]);
    endMappingFn = mappingFn;
  }

  if (interaction.brush === 'oBrush') {
    selectedExtent = null;

    if (interaction.extent) {
      const [leftExtent, rightExtent] = interaction.extent;

      if ((typeof leftExtent === 'string' || typeof leftExtent === 'number') && (typeof rightExtent === 'string' || typeof rightExtent === 'number')) {
        selectedExtent = [projectedColumns[leftExtent].x, projectedColumns[rightExtent].x + projectedColumns[rightExtent].width];
      }
    }

    mappingFn = generateOMappingFn(projectedColumns);
    endMappingFn = generateOEndMappingFn(projectedColumns);
  }

  semioticBrush.extent([[0, 0], [props.size[0], props.size[1]]]).on('start', () => brushStart(mappingFn(event$1.selection), undefined, brushData, props)).on('brush', () => brush$1(mappingFn(event$1.selection), undefined, brushData, props)).on('end', () => brushEnd(endMappingFn(event$1.selection), undefined, brushData, props));
  return React$1__default.createElement("g", {
    className: "brush"
  }, React$1__default.createElement(Brush, {
    selectedExtent: selectedExtent,
    extent: extent,
    svgBrush: semioticBrush
  }));
};

const canvasEvent = (canvasContext, overlayRegions, canvasMap, e) => {
  const interactionContext = canvasContext.getContext('2d');
  const hoverPoint = interactionContext.getImageData(e.offsetX, e.offsetY, 1, 1);
  const mostCommonRGB = `rgba(${hoverPoint.data[0]},${hoverPoint.data[1]},${hoverPoint.data[2]},255)`;
  let overlay = overlayRegions[canvasMap.get(mostCommonRGB)];

  if (!overlay) {
    const hoverArea = interactionContext.getImageData(e.offsetX - 2, e.offsetY - 2, 5, 5);
    let x = 0;

    while (!overlay && x < 100) {
      overlay = overlayRegions[canvasMap.get(`rgba(${hoverArea.data[x]},${hoverArea.data[x + 1]},${hoverArea.data[x + 2]},255)`)];
      x += 4;
    }
  }

  return overlay;
};

const InteractionLayer = props => {
  const canvasMap = new Map();
  const [interactionContext, setInteractionContext] = React$1.useState(null);
  const [overlayRegions, setOverlayRegions] = React$1.useState([]);
  const {
    xScale,
    yScale,
    data,
    size,
    overlay,
    hoverAnnotation,
    useCanvas,
    voronoiHover
  } = props;
  React$1.useEffect(() => {
    setOverlayRegions(calculateOverlay(props));
  }, [xScale, yScale, data, size, overlay, hoverAnnotation]);

  const generateInteractionCanvas = props => {
    return React$1__default.createElement("canvas", {
      className: "frame-canvas-interaction",
      ref: canvasContext => {
        const boundCanvasEvent = canvasEvent.bind(null, canvasContext, overlayRegions, canvasMap);

        if (canvasContext) {
          canvasContext.onmousemove = e => {
            const overlay = boundCanvasEvent(e);

            if (overlay && overlay.props) {
              overlay.props.onMouseEnter();
            } else {
              voronoiHover([]);
            }
          };

          canvasContext.onclick = e => {
            const overlay = boundCanvasEvent(e);

            if (overlay && overlay.props) {
              overlay.props.onClick();
            }
          };

          canvasContext.ondblclick = e => {
            const overlay = boundCanvasEvent(e);

            if (overlay && overlay.props) {
              overlay.props.onDoubleClick();
            }
          };
        }

        setInteractionContext(canvasContext);
      },
      style: {
        position: 'absolute',
        left: `0px`,
        top: `0px`,
        imageRendering: 'pixelated',
        pointerEvents: 'all',
        opacity: 0
      },
      width: props.svgSize[0],
      height: props.svgSize[1]
    });
  };

  const interactionCanvas = generateInteractionCanvas(props);
  React$1.useEffect(() => {
    renderCanvas({
      props,
      canvasMap,
      overlayRegions,
      interactionContext
    });
  }, [overlayRegions]);
  let semioticBrush = null;
  const {
    interaction,
    svgSize,
    margin,
    useSpans,
    disableCanvasInteraction,
    enabled: userEnabled
  } = props;
  let enabled = userEnabled;

  if (interaction && interaction.brush) {
    enabled = true;
    semioticBrush = createBrush$1(interaction, props);
  }

  if (interaction && interaction.columnsBrush) {
    enabled = true;
    semioticBrush = createColumnsBrush(interaction, props);
  }

  if (!overlayRegions && !semioticBrush) {
    return null;
  }

  const _interactionCanvas = !disableCanvasInteraction && useCanvas && overlayRegions && interactionCanvas;

  return React$1__default.createElement(SpanOrDiv, {
    span: useSpans,
    className: "interaction-layer",
    style: {
      position: 'absolute',
      background: 'none',
      pointerEvents: 'none'
    }
  }, _interactionCanvas || React$1__default.createElement("svg", {
    height: svgSize[1],
    width: svgSize[0],
    style: {
      background: 'none',
      pointerEvents: 'none'
    }
  }, React$1__default.createElement("g", {
    className: "interaction-overlay",
    transform: `translate(${margin.left},${margin.top})`,
    style: {
      pointerEvents: enabled ? 'all' : 'none'
    }
  }, React$1__default.createElement("g", {
    className: "interaction-regions"
  }, overlayRegions), semioticBrush)));
};

InteractionLayer.propTypes = {
  name: propTypes.string,
  interaction: propTypes.object,
  overlay: propTypes.array,
  xScale: propTypes.func,
  yScale: propTypes.func,
  rScale: propTypes.func,
  svgSize: propTypes.array,
  hoverAnnotation: propTypes.oneOfType([propTypes.bool, propTypes.object, propTypes.array, propTypes.func]),
  interactionOverflow: propTypes.object,
  size: propTypes.arrayOf(propTypes.number),
  position: propTypes.arrayOf(propTypes.number),
  enabled: propTypes.bool,
  useSpans: propTypes.bool,
  margin: propTypes.object,
  useCanvas: propTypes.bool,
  customDoubleClickBehavior: propTypes.func,
  customClickBehavior: propTypes.func,
  customHoverBehavior: propTypes.func,
  voronoiHover: propTypes.func,
  disableCanvasInteraction: propTypes.bool
};
InteractionLayer.defaultProps = {
  svgSize: [500, 500],
  useSpans: false,
  useCanvas: false
};

// from Evan Wang's https://github.com/tinker10/D3-Labeler
function labeler () {
  let lab = [],
      anc = [],
      w = 1,
      // box width
  h = 1,
      // box width
  labeler = {
    start: x => {},
    width: x => {},
    height: x => {},
    label: x => {},
    anchor: x => {},
    alt_energy: x => {},
    alt_schedule: x => {}
  };
  let max_move = 5.0,
      max_angle = 0.5; // weights

  let w_len = 0.2,
      // leader line length
  w_inter = 1.0,
      // leader line intersection
  w_lab2 = 30.0,
      // label-label overlap
  w_lab_anc = 30.0,
      // label-anchor overlap
  w_orient = 3.0; // orientation bias
  // booleans for user defined functions

  let user_energy = false;
  let user_defined_energy;

  const energy = function (index) {
    // energy function, tailored for label placement
    let m = lab.length,
        ener = 0,
        dx = lab[index].x - anc[index].x,
        dy = anc[index].y - lab[index].y,
        dist = Math.sqrt(dx * dx + dy * dy);
 // penalty for length of leader line

    if (dist > 0) ener += dist * w_len; // label orientation bias

    dx /= dist;
    dy /= dist;

    if (dx > 0 && dy > 0) {
      ener += 0 * w_orient;
    } else if (dx < 0 && dy > 0) {
      ener += 1 * w_orient;
    } else if (dx < 0 && dy < 0) {
      ener += 2 * w_orient;
    } else {
      ener += 3 * w_orient;
    }

    let x21 = lab[index].x,
        y21 = lab[index].y - lab[index].height + 2.0,
        x22 = lab[index].x + lab[index].width,
        y22 = lab[index].y + 2.0;
    let x11, x12, y11, y12, x_overlap, y_overlap, overlap_area;

    for (let i = 0; i < m; i++) {
      if (i !== index) {
        // penalty for intersection of leader lines
        const overlap = intersect(anc[index].x, lab[index].x, anc[i].x, lab[i].x, anc[index].y, lab[index].y, anc[i].y, lab[i].y);
        if (overlap) ener += w_inter; // penalty for label-label overlap

        x11 = lab[i].x;
        y11 = lab[i].y - lab[i].height + 2.0;
        x12 = lab[i].x + lab[i].width;
        y12 = lab[i].y + 2.0;
        x_overlap = Math.max(0, Math.min(x12, x22) - Math.max(x11, x21));
        y_overlap = Math.max(0, Math.min(y12, y22) - Math.max(y11, y21));
        overlap_area = x_overlap * y_overlap;
        ener += overlap_area * w_lab2;
      } // penalty for label-anchor overlap


      x11 = anc[i].x - anc[i].r;
      y11 = anc[i].y - anc[i].r;
      x12 = anc[i].x + anc[i].r;
      y12 = anc[i].y + anc[i].r;
      x_overlap = Math.max(0, Math.min(x12, x22) - Math.max(x11, x21));
      y_overlap = Math.max(0, Math.min(y12, y22) - Math.max(y11, y21));
      overlap_area = x_overlap * y_overlap;
      ener += overlap_area * w_lab_anc;
    }

    return ener;
  };

  const mcmove = function (currT) {
    // Monte Carlo translation move
    // select a random label
    let i = Math.floor(Math.random() * lab.length); // save old coordinates

    let x_old = lab[i].x;
    let y_old = lab[i].y; // old energy

    let old_energy;

    if (user_energy) {
      old_energy = user_defined_energy(i, lab, anc);
    } else {
      old_energy = energy(i);
    } // random translation


    lab[i].x += (Math.random() - 0.5) * max_move;
    lab[i].y += (Math.random() - 0.5) * max_move; // hard wall boundaries

    if (lab[i].x > w) lab[i].x = x_old;
    if (lab[i].x < 0) lab[i].x = x_old;
    if (lab[i].y > h) lab[i].y = y_old;
    if (lab[i].y < 0) lab[i].y = y_old; // new energy

    let new_energy;

    if (user_energy) {
      new_energy = user_defined_energy(i, lab, anc);
    } else {
      new_energy = energy(i);
    } // delta E


    let delta_energy = new_energy - old_energy;

    if (!(Math.random() < Math.exp(-delta_energy / currT))) {
      // move back to old coordinates
      lab[i].x = x_old;
      lab[i].y = y_old;
    }
  };

  const mcrotate = function (currT) {
    // Monte Carlo rotation move
    // select a random label
    let i = Math.floor(Math.random() * lab.length); // save old coordinates

    let x_old = lab[i].x;
    let y_old = lab[i].y; // old energy

    let old_energy;

    if (user_energy) {
      old_energy = user_defined_energy(i, lab, anc);
    } else {
      old_energy = energy(i);
    } // random angle


    let angle = (Math.random() - 0.5) * max_angle;
    let s = Math.sin(angle);
    let c = Math.cos(angle); // translate label (relative to anchor at origin):

    lab[i].x -= anc[i].x;
    lab[i].y -= anc[i].y; // rotate label

    let x_new = lab[i].x * c - lab[i].y * s,
        y_new = lab[i].x * s + lab[i].y * c; // translate label back

    lab[i].x = x_new + anc[i].x;
    lab[i].y = y_new + anc[i].y; // hard wall boundaries

    if (lab[i].x > w) lab[i].x = x_old;
    if (lab[i].x < 0) lab[i].x = x_old;
    if (lab[i].y > h) lab[i].y = y_old;
    if (lab[i].y < 0) lab[i].y = y_old; // new energy

    let new_energy;

    if (user_energy) {
      new_energy = user_defined_energy(i, lab, anc);
    } else {
      new_energy = energy(i);
    } // delta E


    let delta_energy = new_energy - old_energy;

    if (!(Math.random() < Math.exp(-delta_energy / currT))) {
      // move back to old coordinates
      lab[i].x = x_old;
      lab[i].y = y_old;
    }
  };

  const intersect = function (x1, x2, x3, x4, y1, y2, y3, y4) {
    // returns true if two lines intersect, else false
    // from http://paulbourke.net/geometry/lineline2d/
    let mua, mub;
    let denom, numera, numerb;
    denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
    numera = (x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3);
    numerb = (x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3);
    /* Is the intersection along the the segments */

    mua = numera / denom;
    mub = numerb / denom;

    if (!(mua < 0 || mua > 1 || mub < 0 || mub > 1)) {
      return true;
    }

    return false;
  };

  const cooling_schedule = function (currT, initialT, nsweeps) {
    // linear cooling
    return currT - initialT / nsweeps;
  };

  labeler.start = function (nsweeps) {
    // main simulated annealing function
    let m = lab.length,
        currT = 1.0,
        initialT = 1.0;

    for (let i = 0; i < nsweeps; i++) {
      for (let j = 0; j < m; j++) {
        if (Math.random() < 0.5) {
          mcmove(currT);
        } else {
          mcrotate(currT);
        }
      }

      currT = cooling_schedule(currT, initialT, nsweeps);
    }
  };

  labeler.width = function (x) {
    // users insert graph width
    if (!arguments.length) return w;
    w = x;
    return labeler;
  };

  labeler.height = function (x) {
    // users insert graph height
    if (!arguments.length) return h;
    h = x;
    return labeler;
  };

  labeler.label = function (x) {
    // users insert label positions
    if (!arguments.length) return lab;
    lab = x;
    return labeler;
  };

  labeler.anchor = function (x) {
    // users insert anchor positions
    if (!arguments.length) return anc;
    anc = x;
    return labeler;
  };

  labeler.alt_energy = function (x) {
    // user defined energy
    if (!arguments.length) return energy;
    user_defined_energy = x;
    user_energy = true;
    return labeler;
  };

  labeler.alt_schedule = function (x) {
    // user defined cooling_schedule
    if (!arguments.length) return cooling_schedule;
    return labeler;
  };

  return labeler;
}
/*eslint-enable */

const basicLabelSizeFunction = (noteData, characterWidth, lineHeight, padding) => {
  const text = noteData.note.label || noteData.note.title;
  const textLength = text.length;
  const wrap = noteData.note.wrap || 120;
  const width = Math.min(wrap, textLength * characterWidth) + padding * 2;
  const height = Math.ceil(textLength * characterWidth / 120) * lineHeight + padding * 2;
  return [width, height];
};

function bumpAnnotations(adjustableNotes, processor, size, propsPointSizeFunction, propsLabelSizeFunction) {
  const {
    padding = 1,
    characterWidth = 8,
    lineHeight = 20,
    iterations = 500,
    pointSizeFunction = propsPointSizeFunction,
    labelSizeFunction = propsLabelSizeFunction || basicLabelSizeFunction
  } = processor;
  const labels = adjustableNotes.map((d, i) => {
    const anchorX = (d.props.noteData.x[0] || d.props.noteData.x) + (d.props.noteData.dx !== undefined ? d.props.noteData.dx : (i % 3 - 1) * -10);
    const anchorY = (d.props.noteData.y[0] || d.props.noteData.y) + (d.props.noteData.dy !== undefined ? d.props.noteData.dy : (i % 3 - 1) * 10);
    const [labelWidth, labelHeight] = labelSizeFunction(d.props.noteData, characterWidth, lineHeight, padding);
    return {
      x: anchorX,
      y: anchorY,
      above: anchorY < d.props.noteData.y,
      left: anchorX < d.props.noteData.x,
      width: labelWidth,
      height: labelHeight,
      type: 'label',
      name: '',
      originalNote: d
    };
  });
  const points = adjustableNotes.map(d => ({
    x: d.props.noteData.x,
    y: d.props.noteData.y,
    fx: d.props.noteData.x,
    fy: d.props.noteData.y,
    r: pointSizeFunction && pointSizeFunction(d.props.noteData) || 5,
    type: 'point',
    originalNote: d
  }));
  const instantiatedLabeler = labeler();
  instantiatedLabeler.label(labels);
  instantiatedLabeler.anchor(points);
  instantiatedLabeler.width(size[0]);
  instantiatedLabeler.height(size[1]);
  instantiatedLabeler.start(iterations);
  labels.forEach(d => {
    if (d.type === 'label') {
      const adjusted = adjustedXY(d.originalNote.props.noteData, d, padding);
      d.originalNote.props.noteData.nx = adjusted[0];
      d.originalNote.props.noteData.ny = adjusted[1];
    }
  });
  return adjustableNotes;
}

function adjustedXY(note, calculated, padding) {
  if (note.y > calculated.y) {
    //below
    return [calculated.x + calculated.width / 2 + padding / 2, calculated.y - calculated.height + padding / 2];
  }

  return [calculated.x + calculated.width / 2, calculated.y];
}

var labella_min = createCommonjsModule(function (module, exports) {
!function(t,e){module.exports=e();}(commonjsGlobal,function(){return function(t){function e(n){if(r[n])return r[n].exports;var i=r[n]={exports:{},id:n,loaded:!1};return t[n].call(i.exports,i,i.exports,e),i.loaded=!0,i.exports}var r={};return e.m=t,e.c=r,e.p="",e(0)}([function(t,e,r){t.exports={Node:r(1),Force:r(2),Distributor:r(3),Renderer:r(10)};},function(t,e){function r(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}var n=function(){function t(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n);}}return function(e,r,n){return r&&t(e.prototype,r),n&&t(e,n),e}}(),i=function(){function t(e,n,i){r(this,t),this.idealPos=e,this.currentPos=e,this.width=n,this.data=i,this.layerIndex=0;}return n(t,[{key:"distanceFrom",value:function(t){var e=this.width/2,r=t.width/2;return Math.max(this.currentPos-e,t.currentPos-r)-Math.min(this.currentPos+e,t.currentPos+r)}},{key:"moveToIdealPosition",value:function(){return this.currentPos=this.idealPos,this}},{key:"displacement",value:function(){return this.idealPos-this.currentPos}},{key:"overlapWithNode",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this.distanceFrom(t)-e<0}},{key:"overlapWithPoint",value:function(t){var e=this.width/2;return t>=this.currentPos-e&&t<=this.currentPos+e}},{key:"positionBefore",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return t.currentLeft()-this.width/2-e}},{key:"positionAfter",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return t.currentRight()+this.width/2+e}},{key:"currentRight",value:function(){return this.currentPos+this.width/2}},{key:"currentLeft",value:function(){return this.currentPos-this.width/2}},{key:"idealRight",value:function(){return this.idealPos+this.width/2}},{key:"idealLeft",value:function(){return this.idealPos-this.width/2}},{key:"createStub",value:function(e){var r=new t(this.idealPos,e,this.data);return r.currentPos=this.currentPos,r.child=this,this.parent=r,r}},{key:"removeStub",value:function(){return this.parent&&(this.parent.child=null,this.parent=null),this}},{key:"isStub",value:function(){return !!this.child}},{key:"getPathToRoot",value:function(){for(var t=[],e=this;e;)t.push(e),e=e.parent;return t}},{key:"getPathFromRoot",value:function(){return this.getPathToRoot().reverse()}},{key:"getPathToRootLength",value:function(){for(var t=0,e=this;e;){var r=e.parent?e.parent.currentPos:e.idealPos;t+=Math.abs(e.currentPos-r),e=e.parent;}return t}},{key:"getRoot",value:function(){for(var t=this,e=this;e;)t=e,e=e.parent;return t}},{key:"getLayerIndex",value:function(){return this.layerIndex}},{key:"clone",value:function(){var e=new t(this.idealPos,this.width,this.data);return e.currentPos=this.currentPos,e.layerIndex=this.layerIndex,e}}]),t}();t.exports=i;},function(t,e,r){var n=r(3),i=r(4),o=r(8),s={nodeSpacing:3,minPos:0,maxPos:null,algorithm:"overlap",removeOverlap:!0,density:.85,stubWidth:1},u=function(t){var e={},r=i.extend({},s),u=new n,a=[],c=null;return e.nodes=function(t){return arguments.length?(a=t,c=[t.concat()],e):a},e.getLayers=function(){return c},e.options=function(t){if(!arguments.length)return r;r=i.extend(r,t);var o=i.pick(r,Object.keys(n.DEFAULT_OPTIONS));return i.isDefined(r.minPos)&&i.isDefined(r.maxPos)?o.layerWidth=r.maxPos-r.minPos:o.layerWidth=null,u.options(o),e},e.options(t),e.compute=function(){var t=i.pick(r,Object.keys(o.DEFAULT_OPTIONS));return a.forEach(function(t){t.removeStub();}),c=u.distribute(a),c.map(function(e,n){e.forEach(function(t){t.layerIndex=n;}),r.removeOverlap&&o(e,t);}),e},e.start=function(){console.log("[warning] force.start() is deprecated. Please use force.compute() instead.");},e};u.DEFAULT_OPTIONS=s,t.exports=u;},function(t,e,r){var n=r(4),i=r(6),o={algorithm:"overlap",layerWidth:1e3,density:.75,nodeSpacing:3,stubWidth:1},s=function(t){var e={};t=n.extend({},o,t),e.options=function(r){return arguments.length?(t=n.extend(t,r),e):t},e.computeRequiredWidth=function(e){return n.sum(e,function(e){return e.width+t.nodeSpacing})-t.nodeSpacing},e.maxWidthPerLayer=function(){return t.density*t.layerWidth},e.needToSplit=function(t){return e.estimateRequiredLayers(t)>1},e.estimateRequiredLayers=function(r){return t.layerWidth?Math.ceil(e.computeRequiredWidth(r)/e.maxWidthPerLayer()):1};var r={simple:function(r){for(var n=e.estimateRequiredLayers(r),i=[],o=0;o<n;o++)i.push([]);return r.forEach(function(e,r){var o=r%n;i[o].push(e);for(var s=e,u=o-1;u>=0;u--)s=s.createStub(t.stubWidth),i[u].push(s);}),i},roundRobin:function(t){var e=[];return e},overlap:function(r){for(var n=[],i=e.maxWidthPerLayer(),o=r.concat(),s=e.computeRequiredWidth(o);s>i;){e.countIdealOverlaps(o);var u=o.concat(),a=s;for(o=[];u.length>2&&a>i;){u.sort(function(t,e){return e.overlapCount-t.overlapCount});var c=u.shift();a-=c.width,a+=t.stubWidth,c.overlaps.forEach(function(t){t.overlapCount--;}),o.push(c);}n.push(u),s=e.computeRequiredWidth(o);}o.length>0&&n.push(o);for(var h=n.length-1;h>=1;h--)for(var l=n[h],f=0;f<l.length;f++){var p=l[f];if(!p.isStub())for(var d=p,v=h-1;v>=0;v--)d=d.createStub(t.stubWidth),n[v].push(d);}return n}};return e.countIdealOverlaps=function(e){var r=new i(t.layerWidth/2);return e.forEach(function(t){r.add([t.idealLeft(),t.idealRight(),t]);}),e.forEach(function(t){var e=r.search(t.idealLeft(),t.idealRight());t.overlaps=e.map(function(t){return t.data[2]}),t.overlapCount=e.length;}),e},e.distribute=function(i){if(!i||0===i.length)return [];if("none"==t.algorithm||!n.isDefined(t.algorithm))return [i];if(!e.needToSplit(i))return [i];var o=i.concat().sort(function(t,e){return t.idealPos-e.idealPos});if("function"==typeof t.algorithm)return t.algorithm(o,t);if(r.hasOwnProperty(t.algorithm))return r[t.algorithm](o);throw "Unknown algorithm: "+t.algorithm},e};s.DEFAULT_OPTIONS=o,t.exports=s;},function(t,e,r){var n={isDefined:function(t){return null!==t&&void 0!==t},last:function(t){return t.length>0?t[t.length-1]:null},pick:function(t,e){return e.reduce(function(e,r){return e[r]=t[r],e},{})},sum:function(t,e){return t.map(e).reduce(function(t,e){return t+e},0)}};n.extend=r(5),t.exports=n;},function(t,e){var r="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},n=Object.prototype.hasOwnProperty,i=Object.prototype.toString,o=function(t){return "function"==typeof Array.isArray?Array.isArray(t):"[object Array]"===i.call(t)},s=function(t){if(!t||"[object Object]"!==i.call(t))return !1;var e=n.call(t,"constructor"),r=t.constructor&&t.constructor.prototype&&n.call(t.constructor.prototype,"isPrototypeOf");if(t.constructor&&!e&&!r)return !1;var o;for(o in t);return void 0===o||n.call(t,o)};t.exports=function u(){var t,e,n,i,a,c,h=arguments[0],l=1,f=arguments.length,p=!1;for("boolean"==typeof h?(p=h,h=arguments[1]||{},l=2):("object"!==("undefined"==typeof h?"undefined":r(h))&&"function"!=typeof h||null==h)&&(h={});l<f;++l)if(t=arguments[l],null!=t)for(e in t)n=h[e],i=t[e],h!==i&&(p&&i&&(s(i)||(a=o(i)))?(a?(a=!1,c=n&&o(n)?n:[]):c=n&&s(n)?n:{},h[e]=u(p,c,i)):void 0!==i&&(h[e]=i));return h};},function(t,e,r){function n(t,e){if(e||(e={}),this.startKey=e.startKey||0,this.endKey=e.endKey||1,this.intervalHash={},this.pointTree=new c({compare:function(t,e){if(null==t)return -1;if(null==e)return 1;var r=t[0]-e[0];return r>0?1:0==r?0:-1}}),this._autoIncrement=0,!t||"number"!=typeof t)throw new Error("you must specify center index as the 2nd argument.");this.root=new u(t,this);}function i(t,e){return e.end<t.idx?(t.left||(t.left=new u(e.start+e.end>>1,this)),i.call(this,t.left,e)):t.idx<e.start?(t.right||(t.right=new u(e.start+e.end>>1,this)),i.call(this,t.right,e)):t.insert(e)}function o(t,e,r){if(t)return e<t.idx?(t.starts.every(function(t){var n=t.start<=e;return n&&r.push(t.result()),n}),o.call(this,t.left,e,r)):e>t.idx?(t.ends.every(function(t){var n=t.end>=e;return n&&r.push(t.result()),n}),o.call(this,t.right,e,r)):void t.starts.map(function(t){r.push(t.result());})}function s(t,e,r){if(e-t<=0)throw new Error("end must be greater than start. start: "+t+", end: "+e);var n={},i=[];o.call(this,this.root,t+e>>1,i,!0),i.forEach(function(t){n[t.id]=!0;});for(var s=this.pointTree.bsearch([t,null]),u=this.pointTree;s>=0&&u[s][0]==t;)s--;var a=this.pointTree.bsearch([e,null]);if(a>=0){for(var c=u.length-1;a<=c&&u[a][0]<=e;)a++;u.slice(s+1,a).forEach(function(t){var e=t[1];n[e]=!0;},this),Object.keys(n).forEach(function(n){var i=this.intervalHash[n];r.push(i.result(t,e));},this);}}function u(t){this.idx=t,this.starts=new c({compare:function(t,e){if(null==t)return -1;if(null==e)return 1;var r=t.start-e.start;return r>0?1:0==r?0:-1}}),this.ends=new c({compare:function(t,e){if(null==t)return -1;if(null==e)return 1;var r=t.end-e.end;return r<0?1:0==r?0:-1}});}function a(t,e,r,n){if(this.id=e,this.start=t[r],this.end=t[n],this.data=t,"number"!=typeof this.start||"number"!=typeof this.end)throw new Error("start, end must be number. start: "+this.start+", end: "+this.end);if(this.start>=this.end)throw new Error("start must be smaller than end. start: "+this.start+", end: "+this.end)}var c=r(7);n.prototype.add=function(t,e){if(this.intervalHash[e])throw new Error("id "+e+" is already registered.");if(void 0==e){for(;this.intervalHash[this._autoIncrement];)this._autoIncrement++;e=this._autoIncrement;}var r=new a(t,e,this.startKey,this.endKey);this.pointTree.insert([r.start,e]),this.pointTree.insert([r.end,e]),this.intervalHash[e]=r,this._autoIncrement++,i.call(this,this.root,r);},n.prototype.search=function(t,e){var r=[];if("number"!=typeof t)throw new Error(t+": invalid input");if(void 0==e)o.call(this,this.root,t,r);else{if("number"!=typeof e)throw new Error(t+","+e+": invalid input");s.call(this,t,e,r);}return r},n.prototype.remove=function(t){},u.prototype.insert=function(t){this.starts.insert(t),this.ends.insert(t);},a.prototype.result=function(t,e){var r={id:this.id,data:this.data};if("number"==typeof t&&"number"==typeof e){var n=Math.max(this.start,t),i=Math.min(this.end,e),o=i-n;r.rate1=o/(e-t),r.rate2=o/(this.end-this.start);}return r},t.exports=n;},function(t,e){var r="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},n=function i(){var t=null,e={},n=arguments;["0","1"].forEach(function(i){var o=n[i];Array.isArray(o)?t=o:o&&"object"==("undefined"==typeof o?"undefined":r(o))&&(e=o);}),"function"==typeof e.filter&&(this._filter=e.filter),"function"==typeof e.compare?this._compare=e.compare:"string"==typeof e.compare&&i.compares[e.compare]&&(this._compare=i.compares[e.compare]),this._unique=!!e.unique,e.resume&&t?t.forEach(function(t,e){this.push(t);},this):t&&this.insert.apply(this,t);};n.create=function(t,e){return new n(t,e)},n.prototype=new Array,n.prototype.constructor=Array.prototype.constructor,n.prototype.insertOne=function(t){var e=this.bsearch(t);return (!this._unique||null==this.key(t,e))&&(!!this._filter(t,e)&&(this.splice(e+1,0,t),e+1))},n.prototype.insert=function(){return Array.prototype.map.call(arguments,function(t){return this.insertOne(t)},this)},n.prototype.remove=function(t){return this.splice(t,1),this},n.prototype.bsearch=function(t){if(!this.length)return -1;for(var e,r=0,n=this.length;n-r>1;){e=Math.floor((r+n)/2);var i=this[e],o=this._compare(t,i);if(0==o)return e;o>0?r=e:n=e;}return 0==r&&this._compare(this[0],t)>0?-1:r},n.prototype.key=function(t,e){null==e&&(e=this.bsearch(t));var r=e;if(r==-1||this._compare(this[r],t)<0)return r+1<this.length&&0==this._compare(this[r+1],t)?r+1:null;for(;r>=1&&0==this._compare(this[r-1],t);)r--;return r},n.prototype.keys=function(t,e){var r=[];null==e&&(e=this.bsearch(t));for(var n=e;n>=0&&0==this._compare(this[n],t);)r.push(n),n--;var i=this.length;for(n=e+1;n<i&&0==this._compare(this[n],t);)r.push(n),n++;return r.length?r:null},n.prototype.unique=function(t){if(t)return this.filter(function(t,e){return 0==e||0!=this._compare(this[e-1],t)},this);var e=0;return this.map(function(t,r){return 0==r||0!=this._compare(this[r-1],t)?null:r-e++},this).forEach(function(t){null!=t&&this.remove(t);},this),this},n.prototype.toArray=function(){return this.slice()},n.prototype._filter=function(t,e){return !0},n.compares={number:function(t,e){var r=t-e;return r>0?1:0==r?0:-1},string:function(t,e){return t>e?1:t==e?0:-1}},n.prototype._compare=n.compares.string,t.exports=n;},function(t,e,r){function n(t){var e=new s.Variable(t.targetPos);return e.node=t,e}function i(t,e){if(t.length>0){e=o.extend(u,e),t.forEach(function(t,e){t.targetPos=t.parent?t.parent.currentPos:t.idealPos,t.index=e;});for(var r=t.concat().sort(function(t,e){var r=t.targetPos-e.targetPos;if(0!==r)return r;var n=t.isStub()-e.isStub();return 0!==n?n:t.index-e.HospitalFacilities}).map(n),i=[],a=1; a<r.length; a++){var c=r[a-1],h=r[a],l=void 0;l=c.node.isStub()&&h.node.isStub()?(c.node.width+h.node.width)/2+e.lineSpacing:(c.node.width+h.node.width)/2+e.nodeSpacing,i.push(new s.Constraint(c,h,l));}if(o.isDefined(e.minPos)){var f=new s.Variable(e.minPos,1e10),p=r[0];i.push(new s.Constraint(f,p,p.node.width/2)),r.unshift(f);}if(o.isDefined(e.maxPos)){var d=new s.Variable(e.maxPos,1e10),v=o.last(r);i.push(new s.Constraint(v,d,v.node.width/2)),r.push(d);}new s.Solver(r,i).solve(),r.filter(function(t){return t.node}).map(function(t){return t.node.currentPos=Math.round(t.position()),t});}return t}var o=r(4),s=r(9),u={lineSpacing:2,nodeSpacing:3,minPos:0,maxPos:null};i.DEFAULT_OPTIONS=u,t.exports=i;},function(t,e){var r={},n=function(){function t(t){this.scale=t,this.AB=0,this.AD=0,this.A2=0;}return t.prototype.addVariable=function(t){var e=this.scale/t.scale,r=t.offset/t.scale,n=t.weight;this.AB+=n*e*r,this.AD+=n*e*t.desiredPosition,this.A2+=n*e*e;},t.prototype.getPosn=function(){return (this.AD-this.AB)/this.A2},t}();r.PositionStats=n;var i=function(){function t(t,e,r,n){void 0===n&&(n=!1),this.left=t,this.right=e,this.gap=r,this.equality=n,this.active=!1,this.unsatisfiable=!1,this.left=t,this.right=e,this.gap=r,this.equality=n;}return t.prototype.slack=function(){return this.unsatisfiable?Number.MAX_VALUE:this.right.scale*this.right.position()-this.gap-this.left.scale*this.left.position()},t}();r.Constraint=i;var o=function(){function t(t,e,r){void 0===e&&(e=1),void 0===r&&(r=1),this.desiredPosition=t,this.weight=e,this.scale=r,this.offset=0;}return t.prototype.dfdv=function(){return 2*this.weight*(this.position()-this.desiredPosition)},t.prototype.position=function(){return (this.block.ps.scale*this.block.posn+this.offset)/this.scale},t.prototype.visitNeighbours=function(t,e){var r=function(r,n){return r.active&&t!==n&&e(r,n)};this.cOut.forEach(function(t){return r(t,t.right)}),this.cIn.forEach(function(t){return r(t,t.left)});},t}();r.Variable=o;var s=function(){function t(t){this.vars=[],t.offset=0,this.ps=new n(t.scale),this.addVariable(t);}return t.prototype.addVariable=function(t){t.block=this,this.vars.push(t),this.ps.addVariable(t),this.posn=this.ps.getPosn();},t.prototype.updateWeightedPosition=function(){this.ps.AB=this.ps.AD=this.ps.A2=0;for(var t=0,e=this.vars.length;t<e;++t)this.ps.addVariable(this.vars[t]);this.posn=this.ps.getPosn();},t.prototype.compute_lm=function(t,e,r){var n=this,i=t.dfdv();return t.visitNeighbours(e,function(e,o){var s=n.compute_lm(o,t,r);o===e.right?(i+=s*e.left.scale,e.lm=s):(i+=s*e.right.scale,e.lm=-s),r(e);}),i/t.scale},t.prototype.populateSplitBlock=function(t,e){var r=this;t.visitNeighbours(e,function(e,n){n.offset=t.offset+(n===e.right?e.gap:-e.gap),r.addVariable(n),r.populateSplitBlock(n,t);});},t.prototype.traverse=function(t,e,r,n){var i=this;void 0===r&&(r=this.vars[0]),void 0===n&&(n=null),r.visitNeighbours(n,function(n,o){e.push(t(n)),i.traverse(t,e,o,r);});},t.prototype.findMinLM=function(){var t=null;return this.compute_lm(this.vars[0],null,function(e){!e.equality&&(null===t||e.lm<t.lm)&&(t=e);}),t},t.prototype.findMinLMBetween=function(t,e){this.compute_lm(t,null,function(){});var r=null;return this.findPath(t,null,e,function(t,e){!t.equality&&t.right===e&&(null===r||t.lm<r.lm)&&(r=t);}),r},t.prototype.findPath=function(t,e,r,n){var i=this,o=!1;return t.visitNeighbours(e,function(e,s){o||s!==r&&!i.findPath(s,t,r,n)||(o=!0,n(e,s));}),o},t.prototype.isActiveDirectedPathBetween=function(t,e){if(t===e)return !0;for(var r=t.cOut.length;r--;){var n=t.cOut[r];if(n.active&&this.isActiveDirectedPathBetween(n.right,e))return !0}return !1},t.split=function(e){return e.active=!1,[t.createSplitBlock(e.left),t.createSplitBlock(e.right)]},t.createSplitBlock=function(e){var r=new t(e);return r.populateSplitBlock(e,null),r},t.prototype.splitBetween=function(e,r){var n=this.findMinLMBetween(e,r);if(null!==n){var i=t.split(n);return {constraint:n,lb:i[0],rb:i[1]}}return null},t.prototype.mergeAcross=function(t,e,r){e.active=!0;for(var n=0,i=t.vars.length;n<i;++n){var o=t.vars[n];o.offset+=r,this.addVariable(o);}this.posn=this.ps.getPosn();},t.prototype.cost=function(){for(var t=0,e=this.vars.length;e--;){var r=this.vars[e],n=r.position()-r.desiredPosition;t+=n*n*r.weight;}return t},t}();r.Block=s;var u=function(){function t(t){this.vs=t;var e=t.length;for(this.list=new Array(e);e--;){var r=new s(t[e]);this.list[e]=r,r.blockInd=e;}}return t.prototype.cost=function(){for(var t=0,e=this.list.length;e--;)t+=this.list[e].cost();return t},t.prototype.insert=function(t){t.blockInd=this.list.length,this.list.push(t);},t.prototype.remove=function(t){var e=this.list.length-1,r=this.list[e];this.list.length=e,t!==r&&(this.list[t.blockInd]=r,r.blockInd=t.blockInd);},t.prototype.merge=function(t){var e=t.left.block,r=t.right.block,n=t.right.offset-t.left.offset-t.gap;e.vars.length<r.vars.length?(r.mergeAcross(e,t,n),this.remove(e)):(e.mergeAcross(r,t,-n),this.remove(r));},t.prototype.forEach=function(t){this.list.forEach(t);},t.prototype.updateBlockPositions=function(){this.list.forEach(function(t){return t.updateWeightedPosition()});},t.prototype.split=function(t){var e=this;this.updateBlockPositions(),this.list.forEach(function(r){var n=r.findMinLM();null!==n&&n.lm<a.LAGRANGIAN_TOLERANCE&&(r=n.left.block,s.split(n).forEach(function(t){return e.insert(t)}),e.remove(r),t.push(n));});},t}();r.Blocks=u;var a=function(){function t(t,e){this.vs=t,this.cs=e,this.vs=t,t.forEach(function(t){t.cIn=[],t.cOut=[];}),this.cs=e,e.forEach(function(t){t.left.cOut.push(t),t.right.cIn.push(t);}),this.inactive=e.map(function(t){return t.active=!1,t}),this.bs=null;}return t.prototype.cost=function(){return this.bs.cost()},t.prototype.setStartingPositions=function(t){this.inactive=this.cs.map(function(t){return t.active=!1,t}),this.bs=new u(this.vs),this.bs.forEach(function(e,r){return e.posn=t[r]});},t.prototype.setDesiredPositions=function(t){this.vs.forEach(function(e,r){return e.desiredPosition=t[r]});},t.prototype.mostViolated=function(){for(var e=Number.MAX_VALUE,r=null,n=this.inactive,i=n.length,o=i,s=0;s<i;++s){var u=n[s];if(!u.unsatisfiable){var a=u.slack();if((u.equality||a<e)&&(e=a,r=u,o=s,u.equality))break}}return o!==i&&(e<t.ZERO_UPPERBOUND&&!r.active||r.equality)&&(n[o]=n[i-1],n.length=i-1),r},t.prototype.satisfy=function(){null==this.bs&&(this.bs=new u(this.vs)),this.bs.split(this.inactive);for(var e=null;(e=this.mostViolated())&&(e.equality||e.slack()<t.ZERO_UPPERBOUND&&!e.active);){var r=e.left.block,n=e.right.block;if(r!==n)this.bs.merge(e);else{if(r.isActiveDirectedPathBetween(e.right,e.left)){e.unsatisfiable=!0;continue}var i=r.splitBetween(e.left,e.right);if(null===i){e.unsatisfiable=!0;continue}this.bs.insert(i.lb),this.bs.insert(i.rb),this.bs.remove(r),this.inactive.push(i.constraint),e.slack()>=0?this.inactive.push(e):this.bs.merge(e);}}},t.prototype.solve=function(){this.satisfy();for(var t=Number.MAX_VALUE,e=this.bs.cost();Math.abs(t-e)>1e-4;)this.satisfy(),t=e,e=this.bs.cost();return e},t.LAGRANGIAN_TOLERANCE=-1e-4,t.ZERO_UPPERBOUND=-1e-10,t}();r.Solver=a,t.exports=r;},function(t,e,r){function n(t){this.options=c.extend({layerGap:60,nodeHeight:10,direction:"down"},t);}function i(t){return "L "+t.join(" ")}function o(t){return "M "+t.join(" ")}function s(t,e,r){return "C "+t.join(" ")+" "+e.join(" ")+" "+r.join(" ")}function u(t,e){var r=(t[1]+e[1])/2;return s([t[0],r],[e[0],r],e)}function a(t,e){var r=(t[0]+e[0])/2;return s([r,t[1]],[r,e[1]],e)}var c=r(4);n.lineTo=i,n.moveTo=o,n.curveTo=s,n.vCurveBetween=u,n.hCurveBetween=a,n.prototype.getWaypoints=function(t){var e=this.options,r=e.direction,n=t.getPathFromRoot(),i=e.nodeHeight+e.layerGap;return "left"===r?[[[0,n[0].idealPos]]].concat(n.map(function(t,r){var n=i*(r+1)*-1;return [[n+e.nodeHeight,t.currentPos],[n,t.currentPos]]})):"right"===r?[[[0,n[0].idealPos]]].concat(n.map(function(t,r){var n=i*(r+1);return [[n-e.nodeHeight,t.currentPos],[n,t.currentPos]]})):"up"===r?[[[n[0].idealPos,0]]].concat(n.map(function(t,r){var n=i*(r+1)*-1;return [[t.currentPos,n+e.nodeHeight],[t.currentPos,n]]})):[[[n[0].idealPos,0]]].concat(n.map(function(t,r){var n=i*(r+1);return [[t.currentPos,n-e.nodeHeight],[t.currentPos,n]]}))},n.prototype.layout=function(t){var e=this.options,r=e.layerGap+e.nodeHeight;switch(e.direction){case"left":t.forEach(function(t){var n=t.getLayerIndex()*r+e.layerGap;t.x=-n-e.nodeHeight,t.y=t.currentPos,t.dx=e.nodeHeight,t.dy=t.width;});break;case"right":t.forEach(function(t){var n=t.getLayerIndex()*r+e.layerGap;t.x=n,t.y=t.currentPos,t.dx=e.nodeHeight,t.dy=t.width;});break;case"up":t.forEach(function(t){var n=t.getLayerIndex()*r+e.layerGap;t.x=t.currentPos,t.y=-n-e.nodeHeight,t.dx=t.width,t.dy=e.nodeHeight;});break;default:case"down":t.forEach(function(t){var n=t.getLayerIndex()*r+e.layerGap;t.x=t.currentPos,t.y=n,t.dx=t.width,t.dy=e.nodeHeight;});}return t},n.prototype.generatePath=function(t){var e=this.options,r=e.direction,n=this.getWaypoints(t,r),s=[o(n[0][0])];return "left"===r||"right"===r?n.reduce(function(t,e,r){return s.push(a(t[t.length-1],e[0])),r<n.length-1&&s.push(i(e[1])),e}):n.reduce(function(t,e,r){return s.push(u(t[t.length-1],e[0])),r<n.length-1&&s.push(i(e[1])),e}),s.join(" ")},t.exports=n;}])});
});
var labella_min_1 = labella_min.labella;

const marginOffsetFn = (orient, axisSettings, marginOffset) => {
  if (typeof marginOffset === 'number') {
    return marginOffset;
  }

  if (axisSettings && axisSettings.find(d => d.props.orient === orient)) {
    return 50;
  }

  return 10;
};

const noteDataWidth = (noteData, charWidth = 8) => {
  const wrap = noteData.note && noteData.note.wrap || 120;
  const noteText = noteData.note.label || noteData.note.label || '';
  return Math.min(wrap, noteText.length * charWidth);
};

const noteDataHeight = (noteData, charWidth = 8, lineHeight = 20) => {
  const wrap = noteData.note && noteData.note.wrap || 120;
  const text = noteData.note.label || noteData.note.title || '';
  return Math.ceil(text.length * charWidth / wrap) * lineHeight + (noteData.note.label && noteData.note.title ? lineHeight : 0);
};

const processAnnotations = (adjustableAnnotations, annotationProcessor, props) => {
  const {
    layout = {
      type: false
    }
  } = annotationProcessor;

  if (layout.type === false) {
    return adjustableAnnotations;
  }

  let {
    margin = {
      top: 0,
      bottom: 0,
      left: 0,
      right: 0
    }
  } = props;
  const {
    size,
    axes = []
  } = props;
  margin = typeof margin === 'number' ? {
    top: margin,
    left: margin,
    right: margin,
    bottom: margin
  } : margin;

  if (layout.type === 'bump') {
    return bumpAnnotations(adjustableAnnotations, layout, size, props.pointSizeFunction, props.labelSizeFunction);
  } else if (layout.type === 'marginalia') {
    const {
      marginOffset,
      orient = 'nearest',
      characterWidth = 8,
      lineHeight = 20,
      padding = 2,
      axisMarginOverride = {}
    } = layout;
    const finalOrientation = orient === 'nearest' ? ['left', 'right', 'top', 'bottom'] : Array.isArray(orient) ? orient : [orient];
    const leftOn = finalOrientation.find(d => d === 'left');
    const rightOn = finalOrientation.find(d => d === 'right');
    const topOn = finalOrientation.find(d => d === 'top');
    const bottomOn = finalOrientation.find(d => d === 'bottom');
    const leftNodes = [];
    const rightNodes = [];
    const topNodes = [];
    const bottomNodes = [];
    adjustableAnnotations.forEach(aNote => {
      const noteData = aNote.props.noteData;
      const noteX = noteData.x[0] || noteData.x;
      const noteY = noteData.y[0] || noteData.y;
      const leftDist = leftOn ? noteX : Infinity;
      const rightDist = rightOn ? size[0] - noteX : Infinity;
      const topDist = topOn ? noteY : Infinity;
      const bottomDist = bottomOn ? size[1] - noteY : Infinity;
      const minDist = Math.min(leftDist, rightDist, topDist, bottomDist);

      if (leftDist === minDist) {
        leftNodes.push(aNote);
      } else if (rightDist === minDist) {
        rightNodes.push(aNote);
      } else if (topDist === minDist) {
        topNodes.push(aNote);
      } else {
        bottomNodes.push(aNote);
      }
    }); //Adjust the margins based on which regions are active

    const leftForce = new undefined({
      minPos: axisMarginOverride.top !== undefined ? 0 + axisMarginOverride.top : 0 - margin.top,
      maxPos: axisMarginOverride.bottom !== undefined ? size[1] - axisMarginOverride.bottom : bottomOn ? size[1] : size[1] + margin.bottom
    }).nodes(leftNodes.map(d => {
      const noteY = d.props.noteData.y[0] || d.props.noteData.y;
      return new undefined(noteY, noteDataHeight(d.props.noteData, characterWidth, lineHeight) + padding);
    })).compute();
    const rightForce = new undefined({
      minPos: axisMarginOverride.top !== undefined ? 0 + axisMarginOverride.top : topOn ? 0 : 0 - margin.top,
      maxPos: axisMarginOverride.bottom !== undefined ? size[1] - axisMarginOverride.bottom : size[1] + margin.bottom
    }).nodes(rightNodes.map(d => {
      const noteY = d.props.noteData.y[0] || d.props.noteData.y;
      return new undefined(noteY, noteDataHeight(d.props.noteData, characterWidth, lineHeight) + padding);
    })).compute();
    const topForce = new undefined({
      minPos: axisMarginOverride.left !== undefined ? 0 + axisMarginOverride.left : leftOn ? 0 : 0 - margin.left,
      maxPos: axisMarginOverride.right !== undefined ? size[0] - axisMarginOverride.right : size[0] + margin.right
    }).nodes(topNodes.map(d => {
      const noteX = d.props.noteData.x[0] || d.props.noteData.x;
      return new undefined(noteX, noteDataWidth(d.props.noteData, characterWidth) + padding);
    })).compute();
    const bottomForce = new undefined({
      minPos: axisMarginOverride.left !== undefined ? 0 + axisMarginOverride.left : 0 - margin.left,
      maxPos: axisMarginOverride.right !== undefined ? size[0] - axisMarginOverride.right : rightOn ? size[0] : size[0] + margin.right
    }).nodes(bottomNodes.map(d => {
      const noteX = d.props.noteData.x[0] || d.props.noteData.x;
      return new undefined(noteX, noteDataWidth(d.props.noteData, characterWidth) + padding);
    })).compute();
    const bottomOffset = Math.max(...bottomNodes.map(d => noteDataHeight(d.props.noteData, characterWidth, lineHeight) + padding));
    const topOffset = Math.max(...topNodes.map(d => noteDataHeight(d.props.noteData, characterWidth, lineHeight) + padding));
    const leftOffset = Math.max(...leftNodes.map(d => noteDataWidth(d.props.noteData, characterWidth) + padding));
    const rightOffset = Math.max(...rightNodes.map(d => noteDataWidth(d.props.noteData, characterWidth) + padding)); //      const nodeOffsetHeight = Math.max()

    const leftSortedNodes = leftForce.nodes();
    const rightSortedNodes = rightForce.nodes();
    const topSortedNodes = topForce.nodes();
    const bottomSortedNodes = bottomForce.nodes();
    leftNodes.forEach((note, i) => {
      note.props.noteData.ny = leftSortedNodes[i].currentPos;
      note.props.noteData.nx = 0 - leftSortedNodes[i].layerIndex * leftOffset - marginOffsetFn('left', axes, marginOffset);

      if (note.props.noteData.note) {
        note.props.noteData.note.orientation = note.props.noteData.note.orientation || 'leftRight';
        note.props.noteData.note.align = note.props.noteData.note.align || 'right';
      }
    });
    rightNodes.forEach((note, i) => {
      note.props.noteData.ny = rightSortedNodes[i].currentPos;
      note.props.noteData.nx = size[0] + rightSortedNodes[i].layerIndex * rightOffset + marginOffsetFn('right', axes, marginOffset);

      if (note.props.noteData.note) {
        note.props.noteData.note.orientation = note.props.noteData.note.orientation || 'leftRight';
        note.props.noteData.note.align = note.props.noteData.note.align || 'left';
      }
    });
    topNodes.forEach((note, i) => {
      note.props.noteData.nx = topSortedNodes[i].currentPos;
      note.props.noteData.ny = 0 - topSortedNodes[i].layerIndex * topOffset - marginOffsetFn('top', axes, marginOffset);
    });
    bottomNodes.forEach((note, i) => {
      note.props.noteData.nx = bottomSortedNodes[i].currentPos;
      note.props.noteData.ny = size[1] + bottomSortedNodes[i].layerIndex * bottomOffset + marginOffsetFn('bottom', axes, marginOffset);
    });
    return adjustableAnnotations;
  }

  return adjustableAnnotations;
};

const adjustedAnnotationKeyMapper = d => {
  const {
    note = {}
  } = d.props.noteData;
  const {
    label
  } = note;
  const id = d.props.noteData.id || `${d.props.noteData.x}-${d.props.noteData.y}`;
  return `${id}-${label}`;
};

const AnnotationLayer = props => {
  const [svgAnnotations, setSvgAnnotations] = React$1.useState([]);
  const [htmlAnnotations, setHtmlAnnotations] = React$1.useState([]);
  const [adjustedAnnotations, setAdjustedAnnotations] = React$1.useState([]);
  const [adjustedAnnotationsKey, setAdjustedAnnotationsKey] = React$1.useState('');

  const createAnnotations = props => {
    let newAdjustedAnnotations = adjustedAnnotations.slice();
    let newAdjustableAnnotationsKey = adjustedAnnotationsKey;
    const newAdjustedAnnotationsKey = adjustedAnnotationsKey;
    const {
      annotations,
      annotationHandling = false,
      size,
      generateSVGAnnotations,
      generateHTMLAnnotations,
      voronoiHover
    } = props;
    const annotationProcessor = typeof annotationHandling === 'object' ? annotationHandling : {
      layout: {
        type: annotationHandling
      }
    }; // todo: create svg anno

    const initialSVGAnnotations = annotations.map((d, i) => generateSVGAnnotations({
      d,
      i,
      voronoiHover
    })).filter(d => d);
    const adjustableAnnotations = initialSVGAnnotations.filter(d => d && d.props && d.props.noteData && !d.props.noteData.fixedPosition);
    const fixedAnnotations = initialSVGAnnotations.filter(d => !d.props || !d.props.noteData || d.props.noteData.fixedPosition);
    newAdjustableAnnotationsKey = `${adjustableAnnotations.map(adjustedAnnotationKeyMapper).join(',')}${JSON.stringify(annotationProcessor)}${size.join(',')}`;

    if (annotationHandling === false) {
      newAdjustedAnnotations = adjustableAnnotations;
    }

    if (newAdjustedAnnotations.length !== adjustableAnnotations.length || newAdjustedAnnotationsKey !== newAdjustableAnnotationsKey) {
      newAdjustedAnnotations = processAnnotations(adjustableAnnotations, annotationProcessor, props);
    } else {
      //Handle when style or other attributes change
      newAdjustedAnnotations = newAdjustedAnnotations.map((d, i) => {
        const newNoteData = Object.assign(adjustableAnnotations[i].props.noteData, {
          nx: d.props.noteData.nx,
          ny: d.props.noteData.ny,
          note: d.props.noteData.note
        });
        return React$1__default.createElement(Annotation, {
          key: d.key,
          noteData: newNoteData
        });
      });
    }

    const renderedSVGAnnotations = [...newAdjustedAnnotations, ...fixedAnnotations];
    const renderedHTMLAnnotations = annotations.map((d, i) => generateHTMLAnnotations({
      d,
      i,
      voronoiHover
    }));
    setAdjustedAnnotations(newAdjustedAnnotations);
    setSvgAnnotations(renderedSVGAnnotations);
    setHtmlAnnotations(renderedHTMLAnnotations);
    setAdjustedAnnotationsKey(newAdjustableAnnotationsKey);
  };

  const {
    voronoiHover,
    frameData,
    frameProps
  } = props;
  React$1.useEffect(() => {
    createAnnotations(props);
  }, [voronoiHover, frameData, frameProps]);
  const {
    useSpans,
    size,
    margin
  } = props;
  return React$1__default.createElement(SpanOrDiv, {
    span: useSpans,
    className: "annotation-layer",
    style: {
      position: 'absolute',
      pointerEvents: 'none',
      background: 'none'
    }
  }, React$1__default.createElement("svg", {
    className: "annotation-layer-svg",
    height: size[1],
    width: size[0],
    style: {
      background: 'none',
      pointerEvents: 'none',
      position: 'absolute',
      left: `${margin.left}px`,
      top: `${margin.top}px`,
      overflow: 'visible'
    }
  }, React$1__default.createElement("g", null, svgAnnotations)), React$1__default.createElement(SpanOrDiv, {
    span: useSpans,
    className: "annotation-layer-html",
    style: {
      background: 'none',
      pointerEvents: 'none',
      position: 'absolute',
      height: `${size[1]}px`,
      width: `${size[0]}px`,
      left: `${margin.left}px`,
      top: `${margin.top}px`
    }
  }, htmlAnnotations));
};

AnnotationLayer.propTypes = {
  margin: propTypes.object,
  voronoiHover: propTypes.oneOfType([propTypes.array, propTypes.object]),
  useSpans: propTypes.bool,
  size: propTypes.array,
  axes: propTypes.array,
  annotationHandling: propTypes.func,
  annotations: propTypes.array,
  pointSizeFunction: propTypes.func,
  labelSizeFunction: propTypes.func,
  position: propTypes.array,
  generateSVGAnnotations: propTypes.func,
  generateHTMLAnnotations: propTypes.func,
  frameData: propTypes.object,
  frameProps: propTypes.object
};
AnnotationLayer.defaultProps = {
  margin: {
    top: 0,
    bottom: 0,
    left: 0,
    right: 0
  },
  generateSVGAnnotations: () => [],
  generateHTMLAnnotations: () => []
};

const getCanvasScale = context => {
  const devicePixelRatio = window.devicePixelRatio || 1;
  const backingStoreRatio = context.webkitBackingStorePixelRatio || context.mozBackingStorePixelRatio || context.msBackingStorePixelRatio || context.oBackingStorePixelRatio || context.backingStorePixelRatio || 1;
  return devicePixelRatio / backingStoreRatio;
};

const Frame = props => {
  const frontCanvasRef = React$1.useRef(null);
  const backCanvasRef = React$1.useRef(null);
  const [frontCanvas, setFrontCanvas] = React$1.useState(null);
  const [backCanvas, setBackCanvas] = React$1.useState(null);
  const [voronoiHover, setVoronoiHover] = React$1.useState(null);

  const updateCanvas = () => {
    if (frontCanvasRef && frontCanvasRef.current) {
      const _frontContext = frontCanvasRef.current.getContext('2d');

      const canvasScale = getCanvasScale(_frontContext);

      _frontContext.scale(canvasScale, canvasScale);

      setFrontCanvas(frontCanvasRef.current);
    }

    if (backCanvasRef && backCanvasRef.current) {
      const _backContext = backCanvasRef.current.getContext('2d');

      _backContext.mozImageSmoothingEnabled = false;
      _backContext.webkitImageSmoothingEnabled = false;
      _backContext.msImageSmoothingEnabled = false;
      _backContext.imageSmoothingEnabled = false;
      const canvasScale = getCanvasScale(_backContext);

      _backContext.scale(canvasScale, canvasScale);

      setBackCanvas(backCanvasRef.current);
    }
  };

  React$1.useEffect(() => {
    updateCanvas();
  }, []);
  const {
    // routine
    name,
    className,
    frameKey,
    useSpans,
    matte,
    width,
    height,
    margin,
    title,
    // render as it is
    foregroundGraphics,
    backgroundGraphics,
    additionalDefs,
    beforeElements,
    afterElements,
    canvasPostProcess,
    // generated
    frameXScale,
    frameYScale,
    canvasPipeline,
    svgPipeline,
    screenCoordinates,
    xyPoints,
    adjustedPosition,
    adjustedSize,
    // interaction
    overlay,
    interactionOverflow,
    disableCanvasInteraction,
    hoverAnnotation,
    interaction,
    customClickBehavior,
    customHoverBehavior,
    customDoubleClickBehavior,
    // children
    children,
    //todo: remove
    oLabels,
    axes,
    axesTickLines
  } = props;
  const size = [width, height];
  const devicePixelRatio = window.devicePixelRatio || 1;
  const finalBackgroundGraphics = typeof backgroundGraphics === 'function' ? backgroundGraphics({
    size,
    margin
  }) : backgroundGraphics;
  const finalForegroundGraphics = typeof foregroundGraphics === 'function' ? foregroundGraphics({
    size,
    margin
  }) : foregroundGraphics;
  const userTitle = typeof title === 'object' && !React$1__default.isValidElement(title) && title !== null ? title : {
    title,
    orient: 'top'
  };
  const generatedTitle = generateFrameTitle({
    title: userTitle,
    size
  }); //todo: remove

  const marginGraphic = toMarginGraphic({
    matte,
    size,
    margin,
    name
  });
  const annotations = React$1__default.Children.toArray(children).filter(d => d.type.name === 'Annotation').map(d => d.props);

  if (voronoiHover) {
    if (Array.isArray(voronoiHover)) {
      annotations.push(...voronoiHover);
    } else {
      annotations.push(voronoiHover);
    }
  } // todo: put here?


  if (props.nodeLabelAnnotations) {
    annotations.push(...props.nodeLabelAnnotations);
  }

  const {
    generateSVGAnnotations,
    generateHTMLAnnotations
  } = props;
  const annotationLayer = annotations && annotations.length > 0 && React$1__default.createElement(AnnotationLayer, {
    annotations: annotations,
    voronoiHover: voronoiHover,
    generateSVGAnnotations: generateSVGAnnotations,
    generateHTMLAnnotations: generateHTMLAnnotations,
    margin: margin,
    useSpans: useSpans,
    size: adjustedSize,
    position: [adjustedPosition[0] + margin.left, adjustedPosition[1] + margin.top]
  });
  return React$1__default.createElement(SpanOrDiv, {
    span: useSpans,
    className: `${className} frame ${name}`
  }, beforeElements && React$1__default.createElement(SpanOrDiv, {
    span: useSpans,
    className: `${name} frame-before-elements`
  }, beforeElements), React$1__default.createElement(SpanOrDiv, {
    span: useSpans,
    className: "frame-elements",
    style: {
      height: `${height}px`,
      width: `${width}px`
    }
  }, React$1__default.createElement(SpanOrDiv, {
    span: useSpans,
    className: "visualization-layer",
    style: {
      position: 'absolute'
    }
  }, (axesTickLines || backgroundGraphics) && React$1__default.createElement("svg", {
    className: "background-graphics",
    style: {
      position: 'absolute'
    },
    width: width,
    height: height
  }, backgroundGraphics && React$1__default.createElement("g", {
    "aria-hidden": true,
    className: "background-graphics"
  }, finalBackgroundGraphics), axesTickLines && React$1__default.createElement("g", {
    transform: `translate(${margin.left},${margin.top})`,
    key: "visualization-tick-lines",
    className: 'axis axis-tick-lines',
    "aria-hidden": true
  }, axesTickLines)), React$1__default.createElement("canvas", {
    className: "frame-canvas frame-canvas-front",
    ref: frontCanvasRef,
    style: {
      position: 'absolute',
      left: `0px`,
      top: `0px`,
      width: `${width}px`,
      height: `${height}px`
    },
    width: width * devicePixelRatio,
    height: height * devicePixelRatio
  }), React$1__default.createElement("canvas", {
    className: "frame-canvas frame-canvas-hidden",
    ref: backCanvasRef,
    style: {
      position: 'absolute',
      left: `0px`,
      top: `0px`,
      width: `${width}px`,
      height: `${height}px`
    },
    width: width * devicePixelRatio,
    height: height * devicePixelRatio
  }), React$1__default.createElement("svg", {
    className: "visualization-layer",
    style: {
      position: 'absolute'
    },
    width: width,
    height: height
  }, React$1__default.createElement(FilterDefs, {
    matte: marginGraphic,
    key: frameKey || name,
    additionalDefs: additionalDefs
  }), React$1__default.createElement(VisualizationLayer, {
    title: generatedTitle,
    frameKey: frameKey,
    width: width,
    height: height,
    size: adjustedSize,
    position: adjustedPosition,
    frontCanvas: frontCanvas,
    backCanvas: backCanvas,
    matte: marginGraphic,
    margin: margin,
    canvasPostProcess: canvasPostProcess,
    canvasPipeline: canvasPipeline,
    voronoiHover: setVoronoiHover
  }, svgPipeline, axes && React$1__default.createElement("g", {
    key: "visualization-axis-labels",
    className: "axis axis-labels"
  }, axes)), generatedTitle && React$1__default.createElement("g", {
    className: "frame-title"
  }, generatedTitle), foregroundGraphics || oLabels && React$1__default.createElement("g", {
    "aria-hidden": true,
    className: "foreground-graphics"
  }, finalForegroundGraphics, oLabels))), React$1__default.createElement(InteractionLayer, {
    useSpans: useSpans,
    hoverAnnotation: hoverAnnotation,
    interaction: interaction,
    voronoiHover: setVoronoiHover,
    customClickBehavior: customClickBehavior,
    customHoverBehavior: customHoverBehavior,
    customDoubleClickBehavior: customDoubleClickBehavior,
    position: adjustedPosition,
    margin: margin,
    size: adjustedSize,
    svgSize: size,
    xScale: frameXScale,
    yScale: frameYScale,
    data: screenCoordinates,
    enabled: true,
    useCanvas: canvasPipeline.length > 0,
    overlay: overlay,
    interactionOverflow: interactionOverflow,
    disableCanvasInteraction: disableCanvasInteraction
  }), annotationLayer, afterElements && React$1__default.createElement(SpanOrDiv, {
    span: useSpans,
    className: `${name} frame-after-elements`
  }, afterElements)));
};

Frame.propTypes = { ...BaseProps,
  // generated
  frameXScale: propTypes.func,
  frameYScale: propTypes.func,
  annotationLayer: propTypes.node,
  canvasPipeline: propTypes.array,
  svgPipeline: propTypes.array,
  // todo: duplicated?
  screenCoordinates: propTypes.array,
  xyPoints: propTypes.array,
  adjustedPosition: propTypes.array,
  adjustedSize: propTypes.array,
  plotChildren: propTypes.array,
  axes: propTypes.array,
  axesTickLines: propTypes.array
};
Frame.defaultProps = { ...BaseDefaultProps,
  adjustedPosition: [0, 0],
  annotationLayer: null,
  axes: null,
  axesTickLines: null,
  canvasPipeline: [],
  svgPipeline: [],
  screenCoordinates: []
};

const calculateMargin = ({
  margin,
  axes,
  title,
  oLabel,
  projection,
  size
}) => {
  if (margin !== undefined) {
    if (typeof margin === 'function') {
      margin = margin({
        size
      });
    }

    if (typeof margin !== 'object') {
      return {
        top: margin,
        bottom: margin,
        left: margin,
        right: margin
      };
    } else if (typeof margin === 'object') {
      return Object.assign({
        top: 0,
        bottom: 0,
        left: 0,
        right: 0
      }, margin);
    }
  }

  const finalMargin = {
    top: 0,
    bottom: 0,
    left: 0,
    right: 0
  };
  let orient = 'left';

  if (axes && projection !== 'radial') {
    axes.forEach(axisObj => {
      const axisObjAdditionMargin = axisObj.label ? 60 : 50;
      orient = axisObj.orient;
      finalMargin[orient] = axisObjAdditionMargin;
    });
  }

  if (title.title && !(typeof title.title === 'string' && title.title.length === 0)) {
    const {
      orient = 'top'
    } = title;
    finalMargin[orient] += 40;
  }

  if (oLabel && projection !== 'radial') {
    if (orient === 'bottom' || orient === 'top') {
      finalMargin.left += 50;
    } else {
      finalMargin.bottom += 50;
    }
  }

  return finalMargin;
};

const toAxes = ({
  margin,
  axesDefs,
  adjustedSize,
  yScale,
  xScale,
  xyPoints
}) => {
  let axes = [];
  const axesTickLines = [];
  const existingBaselines = {};

  if (axesDefs) {
    axes = axesDefs.map((_d, i) => {
      const d = Object.assign({}, _d);
      let axisClassname = d.className || '';
      axisClassname += ' axis';
      let axisScale = yScale;

      if (existingBaselines[d.orient]) {
        d.baseline = d.baseline || false;
      }

      existingBaselines[d.orient] = true;

      if (d.orient === 'top' || d.orient === 'bottom') {
        axisClassname += ' x';
        axisScale = xScale;
      } else {
        axisClassname += ' y';
      }

      axisClassname += ` ${d.orient}`;
      let tickValues;

      if (d.tickValues && Array.isArray(d.tickValues)) {
        tickValues = d.tickValues;
      }

      const axisSize = [adjustedSize[0], adjustedSize[1]];
      const axisParts = axisPieces({
        padding: d.padding,
        tickValues,
        scale: axisScale,
        ticks: d.ticks,
        orient: d.orient,
        size: axisSize,
        footer: d.footer,
        tickSize: d.tickSize
      });
      const tickLineGroup = d.showLineTicks !== false && React$1__default.createElement("g", {
        key: `axes-tick-lines-${i}`,
        className: `axis ${axisClassname}`
      }, axisLines({
        axisParts,
        orient: d.orient,
        tickLineGenerator: d.tickLineGenerator,
        baseMarkProps: d.baseMarkProps,
        className: axisClassname,
        jaggedBase: d.jaggedBase
      }));
      axesTickLines.push(tickLineGroup);
      return React$1__default.createElement(Axis, {
        label: d.label,
        axisParts: axisParts,
        key: d.key || `axis-${i}`,
        orient: d.orient,
        size: axisSize,
        margin: margin,
        ticks: d.ticks,
        tickSize: d.tickSize,
        tickFormat: d.tickFormat,
        tickValues: tickValues,
        scale: axisScale,
        className: axisClassname,
        padding: d.padding,
        rotate: d.rotate,
        annotationFunction: d.axisAnnotationFunction,
        glyphFunction: d.glyphFunction,
        baseline: d.baseline,
        dynamicLabelPosition: d.dynamicLabelPosition,
        center: d.center,
        marginalSummaryType: d.marginalSummaryType,
        xyPoints: xyPoints,
        showLineTicks: d.showLineTicks,
        showLabels: d.showLabels
      });
    });
  }

  return {
    axes,
    axesTickLines
  };
};

const computeXYFrameData = props => {
  const {
    width,
    height,
    title,
    margin: baseMargin,
    // interactions
    xScaleType = linear$1,
    yScaleType = linear$1,
    plotChildren,
    axesDefs
  } = props;
  const size = [width, height];
  const margin = calculateMargin({
    margin: baseMargin,
    axes: axesDefs,
    title: title
  });
  const {
    adjustedPosition,
    adjustedSize
  } = getAdjustedPositionSize({
    size: [width, height],
    margin
  });
  const frameScopeExtent = getFrameScopeExtent(plotChildren);
  const xRange = [0, adjustedSize[0]];
  const yRange = [adjustedSize[1], 0];
  const frameXScale = xScaleType().domain(frameScopeExtent.xExtent).range(xRange);
  const frameYScale = yScaleType().domain(frameScopeExtent.yExtent).range(yRange); // canvasPipeline

  const {
    canvasPipeline,
    svgPipeline,
    xyPoints
  } = plotChildren.map((d, i) => toPipeline({ ...d.props,
    frameXScale,
    frameYScale,
    margin,
    adjustedSize,
    size
  })).reduce((acc, cur) => {
    acc.canvasPipeline = acc.canvasPipeline.concat(cur.canvasPipe);
    acc.svgPipeline = acc.svgPipeline.concat(cur.svgPipe);
    acc.xyPoints = acc.xyPoints.concat(cur.xyPoints);
    return acc;
  }, {
    canvasPipeline: [],
    svgPipeline: [],
    xyPoints: []
  });
  const {
    axes,
    axesTickLines
  } = toAxes({
    axesDefs,
    margin,
    adjustedSize,
    xScale: frameXScale,
    yScale: frameYScale,
    xyPoints
  });
  const screenCoordinates = plotChildren.map(d => d.props.data.map(e => ({ ...e,
    x: d.props.xAccessor(e),
    y: d.props.yAccessor(e),
    screenCoordinates: [frameXScale(d.props.xAccessor(e)), frameYScale(d.props.yAccessor(e))],
    key: d.key
  }))).reduce((acc, cur) => {
    acc = [...acc, ...cur];
    return acc;
  }, []);
  return {
    margin,
    adjustedPosition,
    adjustedSize,
    screenCoordinates,
    axes,
    axesTickLines,
    canvasPipeline,
    svgPipeline,
    xyPoints,
    frameXScale,
    frameYScale
  };
};

const keyAndObjectifyBarData = ({
  data,
  renderKey = (d, i) => i,
  oAccessor,
  rAccessor: baseRAccessor,
  originalRAccessor,
  originalOAccessor,
  multiAxis = false
}) => {
  let rAccessor;
  let multiExtents;

  if (multiAxis && baseRAccessor.length > 1) {
    multiExtents = baseRAccessor.map(accessor => extent(data.map(accessor)));
    const rScales = multiExtents.map(ext => linear$1().domain(ext).range([0, 1]));
    rAccessor = rScales.map((scale, i) => d => scale(baseRAccessor[i](d)));
  } else {
    rAccessor = baseRAccessor;
  }

  const decoratedData = [];
  oAccessor.forEach((actualOAccessor, oIndex) => {
    rAccessor.forEach((actualRAccessor, rIndex) => {
      data.forEach(d => {
        const appliedKey = renderKey(d, decoratedData.length);
        const originalR = originalRAccessor[rIndex];
        const originalO = originalOAccessor[oIndex];
        const rName = typeof originalR === 'string' ? originalR : `function-${rIndex}`;
        const oName = typeof originalO === 'string' ? originalO : `function-${oIndex}`;

        if (typeof d !== 'object') {
          const expandedData = {
            value: d,
            renderKey: appliedKey
          };
          const value = actualRAccessor(expandedData);
          decoratedData.push({
            data: expandedData,
            value,
            rIndex,
            rName,
            oIndex,
            oName,
            column: appliedKey !== undefined && appliedKey.toString && appliedKey.toString() || appliedKey,
            renderKey: appliedKey
          });
        } else {
          const value = actualRAccessor(d);
          decoratedData.push({
            renderKey: appliedKey,
            data: d,
            rIndex,
            rName,
            oIndex,
            oName,
            value,
            column: actualOAccessor(d)
          });
        }
      });
    });
  });
  return {
    allData: decoratedData,
    multiExtents
  };
};

const stringToArrayFn = (accessor, defaultAccessor, raw) => {
  if (accessor === undefined) {
    return [stringToFn(undefined, defaultAccessor, raw)];
  }

  let arrayOfAccessors = [];

  if (Array.isArray(accessor)) {
    arrayOfAccessors = accessor;
  } else {
    arrayOfAccessors = [accessor];
  }

  return arrayOfAccessors.map(a => stringToFn(a, defaultAccessor, raw));
};

const toLaidOutPieces = ({
  data,
  shouldRender,
  useCanvas,
  styleFn,
  classFn,
  baseMarkProps,
  renderKeyFn,
  ariaLabel,
  axis
}) => {
  const valueFormat = axis && axis[0] && axis[0].tickFormat;
  const svgPipeline = [];
  const canvasPipeline = [];
  if (!shouldRender) return {
    svgPipeline,
    canvasPipeline
  };
  data.forEach((d, i) => {
    if (useCanvas === true) {
      const canvasPiece = {
        baseClass: 'orframe-piece',
        tx: d.renderElement.tx || 0,
        ty: d.renderElement.ty || 0,
        d: d.piece,
        i,
        markProps: d.renderElement || d,
        styleFn: styleFn,
        classFn
      };
      canvasPipeline.push(canvasPiece);
    } else {
      if (React$1__default.isValidElement(d.renderElement || d)) {
        svgPipeline.push(d.renderElement || d);
      } else {
        /*ariaLabel.items*/
        const pieceAriaLabel = `${d.o} ${ariaLabel.items} value ${valueFormat && valueFormat(d.piece.value) || d.piece.value}`;
        svgPipeline.push(React$1__default.createElement(lib_2, _extends({}, baseMarkProps, {
          key: renderKeyFn ? renderKeyFn(d.piece) : d.renderKey || `piece-render-${i}`
        }, d.renderElement || d, {
          "aria-label": pieceAriaLabel
        })));
      }
    }
  });
  return {
    svgPipeline,
    canvasPipeline
  };
};

const eventListenersGenerator = () => ({});

const drawAreaConnector = ({
  x1,
  x2,
  y1,
  y2,
  sizeX1,
  sizeY1,
  sizeX2,
  sizeY2
}) => {
  return `M${x1},${y1}L${x2},${y2}L${x2 + sizeX2},${y2 + sizeY2}L${x1 + sizeX1},${y1 + sizeY1}Z`;
};

const toConnectors = ({
  type,
  data,
  renderMode,
  styleFn,
  classFn,
  projection,
  useCanvas,
  baseMarkProps,
  isOrdinalPoint = false
}) => {
  const svgPipeline = [];
  const canvasPipeline = [];

  if (!type.type) {
    return {
      svgPipeline,
      canvasPipeline
    };
  }

  const radarHash = new Map();

  if (typeof type.type === 'function') {
    const connectionRule = type.type;
    const keys = Object.keys(data);
    keys.forEach((key, pieceArrayI) => {
      const pieceArray = data[key];
      const nextColumn = data[keys[pieceArrayI + 1]];

      if (nextColumn) {
        const matchArray = nextColumn.map((d, i) => connectionRule({ ...d.piece,
          ...d.piece.data
        }, i));
        pieceArray.forEach((piece, pieceI) => {
          const thisConnectionPiece = connectionRule({ ...piece.piece,
            ...piece.piece.data
          }, pieceI);
          const targetMatch = connectionRule({ ...piece.piece,
            ...piece.piece.data
          }, pieceI);
          const matchingPieceIndex = targetMatch !== undefined && targetMatch !== false && matchArray.indexOf(targetMatch);

          if (thisConnectionPiece !== undefined && thisConnectionPiece !== null && matchingPieceIndex !== false && matchingPieceIndex !== -1) {
            const matchingPiece = nextColumn[matchingPieceIndex];
            let markD;

            if (projection === 'radial' && isOrdinalPoint === true) {
              if (!radarHash.get(piece)) {
                radarHash.set(piece, [piece]);
              }

              const thisRadar = radarHash.get(piece);

              if (thisRadar) {
                thisRadar.push(matchingPiece);
                radarHash.set(matchingPiece, thisRadar);
                radarHash.delete(piece);
              }
            } else {
              const {
                xy
              } = piece;
              const {
                xy: mxy
              } = matchingPiece;
              const {
                x,
                y,
                height = 1,
                width = 1
              } = xy;
              const {
                x: mx,
                y: my,
                height: mheight = 1,
                width: mwidth = 1
              } = mxy;

              if (projection === 'vertical') {
                markD = drawAreaConnector({
                  x1: x + width,
                  x2: mx,
                  y1: y,
                  y2: my,
                  sizeX1: 0,
                  sizeX2: 0,
                  sizeY1: height,
                  sizeY2: mheight
                });
              } else if (projection === 'horizontal') {
                markD = drawAreaConnector({
                  x1: x,
                  x2: mx,
                  y1: y + height,
                  y2: my,
                  sizeX1: width,
                  sizeX2: mwidth,
                  sizeY1: 0,
                  sizeY2: 0
                });
              } else if (projection === 'radial') {
                markD = drawAreaConnector({
                  x1: x,
                  x2: mx,
                  y1: y + height,
                  y2: my,
                  sizeX1: width,
                  sizeX2: mwidth,
                  sizeY1: 0,
                  sizeY2: 0
                });
              }

              const renderValue = renderMode && renderMode(piece.piece, pieceI);
              const source = { ...piece.piece.data,
                ...piece.piece.data
              };
              const target = { ...matchingPiece.piece,
                ...matchingPiece.piece.data
              };
              const calculatedStyle = styleFn({
                source,
                target
              });
              const eventListeners = eventListenersGenerator();

              if (useCanvas === true) {
                const canvasConnector = {
                  baseClass: 'xyframe-line',
                  tx: 0,
                  ty: 0,
                  d: {
                    source,
                    target
                  },
                  markProps: {
                    d: markD,
                    markType: 'path'
                  },
                  styleFn: styleFn,
                  renderFn: renderMode,
                  classFn
                };
                canvasPipeline.push(canvasConnector);
              } else {
                svgPipeline.push(React$1__default.createElement(Mark, _extends({}, baseMarkProps, eventListeners, {
                  renderMode: renderValue,
                  markType: "path",
                  d: markD,
                  className: classFn ? classFn(piece.piece.data, pieceI) : '',
                  key: `connector${piece.piece.renderKey}`,
                  style: calculatedStyle
                })));
              }
            }
          }
        });
      }
    });

    if (radarHash.size > 0) {
      for (const ring of radarHash.values()) {
        const ringPiece = { ...ring[0].piece,
          ...ring[0].piece.data
        };
        const markD = `M${ring.map(d => `${d.xy.x},${d.xy.y}`).join('L')}Z`;

        if (useCanvas === true) {
          const canvasRadar = {
            baseClass: 'ordinal-radar',
            tx: 0,
            ty: 0,
            d: {
              source: ringPiece
            },
            markProps: {
              d: markD,
              markType: 'path'
            },
            styleFn: styleFn,
            renderFn: renderMode,
            classFn
          };
          canvasPipeline.push(canvasRadar);
        } else {
          svgPipeline.push(React$1__default.createElement(Mark, _extends({}, baseMarkProps, {
            renderMode: renderMode && renderMode(ringPiece),
            markType: "path",
            d: markD,
            className: classFn ? classFn(ringPiece) : '',
            key: `ordinal-ring-${ringPiece.renderKey}`,
            style: styleFn({
              source: ringPiece
            })
          })));
        }
      }
    }
  } else if (type.type) {
    console.error(`Invalid connectorType - Must be a function that takes a data point and determines if it is connected to a data point in the next column`);
  }

  return {
    svgPipeline,
    canvasPipeline
  };
};

const toPipeline$1 = ({
  // pieces
  pieceStyle,
  pieceData,
  pieceClass,
  pieceType,
  pieceUseCanvas,
  //connectors
  connectorType,
  connectorData,
  connectorStyle,
  connectorClass,
  connectorUseCanvas,
  connectorRenderMode,
  projection,
  ariaLabel,
  axis,
  baseMarkProps,
  renderKeyFn,
  isOrdinalPoint,
  shouldRender = true
}) => {
  const {
    svgPipeline: pieceSvg,
    canvasPipeline: pieceCanvas
  } = toLaidOutPieces({
    data: pieceData,
    shouldRender,
    useCanvas: pieceUseCanvas,
    styleFn: pieceStyle,
    classFn: pieceClass,
    baseMarkProps,
    renderKeyFn,
    ariaLabel,
    axis
  });
  const {
    svgPipeline: connectorSvg,
    canvasPipeline: connectorCanvas
  } = toConnectors({
    type: connectorType,
    isOrdinalPoint,
    data: connectorData,
    useCanvas: connectorUseCanvas,
    styleFn: connectorStyle,
    classFn: connectorClass,
    renderMode: connectorRenderMode,
    baseMarkProps,
    renderKeyFn,
    ariaLabel,
    axis,
    projection
  });
  const svgPipe = [...pieceSvg, ...connectorSvg];
  const canvasPipe = [...pieceCanvas, ...connectorCanvas];
  return {
    svgPipe,
    canvasPipe
  };
};

const baselineGenerator = (orient, size, className) => {
  const offsets = {
    left: {
      x: 0,
      y: 0,
      width: 0,
      height: size[1]
    },
    right: {
      x: size[0],
      y: 0,
      width: 0,
      height: size[1]
    },
    top: {
      x: 0,
      y: 0,
      width: size[0],
      height: 0
    },
    bottom: {
      x: 0,
      y: size[1],
      width: size[0],
      height: 0
    }
  };
  const orientOffset = offsets[orient];
  return React$1__default.createElement("line", {
    key: "baseline",
    className: `axis-baseline ${className}`,
    stroke: "black",
    strokeLinecap: "square",
    x1: orientOffset.x,
    x2: orientOffset.x + orientOffset.width,
    y1: orientOffset.y,
    y2: orientOffset.y + orientOffset.height
  });
};

const roundToTenth = number => Math.round(number * 10) / 10;

const circlePath = (cx, cy, r) => `${['M', roundToTenth(cx - r), roundToTenth(cy), 'a', r, r, 0, 1, 0, r * 2, 0, 'a', r, r, 0, 1, 0, -(r * 2), 0].join(' ')}Z`;

const orFrameAxisGenerator = ({
  projection,
  axis,
  adjustedSize,
  size,
  rScale,
  rScaleType,
  innerRadius,
  rExtent,
  data,
  maxColumnValues = 1,
  xyData,
  margin
}) => {
  if (!axis) return {
    axis: undefined,
    axesTickLines: undefined
  };
  let generatedAxis, axesTickLines;

  if (projection !== 'radial' && axis) {
    axesTickLines = [];
    const axisPosition = [0, 0];
    generatedAxis = axis.map((d, i) => {
      let axisClassname = d.className || '';
      let tickValues;
      const axisDomain = d.extentOverride ? d.extentOverride : rScale.domain();
      const leftRight = ['left', 'right'];
      const axisScale = leftRight.indexOf(d.orient) === -1 && projection !== 'vertical' || leftRight.indexOf(d.orient) !== -1 && projection !== 'horizontal' ? rScaleType.domain(axisDomain) : rScaleType.domain([0, maxColumnValues]);
      const orient = d.orient;
      const axisRange = leftRight.indexOf(d.orient) === -1 && projection !== 'vertical' || leftRight.indexOf(d.orient) !== -1 && projection !== 'horizontal' ? rScale.range() : [0, projection === 'vertical' ? adjustedSize[0] : adjustedSize[1]];

      if (orient === 'right') {
        axisScale.range(axisRange.reverse());
        axisClassname += ' right y';
      } else if (orient === 'left') {
        axisClassname += ' left y';
        axisScale.range(axisRange.reverse());
      } else if (orient === 'top') {
        axisClassname += ' top x';
        axisScale.range(axisRange);
      } else if (orient === 'bottom') {
        axisClassname += ' bottom x';
        axisScale.range(axisRange);
      }

      if (d.tickValues && Array.isArray(d.tickValues)) {
        tickValues = d.tickValues;
      } else if (d.tickValues instanceof Function) {
        //otherwise assume a function
        tickValues = d.tickValues(data, size, rScale);
      }

      const axisParts = axisPieces({
        padding: d.padding,
        tickValues,
        scale: axisScale,
        ticks: d.ticks,
        orient,
        size: adjustedSize,
        footer: d.footer,
        tickSize: d.tickSize,
        jaggedBase: d.jaggedBase
      });
      const axisTickLines = d.showTickLines !== false ? axisLines({
        className: d.className,
        axisParts,
        orient,
        baseMarkProps: {},
        tickLineGenerator: d.tickLineGenerator,
        jaggedBase: d.jaggedBase,
        scale: axisScale
      }) : [];
      axesTickLines.push(axisTickLines);

      if (d.baseline === 'under') {
        axesTickLines.push(baselineGenerator(d.orient, adjustedSize, d.className));
      }

      const marginalSummaryType = typeof d.marginalSummaryType === 'string' ? {
        type: d.marginalSummaryType
      } : d.marginalSummaryType;
      return React$1__default.createElement(Axis, _extends({}, d, {
        key: d.key || `orframe-axis-${i}`,
        axisParts: axisParts,
        orient: orient,
        size: adjustedSize,
        position: axisPosition,
        baseline: true,
        tickValues: tickValues,
        scale: axisScale,
        className: axisClassname,
        marginalSummaryType: marginalSummaryType,
        margin: margin,
        xyPoints: xyData.map(d => ({
          x: projection === 'vertical' ? 0 : d.value,
          y: projection === 'vertical' ? d.value : 0,
          data: d.data
        }))
      }));
    });
  } else if (projection === 'radial' && axis) {
    const ticks = [];
    axis.forEach(axisObj => {
      const {
        tickValues: baseTickValues = rScale.ticks(Math.max(2, (adjustedSize[0] / 2 - innerRadius) / 50)),
        label,
        tickFormat = d => d
      } = axisObj;
      const tickScale = rScaleType.domain(rExtent).range([innerRadius, adjustedSize[0] / 2]);
      const tickValues = baseTickValues instanceof Function ? baseTickValues({
        orient: axisObj.orient
      }) : baseTickValues;
      tickValues.forEach((t, i) => {
        const tickSize = tickScale(t);

        if (!(innerRadius === 0 && t === 0)) {
          let axisLabel;
          let ref = '';

          if (label && i === tickValues.length - 1) {
            const labelSettings = typeof label === 'string' ? {
              name: label,
              locationDistance: 15
            } : label;
            const {
              locationDistance = 15
            } = labelSettings;
            ref = `${Math.random().toString()} `;
            axisLabel = React$1__default.createElement("g", {
              className: "axis-label radial",
              transform: `translate(0,${locationDistance})`
            }, React$1__default.createElement("text", {
              textAnchor: "middle"
            }, React$1__default.createElement("textPath", {
              startOffset: tickSize * Math.PI * 0.5,
              xlinkHref: `#${ref}`
            }, label.name)));
          }

          ticks.push(React$1__default.createElement("g", {
            key: `orframe-radial-axis-element-${t}`,
            className: "axis axis-label axis-tick radial",
            transform: `translate(0,0)`
          }, React$1__default.createElement("path", {
            id: ref,
            d: circlePath(0, 0, tickSize),
            r: tickSize,
            stroke: "gray",
            fill: "none"
          }), React$1__default.createElement("text", {
            y: -tickSize + 5,
            textAnchor: "middle"
          }, tickFormat(t)), axisLabel));
        }

        return undefined;
      });
    });
    generatedAxis = [React$1__default.createElement("g", {
      key: axis[0].key || `orframe-radial-axis-container`,
      className: "axis-labels",
      transform: `translate(${adjustedSize[0] / 2},${adjustedSize[1] / 2})`
    }, ticks)];
  }

  return {
    axis: generatedAxis,
    axesTickLines
  };
};

const genericFunction = value => () => value;

const midMod = d => d.middle ? d.middle : 0;

const zeroFunction = genericFunction(0);
const twoPI$2 = Math.PI * 2;
const defaultOverflow = {
  top: 0,
  bottom: 0,
  left: 0,
  right: 0
};
const BAR_PERCENT = 'barpercent';
const TIMELINE = 'timeline';
const CLUSTER_BAR = 'clusterbar';
const BAR = 'bar';
const NONE = 'none';
const ORDINAL_POINT = 'ordinalpoint';
const PROJECTION_VERTICAL = 'vertical';
const PROJECTION_RADIAL = 'radial';
const PROJECTION_HORIZONTAL = 'horizontal';
const naturalLanguageTypes = {
  bar: {
    items: 'bar',
    chart: 'bar chart'
  },
  clusterbar: {
    items: 'bar',
    chart: 'grouped bar chart'
  },
  swarm: {
    items: 'point',
    chart: 'swarm plot'
  },
  ordinalpoint: {
    items: 'point',
    chart: 'point plot'
  },
  timeline: {
    items: 'bar',
    chart: 'timeline'
  }
};

const computeOrdinalFrameData = props => {
  const {
    width,
    height,
    title: baseTitle,
    margin: baseMargin,
    customClickBehavior,
    customHoverBehavior,
    customDoubleClickBehavior,
    hoverAnnotation,
    axesDefs: baseAxis,
    plotChildren
  } = props;
  const singleOrdinalPlot = plotChildren[0];
  const {
    // ordinal plot
    data,
    oScaleType,
    rScaleType,
    dynamicColumnWidth,
    pixelColumnWidth,
    oLabel,
    projection,
    multiAxis,
    renderMode,
    oPadding: padding = 0,
    oAccessor: baseOAccessor,
    rAccessor: baseRAccessor,
    oExtent: baseOExtent,
    pieceIDAccessor: basePieceIDAccessor,
    pieceHoverAnnotation,
    baseMarkProps = {},
    style: baseStyle,
    rExtent: baseRExtent,
    renderKey: baseRenderKey,
    oSort,
    pieceClass: basePieceClass,
    pieceUseCanvas,
    connectorStyle: baseConnectorStyle,
    connectorType: baseConnectorType,
    connectorUseCanvas,
    connectorClass,
    connectorRenderMode,
    summaryStyle: baseSummaryStyle,
    summaryClass: baseSummaryClass,
    summaryPosition: baseSummaryPosition,
    summaryRenderMode,
    summaryHoverAnnotation,
    summaryType: baseSummaryType,
    summaryUseCanvas
  } = singleOrdinalPlot.props;
  let pieceType = singleOrdinalPlot.type.name.toLowerCase();

  const _mappedMiddles = (oScale, middleMax, padding) => {
    const oScaleDomainValues = oScale.domain();
    const mappedMiddles = {};
    oScaleDomainValues.forEach((p, q) => {
      const base = oScale(p) - padding;
      const next = oScaleDomainValues[q + 1] ? oScale(oScaleDomainValues[q + 1]) : middleMax;
      const diff = (next - base) / 2;
      mappedMiddles[p] = base + diff;
    });
    return mappedMiddles;
  };

  const connectorStyle = stringToFn(baseConnectorStyle, () => ({}), true);
  const summaryStyle = stringToFn(baseSummaryStyle, () => ({}), true);
  const pieceStyle = stringToFn(baseStyle, () => ({}), true);
  const pieceClass = stringToFn(basePieceClass, () => '', true);
  const summaryClass = stringToFn(baseSummaryClass, () => '', true);

  const summaryPosition = baseSummaryPosition || (position => position);

  const title = typeof baseTitle === 'object' && !React$1__default.isValidElement(baseTitle) && baseTitle !== null ? baseTitle : {
    title: baseTitle,
    orient: 'top'
  };
  const pieceIDAccessor = stringToFn(basePieceIDAccessor, () => ''); // Paper variables

  const summaryType = objectifyType(baseSummaryType);
  const oAccessor = stringToArrayFn(baseOAccessor, d => d.renderKey);
  const rAccessor = stringToArrayFn(baseRAccessor, d => d.value || 1);
  const renderKey = stringToFn(baseRenderKey, (d, i) => i);

  const eventListenersGenerator = () => ({});

  let oLabels;
  const projectedColumns = {}; // --------------- same as xy  - start

  const size = [width, height]; // --------------- same as xy  - close

  const originalRAccessor = Array.isArray(baseRAccessor) ? baseRAccessor : [baseRAccessor];
  const originalOAccessor = Array.isArray(baseOAccessor) ? baseOAccessor : [baseOAccessor];
  const {
    allData,
    multiExtents
  } = keyAndObjectifyBarData({
    data,
    renderKey,
    oAccessor,
    rAccessor,
    originalRAccessor,
    originalOAccessor,
    multiAxis
  });
  let arrayWrappedAxis;

  if (Array.isArray(baseAxis)) {
    arrayWrappedAxis = baseAxis.map(axisFnOrObject => typeof axisFnOrObject === 'function' ? axisFnOrObject({
      size
    }) : axisFnOrObject);
  } else if (baseAxis) {
    arrayWrappedAxis = [baseAxis].map(axisFnOrObject => typeof axisFnOrObject === 'function' ? axisFnOrObject({
      size
    }) : axisFnOrObject);
  }

  if (multiExtents && baseAxis) {
    arrayWrappedAxis.forEach((d, i) => {
      d.extentOverride = multiExtents[i];
    });
  }

  const margin = calculateMargin({
    margin: baseMargin,
    axes: arrayWrappedAxis,
    title,
    oLabel,
    projection,
    size
  });
  const {
    adjustedPosition,
    adjustedSize
  } = getAdjustedPositionSize({
    size: [width, height],
    margin
  });
  const oExtentSettings = baseOExtent === undefined || Array.isArray(baseOExtent) ? {
    extent: baseOExtent
  } : baseOExtent;
  const calculatedOExtent = allData.reduce((p, c) => {
    const baseOValue = c.column;
    const oValue = baseOValue !== undefined ? String(baseOValue) : baseOValue;

    if (p.indexOf(oValue) === -1) {
      p.push(oValue);
    }

    return p;
  }, []);
  let oExtent = oExtentSettings.extent || calculatedOExtent;

  if (pieceType === BAR_PERCENT) {
    const oExtentSums = oExtent.map(d => allData.filter(p => String(p.column) === d).reduce((p, c) => p + c.value, 0)).reduce((p, c, i) => {
      p[oExtent[i]] = c;
      return p;
    }, {});
    allData.forEach(d => {
      d.value = oExtentSums[d.column] && d.value / oExtentSums[d.column] || 0;
    });
    pieceType = BAR;
  }

  if (pixelColumnWidth) {
    if (projection === PROJECTION_RADIAL) {
      console.error('pixelColumnWidth is not honored in radial mode');
    } else if (projection === PROJECTION_VERTICAL) {
      adjustedSize[0] = oExtent.length * pixelColumnWidth;
    } else {
      adjustedSize[1] = oExtent.length * pixelColumnWidth;
    }
  }

  const oDomain = projection === PROJECTION_VERTICAL && [0, adjustedSize[0]] || [0, adjustedSize[1]];
  const cwHash = oExtent.reduce((p, c) => {
    p[c] = 1 / oExtent.length * oDomain[1];
    p.total += p[c];
    return p;
  }, {
    total: 0
  });
  const oScale = dynamicColumnWidth ? ordinal() : oScaleType;
  oScale.domain(oExtent);
  let maxColumnValues;

  if (dynamicColumnWidth) {
    let columnValueCreator;

    if (typeof dynamicColumnWidth === 'string') {
      columnValueCreator = d => sum(d.map(p => p.data[dynamicColumnWidth]));
    } else {
      columnValueCreator = d => dynamicColumnWidth(d.map(p => p.data));
    }

    const thresholdDomain = [0];
    maxColumnValues = 0;
    const columnValues = [];
    oExtent.forEach(d => {
      const oValues = allData.filter(p => p.column === d);
      const columnValue = columnValueCreator(oValues);
      columnValues.push(columnValue);
      maxColumnValues += columnValue;
    });
    cwHash.total = 0;
    oExtent.forEach((d, i) => {
      const oValue = columnValues[i];
      const stepValue = oValue / maxColumnValues * (oDomain[1] - oDomain[0]);
      cwHash[d] = stepValue;
      cwHash.total += stepValue;

      if (i !== oExtent.length - 1) {
        thresholdDomain.push(stepValue + thresholdDomain[i]);
      }
    });
    oScale.range(thresholdDomain);
  } else {
    oScale.range(oDomain);
  }

  const rExtentSettings = baseRExtent === undefined || Array.isArray(baseRExtent) ? {
    extent: baseRExtent,
    onChange: undefined,
    includeAnnotations: false
  } : baseRExtent;
  let rExtent = rExtentSettings.extent;
  let subZeroRExtent = [0, 0];

  if (pieceType === BAR && summaryType.type && summaryType.type !== NONE) {
    pieceType = NONE;
  }

  const annotationsForExtent = []; // todo: annotations

  if (rExtentSettings.includeAnnotations && annotations) {
    rAccessor.forEach(actualRAccessor => {
      annotations.forEach((annotation, annotationIndex) => {
        const r = actualRAccessor(annotation, annotationIndex);

        if (isFinite(r)) {
          annotationsForExtent.push(r);
        }
      });
    });
  }

  if (pieceType === TIMELINE) {
    const rData = allData.map(d => d.value);
    const leftExtent = extent(rData.map(d => d[0]));
    const rightExtent = extent(rData.map(d => d[1]));
    rExtent = extent([...leftExtent, ...rightExtent, ...annotationsForExtent]);
  } else if (pieceType !== BAR) {
    rExtent = extent([...allData.map(d => d.value), ...annotationsForExtent]);
  } else {
    const positiveData = allData.filter(d => d.value >= 0);
    const negativeData = allData.filter(d => d.value < 0);
    const nestedPositiveData = nest$1().key(d => d.column).rollup(leaves => sum(leaves.map(d => d.value))).entries(positiveData);
    const nestedNegativeData = nest$1().key(d => d.column).rollup(leaves => sum(leaves.map(d => d.value))).entries(negativeData);
    const positiveAnnotations = annotationsForExtent.filter(d => d > 0);
    rExtent = [0, nestedPositiveData.length === 0 && positiveAnnotations.length === 0 ? 0 : Math.max(max([...nestedPositiveData.map(d => d.value), ...positiveAnnotations]), 0)];
    const negativeAnnotations = annotationsForExtent.filter(d => d < 0);
    subZeroRExtent = [0, nestedNegativeData.length === 0 ? 0 : Math.min(min([...nestedNegativeData.map(d => d.value), ...negativeAnnotations]), 0)];
    rExtent = [subZeroRExtent[1], rExtent[1]];
  }

  if ((pieceType === CLUSTER_BAR || multiAxis) && rExtent[0] > 0) {
    rExtent[0] = 0;
  }

  const calculatedRExtent = rExtent;

  if (rExtentSettings.extent && rExtentSettings.extent[0] !== undefined && rExtentSettings.extent[1] !== undefined) {
    rExtent = rExtentSettings.extent;
  } else {
    if (rExtentSettings.extent && rExtentSettings.extent[1] !== undefined && rExtentSettings.extent[0] === undefined) {
      rExtent[1] = rExtentSettings.extent[1];
    }

    if (rExtentSettings.extent && rExtentSettings.extent[0] !== undefined && rExtentSettings.extent[1] === undefined) {
      rExtent[0] = rExtentSettings.extent[0];
    }
  }

  if (props.invertR || rExtentSettings.extent && rExtentSettings.extent[0] > rExtentSettings.extent[1]) {
    rExtent = [rExtent[1], rExtent[0]];
  }

  const nestedPieces = {};
  nest$1().key(d => d.column).entries(allData).forEach(d => {
    nestedPieces[d.key] = d.values;
  });

  if (oSort !== undefined) {
    oExtent = oExtent.sort((a, b) => oSort(a, b, nestedPieces[a].map(d => d.data), nestedPieces[b].map(d => d.data)));
    oScale.domain(oExtent);
  }

  const rDomain = projection === PROJECTION_VERTICAL && [0, adjustedSize[1]] || [0, adjustedSize[0]];
  const castRScaleType = rScaleType;
  const instantiatedRScaleType = rScaleType.domain ? rScaleType : castRScaleType();
  const rScale = instantiatedRScaleType.copy().domain(rExtent).range(rDomain);
  const rScaleReverse = instantiatedRScaleType.copy().domain(rDomain).range(rDomain.reverse());
  const rScaleVertical = instantiatedRScaleType.copy().domain(rExtent).range(rDomain);
  const columnWidth = cwHash ? 0 : oScale.bandwidth();
  let pieceData = [];
  let mappedMiddleSize = adjustedSize[1];

  if (projection === PROJECTION_VERTICAL) {
    mappedMiddleSize = adjustedSize[0];
  }

  const mappedMiddles = _mappedMiddles(oScale, mappedMiddleSize, padding);

  pieceData = oExtent.map(d => nestedPieces[d] ? nestedPieces[d] : []);
  const zeroValue = projection === PROJECTION_VERTICAL ? rScaleReverse(rScale(0)) : rScale(0);
  oExtent.forEach((o, i) => {
    projectedColumns[o] = {
      name: o,
      padding,
      pieceData: pieceData[i],
      pieces: pieceData[i]
    };
    projectedColumns[o].x = oScale(o) + padding / 2;
    projectedColumns[o].y = 0;
    projectedColumns[o].middle = mappedMiddles[o] + padding / 2;
    let negativeOffset = zeroValue;
    let positiveOffset = zeroValue;
    let negativeBaseValue = 0;
    let positiveBaseValue = 0;
    projectedColumns[o].pieceData.forEach(piece => {
      let valPosition;

      if (pieceType === TIMELINE) {
        piece.scaledValue = rScale(piece.value[0]);
        piece.scaledEndValue = rScale(piece.value[1]);
        piece.scaledVerticalValue = rScaleVertical(piece.value[0]);
      } else if (pieceType !== BAR && pieceType !== CLUSTER_BAR) {
        piece.scaledValue = rScale(piece.value);
        piece.scaledVerticalValue = rScaleVertical(piece.value);
      } else if (pieceType === CLUSTER_BAR) {
        valPosition = projection === PROJECTION_VERTICAL ? rScaleReverse(rScale(piece.value)) : rScale(piece.value);
        piece.scaledValue = Math.abs(zeroValue - valPosition);
      }

      piece.x = projectedColumns[o].x;

      if (piece.value >= 0) {
        if (pieceType === BAR) {
          piece.scaledValue = projection === PROJECTION_VERTICAL ? positiveOffset - rScaleReverse(rScale(positiveBaseValue + piece.value)) : rScale(positiveBaseValue + piece.value) - positiveOffset;
          positiveBaseValue += piece.value;
        }

        piece.base = zeroValue;
        piece.bottom = pieceType === BAR ? positiveOffset : 0;
        piece.middle = piece.scaledValue / 2 + positiveOffset;
        positiveOffset = projection === PROJECTION_VERTICAL ? positiveOffset - piece.scaledValue : positiveOffset + piece.scaledValue;
        piece.negative = false;
      } else {
        if (pieceType === BAR) {
          piece.scaledValue = projection === PROJECTION_VERTICAL ? Math.abs(rScale(piece.value) - rScale(0)) : Math.abs(rScale(piece.value) - zeroValue);
          negativeBaseValue += piece.value;
        }

        piece.base = zeroValue;
        piece.bottom = pieceType === BAR ? negativeOffset : 0;
        piece.middle = negativeOffset - piece.scaledValue / 2;
        negativeOffset = projection === PROJECTION_VERTICAL ? negativeOffset + piece.scaledValue : negativeOffset - piece.scaledValue;
        piece.negative = true;
      }
    });

    if (cwHash) {
      projectedColumns[o].width = cwHash[o] - padding;

      if (props.ordinalAlign === 'center') {
        if (i === 0) {
          projectedColumns[o].x = projectedColumns[o].x - projectedColumns[o].width / 2;
          projectedColumns[o].middle = projectedColumns[o].middle - projectedColumns[o].width / 2;
        } else {
          projectedColumns[o].x = projectedColumns[oExtent[i - 1]].x + projectedColumns[oExtent[i - 1]].width;
          projectedColumns[o].middle = projectedColumns[o].x + projectedColumns[o].width / 2;
        }
      }

      projectedColumns[o].pct = cwHash[o] / cwHash.total;
      projectedColumns[o].pct_start = (projectedColumns[o].x - oDomain[0]) / cwHash.total;
      projectedColumns[o].pct_padding = padding / cwHash.total;
      projectedColumns[o].pct_middle = (projectedColumns[o].middle - oDomain[0]) / cwHash.total;
    } else {
      projectedColumns[o].width = columnWidth - padding;

      if (props.ordinalAlign === 'center') {
        projectedColumns[o].x = projectedColumns[o].x - projectedColumns[o].width / 2;
        projectedColumns[o].middle = projectedColumns[o].middle - projectedColumns[o].width / 2;
      }

      projectedColumns[o].pct = columnWidth / adjustedSize[1];
      projectedColumns[o].pct_start = (projectedColumns[o].x - oDomain[0]) / adjustedSize[1];
      projectedColumns[o].pct_padding = padding / adjustedSize[1];
      projectedColumns[o].pct_middle = (projectedColumns[o].middle - oDomain[0]) / adjustedSize[1];
    }
  });
  const labelArray = [];
  const pieArcs = [];
  const labelSettings = typeof oLabel === 'object' ? Object.assign({
    label: true,
    padding: 5
  }, oLabel) : {
    orient: 'default',
    label: oLabel,
    padding: 5
  };

  if (oLabel || hoverAnnotation) {
    const {
      offsetAngle,
      angleRange
    } = singleOrdinalPlot.props;
    const offsetPct = offsetAngle && offsetAngle / 360 || 0;
    const rangePct = angleRange && angleRange.map(d => d / 360) || [0, 1];
    const rangeMod = rangePct[1] - rangePct[0];
    const adjustedPct = rangeMod < 1 ? linear$1().domain([0, 1]).range(rangePct) : d => d;
    oExtent.forEach(d => {
      const arcGenerator = arc$2().innerRadius(0).outerRadius(rScale.range()[1] / 2);
      const angle = projectedColumns[d].pct * rangeMod;
      const startAngle = adjustedPct(projectedColumns[d].pct_start + offsetPct);
      const endAngle = startAngle + angle;
      const midAngle = startAngle + angle / 2;
      const markD = arcGenerator({
        startAngle: startAngle * twoPI$2,
        endAngle: endAngle * twoPI$2
      });
      const translate = [adjustedSize[0] / 2, adjustedSize[1] / 2];
      const centroid = arcGenerator.centroid({
        startAngle: startAngle * twoPI$2,
        endAngle: endAngle * twoPI$2
      });
      const addedPadding = centroid[1] > 0 && (!labelSettings.orient || labelSettings.orient === 'default' || labelSettings.orient === 'edge') ? 8 : 0;
      const outerPoint = pointOnArcAtAngle([0, 0], midAngle, rScale.range()[1] / 2 + labelSettings.padding + addedPadding);
      pieArcs.push({
        startAngle,
        endAngle,
        midAngle,
        markD,
        translate,
        centroid,
        outerPoint
      });
    });
  }

  if (oLabel) {
    let labelingFn;

    if (labelSettings.label === true) {
      const labelStyle = {
        textAnchor: 'middle'
      };

      if (projection === PROJECTION_HORIZONTAL && labelSettings.orient === 'right') {
        labelStyle.textAnchor = 'start';
      } else if (projection === PROJECTION_HORIZONTAL) {
        labelStyle.textAnchor = 'end';
      }

      labelingFn = (d, p, i) => {
        const additionalStyle = {};
        let transformRotate;

        if (projection === PROJECTION_RADIAL && labelSettings.orient === 'stem') {
          transformRotate = `rotate(${pieArcs[i].outerPoint[0] < 0 ? pieArcs[i].midAngle * 360 + 90 : pieArcs[i].midAngle * 360 - 90})`;
        } else if (projection === PROJECTION_RADIAL && labelSettings.orient !== 'center') {
          transformRotate = `rotate(${pieArcs[i].outerPoint[1] < 0 ? pieArcs[i].midAngle * 360 : pieArcs[i].midAngle * 360 + 180})`;
        }

        if (projection === PROJECTION_RADIAL && labelSettings.orient === 'stem' && (pieArcs[i].outerPoint[0] > 0 && labelSettings.padding < 0 || pieArcs[i].outerPoint[0] < 0 && labelSettings.padding >= 0)) {
          additionalStyle.textAnchor = 'end';
        } else if (projection === PROJECTION_RADIAL && labelSettings.orient === 'stem') {
          additionalStyle.textAnchor = 'start';
        }

        return React$1__default.createElement("text", _extends({}, labelStyle, additionalStyle, {
          transform: transformRotate
        }), d);
      };
    } else if (typeof labelSettings.label === 'function') {
      labelingFn = labelSettings.label;
    }

    oExtent.forEach((d, i) => {
      let xPosition = projectedColumns[d].middle;
      let yPosition = 0;

      if (projection === PROJECTION_HORIZONTAL) {
        yPosition = projectedColumns[d].middle;

        if (labelSettings.orient === 'right') {
          xPosition = adjustedSize[0] + 3;
        } else {
          xPosition = -3;
        }
      } else if (projection === PROJECTION_RADIAL) {
        if (labelSettings.orient === 'center') {
          xPosition = pieArcs[i].centroid[0] + pieArcs[i].translate[0];
          yPosition = pieArcs[i].centroid[1] + pieArcs[i].translate[1];
        } else {
          xPosition = pieArcs[i].outerPoint[0] + pieArcs[i].translate[0];
          yPosition = pieArcs[i].outerPoint[1] + pieArcs[i].translate[1];
        }
      }

      const label = labelingFn(d, projectedColumns[d].pieceData.map(d => d.data), i //          ,{ arc: pieArcs[i], data: projectedColumns[d] }
      );
      labelArray.push(React$1__default.createElement("g", {
        key: `olabel-${i}`,
        transform: `translate(${xPosition},${yPosition})`
      }, label));
    });

    if (projection === PROJECTION_VERTICAL) {
      let labelY;

      if (labelSettings.orient === 'top') {
        labelY = -15;
      } else {
        labelY = 15 + rScale.range()[1];
      }

      oLabels = React$1__default.createElement("g", {
        key: "ordinalframe-labels-container",
        className: "ordinal-labels",
        transform: `translate(${margin.left},${labelY + margin.top})`
      }, labelArray);
    } else if (projection === PROJECTION_HORIZONTAL) {
      oLabels = React$1__default.createElement("g", {
        key: "ordinalframe-labels-container",
        className: "ordinal-labels",
        transform: `translate(${margin.left},${margin.top})`
      }, labelArray);
    } else if (projection === PROJECTION_RADIAL) {
      oLabels = React$1__default.createElement("g", {
        key: "ordinalframe-labels-container",
        className: "ordinal-labels",
        transform: `translate(${margin.left},${margin.top})`
      }, labelArray);
    }
  }

  let columnOverlays;

  if (props.hoverAnnotation) {
    columnOverlays = oExtent.map((d, i) => {
      const barColumnWidth = projectedColumns[d].width;
      let xPosition = projectedColumns[d].x;
      let yPosition = 0;
      let height = rScale.range()[1];
      let width = barColumnWidth + padding;

      if (projection === PROJECTION_HORIZONTAL) {
        yPosition = projectedColumns[d].x;
        xPosition = 0;
        width = rScale.range()[1];
        height = barColumnWidth;
      }

      if (projection === PROJECTION_RADIAL) {
        const {
          markD,
          centroid,
          translate,
          midAngle
        } = pieArcs[i];
        const radialMousePackage = {
          type: 'column-hover',
          column: projectedColumns[d],
          pieces: projectedColumns[d].pieceData,
          summary: projectedColumns[d].pieceData,
          arcAngles: {
            centroid,
            translate,
            midAngle,
            length: rScale.range()[1] / 2
          }
        };
        return {
          markType: 'path',
          key: `hover${d}`,
          d: markD,
          transform: `translate(${translate.join(',')})`,
          style: {
            opacity: 0,
            fill: 'pink'
          },
          overlayData: radialMousePackage,
          onDoubleClick: customDoubleClickBehavior && (() => {
            customDoubleClickBehavior(radialMousePackage);
          }),
          onClick: customClickBehavior && (() => {
            customClickBehavior(radialMousePackage);
          }),
          onMouseEnter: customHoverBehavior && (() => {
            customHoverBehavior(radialMousePackage);
          }),
          onMouseLeave: customHoverBehavior && (() => {
            customHoverBehavior();
          })
        };
      }

      const baseMousePackage = {
        type: 'column-hover',
        column: projectedColumns[d],
        pieces: projectedColumns[d].pieceData,
        summary: projectedColumns[d].pieceData
      };
      return {
        markType: 'rect',
        key: `hover-${d}`,
        x: xPosition,
        y: yPosition,
        height: height,
        width: width,
        style: {
          opacity: 0,
          stroke: 'black',
          fill: 'pink'
        },
        onDoubleClick: customDoubleClickBehavior && (() => {
          customDoubleClickBehavior(baseMousePackage);
        }),
        onClick: customClickBehavior && (() => {
          customClickBehavior(baseMousePackage);
        }),
        onMouseEnter: customHoverBehavior && (() => {
          customHoverBehavior(baseMousePackage);
        }),
        onMouseLeave: () => ({}),
        overlayData: baseMousePackage
      };
    });
  }

  let screenCoordinates;
  const pieceTypeForXY = pieceType && pieceType !== NONE ? pieceType : ORDINAL_POINT;
  const pieceTypeLayout = typeof pieceTypeForXY === 'function' ? pieceTypeForXY : singleOrdinalPlot.type.layout;
  const calculatedPieceData = pieceTypeLayout({ ...singleOrdinalPlot.props,
    data: projectedColumns,
    renderMode: stringToFn(renderMode, undefined, true),
    eventListenersGenerator,
    styleFn: pieceStyle,
    projection,
    classFn: pieceClass,
    adjustedSize,
    chartSize: size,
    margin,
    rScale,
    baseMarkProps
  });
  const keyedData = calculatedPieceData.reduce((p, c) => {
    if (c.o) {
      if (!p[c.o]) {
        p[c.o] = [];
      }

      p[c.o].push(c);
    }

    return p;
  }, {});
  Object.keys(projectedColumns).forEach(d => {
    projectedColumns[d].xyData = keyedData[d] || [];
  });
  let calculatedSummaries = {};

  if (summaryType.type && summaryType.type !== NONE) {
    calculatedSummaries = drawSummaries({
      data: projectedColumns,
      type: summaryType,
      renderMode: stringToFn(summaryRenderMode, undefined, true),
      styleFn: stringToFn(summaryStyle, () => ({}), true),
      classFn: stringToFn(summaryClass, () => '', true),
      //        canvasRender: stringToFn<boolean>(summaryUseCanvas, undefined, true),
      positionFn: summaryPosition,
      projection,
      eventListenersGenerator,
      adjustedSize,
      baseMarkProps,
      //        chartSize: size,
      margin
    });
    calculatedSummaries.originalData = projectedColumns;
  }

  const yMod = projection === PROJECTION_HORIZONTAL ? midMod : zeroFunction;
  const xMod = projection === PROJECTION_VERTICAL ? midMod : zeroFunction;
  const basePieceData = calculatedPieceData.map(d => {
    if (d.piece && d.xy) {
      return { ...d.piece,
        type: 'frame-hover',
        x: d.xy.x + xMod(d.xy),
        y: d.xy.y + yMod(d.xy)
      };
    }

    return null;
  }).filter(d => d);

  if (pieceHoverAnnotation && [BAR, CLUSTER_BAR, TIMELINE].indexOf(pieceType) === -1 || summaryHoverAnnotation) {
    if (summaryHoverAnnotation && calculatedSummaries.xyPoints) {
      screenCoordinates = calculatedSummaries.xyPoints.map(d => Object.assign({}, d, {
        type: 'frame-hover',
        isSummaryData: true,
        x: d.x,
        y: d.y
      }));
    } else if (pieceHoverAnnotation && calculatedPieceData) {
      screenCoordinates = basePieceData;
    }
  }

  const {
    innerRadius
  } = singleOrdinalPlot.props; // todo: move to toAxes

  const {
    axis,
    axesTickLines
  } = orFrameAxisGenerator({
    axis: arrayWrappedAxis,
    data: allData,
    projection,
    adjustedSize,
    size,
    rScale,
    rScaleType: instantiatedRScaleType.copy(),
    innerRadius,
    rExtent,
    maxColumnValues,
    xyData: basePieceData,
    margin
  });

  if (pieceHoverAnnotation && [BAR, CLUSTER_BAR, TIMELINE].indexOf(pieceType) !== -1) {
    const yMod = projection === PROJECTION_HORIZONTAL ? midMod : zeroFunction;
    const xMod = projection === PROJECTION_VERTICAL ? midMod : zeroFunction;
    columnOverlays = calculatedPieceData.map((d, i) => {
      const mousePackage = { ...d.piece,
        x: d.xy.x + xMod(d.xy),
        y: d.xy.y + yMod(d.xy)
      };

      if (React$1__default.isValidElement(d.renderElement)) {
        return {
          renderElement: d.renderElement,
          overlayData: mousePackage
        };
      }

      return { ...d.renderElement,
        key: `hover-${i}`,
        type: 'frame-hover',
        style: {
          opacity: 0,
          stroke: 'black',
          fill: 'pink'
        },
        overlayData: mousePackage,
        onClick: customClickBehavior && (() => {
          customClickBehavior(mousePackage.data);
        }),
        onDoubleClick: customDoubleClickBehavior && (() => {
          customDoubleClickBehavior(mousePackage.data);
        }),
        onMouseEnter: customHoverBehavior && (() => {
          customHoverBehavior(mousePackage.data);
        }),
        onMouseLeave: customHoverBehavior && (() => {
          customHoverBehavior();
        })
      };
    });
  }

  const typeAriaLabel = naturalLanguageTypes[pieceType] || {
    items: 'piece',
    chart: 'ordinal chart'
  };
  const {
    svgPipe,
    canvasPipe
  } = toPipeline$1({
    shouldRender: pieceType !== NONE,
    isOrdinalPoint: pieceType === 'ordinalpoint',
    pieceData: calculatedPieceData,
    pieceUseCanvas,
    pieceStyle: stringToFn(pieceStyle, () => ({}), true),
    pieceClass: stringToFn(pieceClass, () => '', true),
    connectorType: objectifyType(baseConnectorType),
    connectorData: keyedData,
    connectorStyle: stringToFn(connectorStyle, () => ({}), true),
    connectorClass: stringToFn(connectorClass, () => '', true),
    connectorUseCanvas,
    connectorRenderMode: stringToFn(connectorRenderMode, undefined, true),
    projection,
    ariaLabel: typeAriaLabel,
    axis: arrayWrappedAxis
  });
  const svgPipeline = [...svgPipe, ...(calculatedSummaries.marks || [])];
  const canvasPipeline = canvasPipe.slice();

  if (rExtentSettings.onChange && (calculatedRExtent || []).join(',') !== (calculatedRExtent || []).join(',')) {
    rExtentSettings.onChange(calculatedRExtent);
  }

  if (oExtentSettings.onChange && (calculatedOExtent || []).join(',') !== (calculatedOExtent || []).join(',')) {
    oExtentSettings.onChange(calculatedOExtent);
  }

  let interactionOverflow;

  if (summaryType && summaryType.amplitude) {
    if (projection === PROJECTION_HORIZONTAL) {
      interactionOverflow = {
        top: summaryType.amplitude,
        bottom: 0,
        left: 0,
        right: 0
      };
    } else if (projection === PROJECTION_RADIAL) {
      interactionOverflow = defaultOverflow;
    } else {
      interactionOverflow = {
        top: 0,
        bottom: 0,
        left: summaryType.amplitude,
        right: 0
      };
    }
  }

  return {
    projectedColumns,
    pieceIDAccessor,
    oColumn: null,
    canvasPipeline,
    svgPipeline,
    screenCoordinates,
    xyPoints: [],
    adjustedPosition,
    adjustedSize,
    axes: axis,
    axesTickLines,
    overlay: columnOverlays,
    interactionOverflow,
    projection,
    oAccessor,
    rAccessor,
    rScale,
    rScaleType,
    summaryType,
    type: pieceType
  };
};

function ascending$7(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}

function bisector$3(compare) {
  if (compare.length === 1) compare = ascendingComparator$3(compare);
  return {
    left: function(a, x, lo, hi) {
      if (lo == null) lo = 0;
      if (hi == null) hi = a.length;
      while (lo < hi) {
        var mid = lo + hi >>> 1;
        if (compare(a[mid], x) < 0) lo = mid + 1;
        else hi = mid;
      }
      return lo;
    },
    right: function(a, x, lo, hi) {
      if (lo == null) lo = 0;
      if (hi == null) hi = a.length;
      while (lo < hi) {
        var mid = lo + hi >>> 1;
        if (compare(a[mid], x) > 0) hi = mid;
        else lo = mid + 1;
      }
      return lo;
    }
  };
}

function ascendingComparator$3(f) {
  return function(d, x) {
    return ascending$7(f(d), x);
  };
}

var ascendingBisect$3 = bisector$3(ascending$7);

function number$4(x) {
  return x === null ? NaN : +x;
}

function max$5(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      max;

  if (valueof == null) {
    while (++i < n) { // Find the first comparable value.
      if ((value = values[i]) != null && value >= value) {
        max = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = values[i]) != null && value > max) {
            max = value;
          }
        }
      }
    }
  }

  else {
    while (++i < n) { // Find the first comparable value.
      if ((value = valueof(values[i], i, values)) != null && value >= value) {
        max = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = valueof(values[i], i, values)) != null && value > max) {
            max = value;
          }
        }
      }
    }
  }

  return max;
}

function mean(values, valueof) {
  var n = values.length,
      m = n,
      i = -1,
      value,
      sum = 0;

  if (valueof == null) {
    while (++i < n) {
      if (!isNaN(value = number$4(values[i]))) sum += value;
      else --m;
    }
  }

  else {
    while (++i < n) {
      if (!isNaN(value = number$4(valueof(values[i], i, values)))) sum += value;
      else --m;
    }
  }

  if (m) return sum / m;
}

function min$4(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      min;

  if (valueof == null) {
    while (++i < n) { // Find the first comparable value.
      if ((value = values[i]) != null && value >= value) {
        min = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = values[i]) != null && min > value) {
            min = value;
          }
        }
      }
    }
  }

  else {
    while (++i < n) { // Find the first comparable value.
      if ((value = valueof(values[i], i, values)) != null && value >= value) {
        min = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = valueof(values[i], i, values)) != null && min > value) {
            min = value;
          }
        }
      }
    }
  }

  return min;
}

function sum$3(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      sum = 0;

  if (valueof == null) {
    while (++i < n) {
      if (value = +values[i]) sum += value; // Note: zero and null are equivalent.
    }
  }

  else {
    while (++i < n) {
      if (value = +valueof(values[i], i, values)) sum += value;
    }
  }

  return sum;
}

var scc = stronglyConnectedComponents;

function stronglyConnectedComponents(adjList) {
  var numVertices = adjList.length;
  var index = new Array(numVertices);
  var lowValue = new Array(numVertices);
  var active = new Array(numVertices);
  var child = new Array(numVertices);
  var scc = new Array(numVertices);
  var sccLinks = new Array(numVertices);
  
  //Initialize tables
  for(var i=0; i<numVertices; ++i) {
    index[i] = -1;
    lowValue[i] = 0;
    active[i] = false;
    child[i] = 0;
    scc[i] = -1;
    sccLinks[i] = [];
  }

  // The strongConnect function
  var count = 0;
  var components = [];
  var sccAdjList = [];

  function strongConnect(v) {
    // To avoid running out of stack space, this emulates the recursive behaviour of the normal algorithm, effectively using T as the call stack.
    var S = [v], T = [v];
    index[v] = lowValue[v] = count;
    active[v] = true;
    count += 1;
    while(T.length > 0) {
      v = T[T.length-1];
      var e = adjList[v];
      if (child[v] < e.length) { // If we're not done iterating over the children, first try finishing that.
        for(var i=child[v]; i<e.length; ++i) { // Start where we left off.
          var u = e[i];
          if(index[u] < 0) {
            index[u] = lowValue[u] = count;
            active[u] = true;
            count += 1;
            S.push(u);
            T.push(u);
            break // First recurse, then continue here (with the same child!).
            // There is a slight change to Tarjan's algorithm here.
            // Normally, after having recursed, we set lowValue like we do for an active child (although some variants of the algorithm do it slightly differently).
            // Here, we only do so if the child we recursed on is still active.
            // The reasoning is that if it is no longer active, it must have had a lowValue equal to its own index, which means that it is necessarily higher than our lowValue.
          } else if (active[u]) {
            lowValue[v] = Math.min(lowValue[v], lowValue[u])|0;
          }
          if (scc[u] >= 0) {
            // Node v is not yet assigned an scc, but once it is that scc can apparently reach scc[u].
            sccLinks[v].push(scc[u]);
          }
        }
        child[v] = i; // Remember where we left off.
      } else { // If we're done iterating over the children, check whether we have an scc.
        if(lowValue[v] === index[v]) { // TODO: It /might/ be true that T is always a prefix of S (at this point!!!), and if so, this could be used here.
          var component = [];
          var links = [], linkCount = 0;
          for(var i=S.length-1; i>=0; --i) {
            var w = S[i];
            active[w] = false;
            component.push(w);
            links.push(sccLinks[w]);
            linkCount += sccLinks[w].length;
            scc[w] = components.length;
            if(w === v) {
              S.length = i;
              break
            }
          }
          components.push(component);
          var allLinks = new Array(linkCount);
          for(var i=0; i<links.length; i++) {
            for(var j=0; j<links[i].length; j++) {
              allLinks[--linkCount] = links[i][j];
            }
          }
          sccAdjList.push(allLinks);
        }
        T.pop(); // Now we're finished exploring this particular node (normally corresponds to the return statement)
      }
    }
  }

  //Run strong connect starting from each vertex
  for(var i=0; i<numVertices; ++i) {
    if(index[i] < 0) {
      strongConnect(i);
    }
  }
  
  // Compact sccAdjList
  var newE;
  for(var i=0; i<sccAdjList.length; i++) {
    var e = sccAdjList[i];
    if (e.length === 0) continue
    e.sort(function (a,b) { return a-b; });
    newE = [e[0]];
    for(var j=1; j<e.length; j++) {
      if (e[j] !== e[j-1]) {
        newE.push(e[j]);
      }
    }
    sccAdjList[i] = newE;
  }  

  return {components: components, adjacencyList: sccAdjList}
}

var johnson = function findCircuits(edges) {
    var circuits = []; // Output

    var stack = [];
    var blocked = [];
    var B = {};
    var Ak = [];
    var s;

    function unblock(u) {
        blocked[u] = false;
        if(B.hasOwnProperty(u)) {
            Object.keys(B[u]).forEach(function(w) {
                delete B[u][w];
                if(blocked[w]) {unblock(w);}
            });
        }
    }

    function circuit(v) {
        var found = false;

        stack.push(v);
        blocked[v] = true;

        // L1
        var i;
        var w;
        for(i = 0; i < Ak[v].length; i++) {
            w = Ak[v][i];
            if(w === s) {
                output(s, stack);
                found = true;
            } else if(!blocked[w]) {
                found = circuit(w);
            }
        }

        // L2
        if(found) {
            unblock(v);
        } else {
            for(i = 0; i < Ak[v].length; i++) {
                w = Ak[v][i];
                var entry = B[w];

                if(!entry) {
                    entry = {};
                    B[w] = entry;
                }

                entry[w] = true;
            }
        }
        stack.pop();
        return found;
    }

    function output(start, stack) {
        var cycle = [].concat(stack).concat(start);
        circuits.push(cycle);
    }

    function subgraph(minId) {
      // Remove edges with indice smaller than minId
        for(var i = 0; i < edges.length; i++) {
            if(i < minId) edges[i] = [];
            edges[i] = edges[i].filter(function(i) {
                return i >= minId;
            });
        }
    }

    function adjacencyStructureSCC(from) {
      // Make subgraph starting from vertex minId
        subgraph(from);
        var g = edges;

      // Find strongly connected components using Tarjan algorithm
        var sccs = scc(g);

      // Filter out trivial connected components (ie. made of one node)
        var ccs = sccs.components.filter(function(scc) {
            return scc.length > 1;
        });

      // Find least vertex
        var leastVertex = Infinity;
        var leastVertexComponent;
        for(var i = 0; i < ccs.length; i++) {
            for(var j = 0; j < ccs[i].length; j++) {
                if(ccs[i][j] < leastVertex) {
                    leastVertex = ccs[i][j];
                    leastVertexComponent = i;
                }
            }
        }

        var cc = ccs[leastVertexComponent];

        if(!cc) return false;

      // Return the adjacency list of first component
        var adjList = edges.map(function(l, index) {
            if(cc.indexOf(index) === -1) return [];
            return l.filter(function(i) {
                return cc.indexOf(i) !== -1;
            });
        });

        return {
            leastVertex: leastVertex,
            adjList: adjList
        };
    }

    s = 0;
    var n = edges.length;
    while(s < n) {
        // find strong component with least vertex in
        // subgraph starting from vertex `s`
        var p = adjacencyStructureSCC(s);

        // Its least vertex
        s = p.leastVertex;
        // Its adjacency list
        Ak = p.adjList;

        if(Ak) {
            for(var i = 0; i < Ak.length; i++) {
                for(var j = 0; j < Ak[i].length; j++) {
                    var vertexId = Ak[i][j];
                    blocked[+vertexId] = false;
                    B[vertexId] = {};
                }
            }
            circuit(s);
            s = s + 1;
        } else {
            s = n;
        }

    }

    return circuits;
};

// For a given link, return the target node's depth
function targetDepth(d) {
  return d.target.depth;
}

// The depth of a node when the nodeAlign (align) is set to 'left'
function left(node) {
  return node.depth;
}

// The depth of a node when the nodeAlign (align) is set to 'right'
function right(node, n) {
  return n - 1 - node.height;
}

// The depth of a node when the nodeAlign (align) is set to 'justify'
function justify(node, n) {
  return node.sourceLinks.length ? node.depth : n - 1;
}

// The depth of a node when the nodeAlign (align) is set to 'center'
function center(node) {
  return node.targetLinks.length ? node.depth : node.sourceLinks.length ? min$4(node.sourceLinks, targetDepth) - 1 : 0;
}

// returns a function, using the parameter given to the sankey setting
function constant$c(x) {
  return function () {
    return x;
  };
}

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};

/// https://github.com/tomshanley/d3-sankeyCircular-circular

// sort links' breadth (ie top to bottom in a column), based on their source nodes' breadths
function ascendingSourceBreadth(a, b) {
  return ascendingBreadth(a.source, b.source) || a.HospitalFacilities - b.HospitalFacilities;
}

// sort links' breadth (ie top to bottom in a column), based on their target nodes' breadths
function ascendingTargetBreadth(a, b) {
  return ascendingBreadth(a.target, b.target) || a.HospitalFacilities - b.HospitalFacilities;
}

// sort nodes' breadth (ie top to bottom in a column)
// if both nodes have circular links, or both don't have circular links, then sort by the top (y0) of the node
// else push nodes that have top circular links to the top, and nodes that have bottom circular links to the bottom
function ascendingBreadth(a, b) {
  if (a.partOfCycle === b.partOfCycle) {
    return a.y0 - b.y0;
  } else {
    if (a.circularLinkType === 'top' || b.circularLinkType === 'bottom') {
      return -1;
    } else {
      return 1;
    }
  }
}

// return the value of a node or link
function value(d) {
  return d.value;
}

// return the vertical center of a node
function nodeCenter(node) {
  return (node.y0 + node.y1) / 2;
}

// return the vertical center of a link's source node
function linkSourceCenter(link) {
  return nodeCenter(link.source);
}

// return the vertical center of a link's target node
function linkTargetCenter(link) {
  return nodeCenter(link.target);
}

// Return the default value for ID for node, d.index
function defaultId(d) {
  return d.HospitalFacilities;
}

// Return the default object the graph's nodes, graph.nodes
function defaultNodes(graph) {
  return graph.nodes;
}

// Return the default object the graph's nodes, graph.links
function defaultLinks(graph) {
  return graph.links;
}

// Return the node from the collection that matches the provided ID, or throw an error if no match
function find$1(nodeById, id) {
  var node = nodeById.get(id);
  if (!node) throw new Error('missing: ' + id);
  return node;
}

function getNodeID(node, id) {
  return id(node);
}

// The main sankeyCircular functions

// Some constants for circular link calculations
var verticalMargin = 25;
var baseRadius = 10;
var scale = 0.3; //Possibly let user control this, although anything over 0.5 starts to get too cramped

function sankeyCircular () {
  // Set the default values
  var x0 = 0,
      y0 = 0,
      x1 = 1,
      y1 = 1,
      // extent
  dx = 24,
      // nodeWidth
  py,
      // nodePadding, for vertical postioning
  id = defaultId,
      align = justify,
      nodes = defaultNodes,
      links = defaultLinks,
      iterations = 32,
      circularLinkGap = 2,
      paddingRatio,
      sortNodes = null;

  function sankeyCircular() {
    var graph = {
      nodes: nodes.apply(null, arguments),
      links: links.apply(null, arguments)

      // Process the graph's nodes and links, setting their positions

      // 1.  Associate the nodes with their respective links, and vice versa
    };computeNodeLinks(graph);

    // 2.  Determine which links result in a circular path in the graph
    identifyCircles(graph, id, sortNodes);

    // 4. Calculate the nodes' values, based on the values of the incoming and outgoing links
    computeNodeValues(graph);

    // 5.  Calculate the nodes' depth based on the incoming and outgoing links
    //     Sets the nodes':
    //     - depth:  the depth in the graph
    //     - column: the depth (0, 1, 2, etc), as is relates to visual position from left to right
    //     - x0, x1: the x coordinates, as is relates to visual position from left to right
    computeNodeDepths(graph);

    // 3.  Determine how the circular links will be drawn,
    //     either travelling back above the main chart ("top")
    //     or below the main chart ("bottom")
    selectCircularLinkTypes(graph, id);

    // 6.  Calculate the nodes' and links' vertical position within their respective column
    //     Also readjusts sankeyCircular size if circular links are needed, and node x's
    computeNodeBreadths(graph, iterations, id);
    computeLinkBreadths(graph);

    // 7.  Sort links per node, based on the links' source/target nodes' breadths
    // 8.  Adjust nodes that overlap links that span 2+ columns
    var linkSortingIterations = 4; //Possibly let user control this number, like the iterations over node placement
    for (var iteration = 0; iteration < linkSortingIterations; iteration++) {

      sortSourceLinks(graph, y1, id);
      sortTargetLinks(graph, y1, id);
      resolveNodeLinkOverlaps(graph, y0, y1, id);
      sortSourceLinks(graph, y1, id);
      sortTargetLinks(graph, y1, id);
    }

    // 8.1  Adjust node and link positions back to fill height of chart area if compressed
    fillHeight(graph, y0, y1);

    // 9. Calculate visually appealling path for the circular paths, and create the "d" string
    addCircularPathData(graph, circularLinkGap, y1, id);

    return graph;
  } // end of sankeyCircular function


  // Set the sankeyCircular parameters
  // nodeID, nodeAlign, nodeWidth, nodePadding, nodes, links, size, extent, iterations, nodePaddingRatio, circularLinkGap
  sankeyCircular.nodeId = function (_) {
    return arguments.length ? (id = typeof _ === 'function' ? _ : constant$c(_), sankeyCircular) : id;
  };

  sankeyCircular.nodeAlign = function (_) {
    return arguments.length ? (align = typeof _ === 'function' ? _ : constant$c(_), sankeyCircular) : align;
  };

  sankeyCircular.nodeWidth = function (_) {
    return arguments.length ? (dx = +_, sankeyCircular) : dx;
  };

  sankeyCircular.nodePadding = function (_) {
    return arguments.length ? (py = +_, sankeyCircular) : py;
  };

  sankeyCircular.nodes = function (_) {
    return arguments.length ? (nodes = typeof _ === 'function' ? _ : constant$c(_), sankeyCircular) : nodes;
  };

  sankeyCircular.links = function (_) {
    return arguments.length ? (links = typeof _ === 'function' ? _ : constant$c(_), sankeyCircular) : links;
  };

  sankeyCircular.size = function (_) {
    return arguments.length ? (x0 = y0 = 0, x1 = +_[0], y1 = +_[1], sankeyCircular) : [x1 - x0, y1 - y0];
  };

  sankeyCircular.extent = function (_) {
    return arguments.length ? (x0 = +_[0][0], x1 = +_[1][0], y0 = +_[0][1], y1 = +_[1][1], sankeyCircular) : [[x0, y0], [x1, y1]];
  };

  sankeyCircular.iterations = function (_) {
    return arguments.length ? (iterations = +_, sankeyCircular) : iterations;
  };

  sankeyCircular.circularLinkGap = function (_) {
    return arguments.length ? (circularLinkGap = +_, sankeyCircular) : circularLinkGap;
  };

  sankeyCircular.nodePaddingRatio = function (_) {
    return arguments.length ? (paddingRatio = +_, sankeyCircular) : paddingRatio;
  };

  sankeyCircular.sortNodes = function (_) {
    return arguments.length ? (sortNodes = _, sankeyCircular) : sortNodes;
  };

  sankeyCircular.update = function (graph) {
    // 5.  Calculate the nodes' depth based on the incoming and outgoing links
    //     Sets the nodes':
    //     - depth:  the depth in the graph
    //     - column: the depth (0, 1, 2, etc), as is relates to visual position from left to right
    //     - x0, x1: the x coordinates, as is relates to visual position from left to right
    // computeNodeDepths(graph)

    // 3.  Determine how the circular links will be drawn,
    //     either travelling back above the main chart ("top")
    //     or below the main chart ("bottom")
    selectCircularLinkTypes(graph, id);

    // 6.  Calculate the nodes' and links' vertical position within their respective column
    //     Also readjusts sankeyCircular size if circular links are needed, and node x's
    // computeNodeBreadths(graph, iterations, id)
    computeLinkBreadths(graph);

    // Force position of circular link type based on position
    graph.links.forEach(function (link) {
      if (link.circular) {
        link.circularLinkType = link.y0 + link.y1 < y1 ? 'top' : 'bottom';

        link.source.circularLinkType = link.circularLinkType;
        link.target.circularLinkType = link.circularLinkType;
      }
    });

    sortSourceLinks(graph, y1, id, false); // Sort links but do not move nodes
    sortTargetLinks(graph, y1, id);

    // 7.  Sort links per node, based on the links' source/target nodes' breadths
    // 8.  Adjust nodes that overlap links that span 2+ columns
    // var linkSortingIterations = 4; //Possibly let user control this number, like the iterations over node placement
    // for (var iteration = 0; iteration < linkSortingIterations; iteration++) {
    //
    //   sortSourceLinks(graph, y1, id)
    //   sortTargetLinks(graph, y1, id)
    //   resolveNodeLinkOverlaps(graph, y0, y1, id)
    //   sortSourceLinks(graph, y1, id)
    //   sortTargetLinks(graph, y1, id)
    //
    // }

    // 8.1  Adjust node and link positions back to fill height of chart area if compressed
    // fillHeight(graph, y0, y1)

    // 9. Calculate visually appealling path for the circular paths, and create the "d" string
    addCircularPathData(graph, circularLinkGap, y1, id);
    return graph;
  };

  // Populate the sourceLinks and targetLinks for each node.
  // Also, if the source and target are not objects, assume they are indices.
  function computeNodeLinks(graph) {
    graph.nodes.forEach(function (node, i) {
      node.index = i;
      node.sourceLinks = [];
      node.targetLinks = [];
    });
    var nodeById = map$1(graph.nodes, id);
    graph.links.forEach(function (link, i) {
      link.index = i;
      var source = link.source;
      var target = link.target;
      if ((typeof source === "undefined" ? "undefined" : _typeof(source)) !== 'object') {
        source = link.source = find$1(nodeById, source);
      }
      if ((typeof target === "undefined" ? "undefined" : _typeof(target)) !== 'object') {
        target = link.target = find$1(nodeById, target);
      }
      source.sourceLinks.push(link);
      target.targetLinks.push(link);
    });
    return graph;
  }

  // Compute the value (size) and cycleness of each node by summing the associated links.
  function computeNodeValues(graph) {
    graph.nodes.forEach(function (node) {
      node.partOfCycle = false;
      node.value = Math.max(sum$3(node.sourceLinks, value), sum$3(node.targetLinks, value));
      node.sourceLinks.forEach(function (link) {
        if (link.circular) {
          node.partOfCycle = true;
          node.circularLinkType = link.circularLinkType;
        }
      });
      node.targetLinks.forEach(function (link) {
        if (link.circular) {
          node.partOfCycle = true;
          node.circularLinkType = link.circularLinkType;
        }
      });
    });
  }

  function getCircleMargins(graph) {
    var totalTopLinksWidth = 0,
        totalBottomLinksWidth = 0,
        totalRightLinksWidth = 0,
        totalLeftLinksWidth = 0;

    var maxColumn = max$5(graph.nodes, function (node) {
      return node.column;
    });

    graph.links.forEach(function (link) {
      if (link.circular) {
        if (link.circularLinkType == 'top') {
          totalTopLinksWidth = totalTopLinksWidth + link.width;
        } else {
          totalBottomLinksWidth = totalBottomLinksWidth + link.width;
        }

        if (link.target.column == 0) {
          totalLeftLinksWidth = totalLeftLinksWidth + link.width;
        }

        if (link.source.column == maxColumn) {
          totalRightLinksWidth = totalRightLinksWidth + link.width;
        }
      }
    });

    //account for radius of curves and padding between links
    totalTopLinksWidth = totalTopLinksWidth > 0 ? totalTopLinksWidth + verticalMargin + baseRadius : totalTopLinksWidth;
    totalBottomLinksWidth = totalBottomLinksWidth > 0 ? totalBottomLinksWidth + verticalMargin + baseRadius : totalBottomLinksWidth;
    totalRightLinksWidth = totalRightLinksWidth > 0 ? totalRightLinksWidth + verticalMargin + baseRadius : totalRightLinksWidth;
    totalLeftLinksWidth = totalLeftLinksWidth > 0 ? totalLeftLinksWidth + verticalMargin + baseRadius : totalLeftLinksWidth;

    return { "top": totalTopLinksWidth, "bottom": totalBottomLinksWidth, "left": totalLeftLinksWidth, "right": totalRightLinksWidth };
  }

  // Update the x0, y0, x1 and y1 for the sankeyCircular, to allow space for any circular links
  function scaleSankeySize(graph, margin) {

    var maxColumn = max$5(graph.nodes, function (node) {
      return node.column;
    });

    var currentWidth = x1 - x0;
    var currentHeight = y1 - y0;

    var newWidth = currentWidth + margin.right + margin.left;
    var newHeight = currentHeight + margin.top + margin.bottom;

    var scaleX = currentWidth / newWidth;
    var scaleY = currentHeight / newHeight;

    x0 = x0 * scaleX + margin.left;
    x1 = margin.right == 0 ? x1 : x1 * scaleX;
    y0 = y0 * scaleY + margin.top;
    y1 = y1 * scaleY;

    graph.nodes.forEach(function (node) {
      node.x0 = x0 + node.column * ((x1 - x0 - dx) / maxColumn);
      node.x1 = node.x0 + dx;
    });

    return scaleY;
  }

  // Iteratively assign the depth for each node.
  // Nodes are assigned the maximum depth of incoming neighbors plus one;
  // nodes with no incoming links are assigned depth zero, while
  // nodes with no outgoing links are assigned the maximum depth.
  function computeNodeDepths(graph) {
    var nodes, next, x;

    for (nodes = graph.nodes, next = [], x = 0; nodes.length; ++x, nodes = next, next = []) {
      nodes.forEach(function (node) {
        node.depth = x;
        node.sourceLinks.forEach(function (link) {
          if (next.indexOf(link.target) < 0 && !link.circular) {
            next.push(link.target);
          }
        });
      });
    }

    for (nodes = graph.nodes, next = [], x = 0; nodes.length; ++x, nodes = next, next = []) {
      nodes.forEach(function (node) {
        node.height = x;
        node.targetLinks.forEach(function (link) {
          if (next.indexOf(link.source) < 0 && !link.circular) {
            next.push(link.source);
          }
        });
      });
    }

    // assign column numbers, and get max value
    graph.nodes.forEach(function (node) {
      node.column = Math.floor(align.call(null, node, x));
    });
  }

  // Assign nodes' breadths, and then shift nodes that overlap (resolveCollisions)
  function computeNodeBreadths(graph, iterations, id) {
    var columns = nest$1().key(function (d) {
      return d.column;
    }).sortKeys(ascending$7).entries(graph.nodes).map(function (d) {
      return d.values;
    });

    initializeNodeBreadth(id);
    resolveCollisions();

    for (var alpha = 1, n = iterations; n > 0; --n) {
      relaxLeftAndRight(alpha *= 0.99, id);
      resolveCollisions();
    }

    function initializeNodeBreadth(id) {

      //override py if nodePadding has been set
      if (paddingRatio) {
        var padding = Infinity;
        columns.forEach(function (nodes) {
          var thisPadding = y1 * paddingRatio / (nodes.length + 1);
          padding = thisPadding < padding ? thisPadding : padding;
        });
        py = padding;
      }

      var ky = min$4(columns, function (nodes) {
        return (y1 - y0 - (nodes.length - 1) * py) / sum$3(nodes, value);
      });

      //calculate the widths of the links
      ky = ky * scale;

      graph.links.forEach(function (link) {
        link.width = link.value * ky;
      });

      //determine how much to scale down the chart, based on circular links
      var margin = getCircleMargins(graph);
      var ratio = scaleSankeySize(graph, margin);

      //re-calculate widths
      ky = ky * ratio;

      graph.links.forEach(function (link) {
        link.width = link.value * ky;
      });

      columns.forEach(function (nodes) {
        var nodesLength = nodes.length;
        nodes.forEach(function (node, i) {
          if (node.depth == columns.length - 1 && nodesLength == 1) {
            node.y0 = y1 / 2 - node.value * ky;
            node.y1 = node.y0 + node.value * ky;
          } else if (node.depth == 0 && nodesLength == 1) {
            node.y0 = y1 / 2 - node.value * ky;
            node.y1 = node.y0 + node.value * ky;
          } else if (node.partOfCycle) {
            if (numberOfNonSelfLinkingCycles(node, id) == 0) {
              node.y0 = y1 / 2 + i;
              node.y1 = node.y0 + node.value * ky;
            } else if (node.circularLinkType == 'top') {
              node.y0 = y0 + i;
              node.y1 = node.y0 + node.value * ky;
            } else {
              node.y0 = y1 - node.value * ky - i;
              node.y1 = node.y0 + node.value * ky;
            }
          } else {
            if (margin.top == 0 || margin.bottom == 0) {
              node.y0 = (y1 - y0) / nodesLength * i;
              node.y1 = node.y0 + node.value * ky;
            } else {
              node.y0 = (y1 - y0) / 2 - nodesLength / 2 + i;
              node.y1 = node.y0 + node.value * ky;
            }
          }
        });
      });
    }

    // For each node in each column, check the node's vertical position in relation to its targets and sources vertical position
    // and shift up/down to be closer to the vertical middle of those targets and sources
    function relaxLeftAndRight(alpha, id) {
      var columnsLength = columns.length;

      columns.forEach(function (nodes) {
        var n = nodes.length;
        var depth = nodes[0].depth;

        nodes.forEach(function (node) {
          // check the node is not an orphan
          var nodeHeight;
          if (node.sourceLinks.length || node.targetLinks.length) {
            if (node.partOfCycle && numberOfNonSelfLinkingCycles(node, id) > 0) ; else if (depth == 0 && n == 1) {
              nodeHeight = node.y1 - node.y0;

              node.y0 = y1 / 2 - nodeHeight / 2;
              node.y1 = y1 / 2 + nodeHeight / 2;
            } else if (depth == columnsLength - 1 && n == 1) {
              nodeHeight = node.y1 - node.y0;

              node.y0 = y1 / 2 - nodeHeight / 2;
              node.y1 = y1 / 2 + nodeHeight / 2;
            } else {
              var avg = 0;

              var avgTargetY = mean(node.sourceLinks, linkTargetCenter);
              var avgSourceY = mean(node.targetLinks, linkSourceCenter);

              if (avgTargetY && avgSourceY) {
                avg = (avgTargetY + avgSourceY) / 2;
              } else {
                avg = avgTargetY || avgSourceY;
              }

              var dy = (avg - nodeCenter(node)) * alpha;
              // positive if it node needs to move down
              node.y0 += dy;
              node.y1 += dy;
            }
          }
        });
      });
    }

    // For each column, check if nodes are overlapping, and if so, shift up/down
    function resolveCollisions() {
      columns.forEach(function (nodes) {
        var node,
            dy,
            y = y0,
            n = nodes.length,
            i;

        // Push any overlapping nodes down.
        nodes.sort(ascendingBreadth);

        for (i = 0; i < n; ++i) {
          node = nodes[i];
          dy = y - node.y0;

          if (dy > 0) {
            node.y0 += dy;
            node.y1 += dy;
          }
          y = node.y1 + py;
        }

        // If the bottommost node goes outside the bounds, push it back up.
        dy = y - py - y1;
        if (dy > 0) {
          y = node.y0 -= dy, node.y1 -= dy;

          // Push any overlapping nodes back up.
          for (i = n - 2; i >= 0; --i) {
            node = nodes[i];
            dy = node.y1 + py - y;
            if (dy > 0) node.y0 -= dy, node.y1 -= dy;
            y = node.y0;
          }
        }
      });
    }
  }

  // Assign the links y0 and y1 based on source/target nodes position,
  // plus the link's relative position to other links to the same node
  function computeLinkBreadths(graph) {
    graph.nodes.forEach(function (node) {
      node.sourceLinks.sort(ascendingTargetBreadth);
      node.targetLinks.sort(ascendingSourceBreadth);
    });
    graph.nodes.forEach(function (node) {
      var y0 = node.y0;
      var y1 = y0;

      // start from the bottom of the node for cycle links
      var y0cycle = node.y1;
      var y1cycle = y0cycle;

      node.sourceLinks.forEach(function (link) {
        if (link.circular) {
          link.y0 = y0cycle - link.width / 2;
          y0cycle = y0cycle - link.width;
        } else {
          link.y0 = y0 + link.width / 2;
          y0 += link.width;
        }
      });
      node.targetLinks.forEach(function (link) {
        if (link.circular) {
          link.y1 = y1cycle - link.width / 2;
          y1cycle = y1cycle - link.width;
        } else {
          link.y1 = y1 + link.width / 2;
          y1 += link.width;
        }
      });
    });
  }

  return sankeyCircular;
}

/// /////////////////////////////////////////////////////////////////////////////////
// Cycle functions
// portion of code to detect circular links based on Colin Fergus' bl.ock https://gist.github.com/cfergus/3956043

// Identify circles in the link objects
function identifyCircles(graph, id, sortNodes) {
  var circularLinkID = 0;
  if (sortNodes === null) {

    // Building adjacency graph
    var adjList = [];
    for (var i = 0; i < graph.links.length; i++) {
      var link = graph.links[i];
      var source = link.source.HospitalFacilities;
      var target = link.target.HospitalFacilities;
      if (!adjList[source]) adjList[source] = [];
      if (!adjList[target]) adjList[target] = [];

      // Add links if not already in set
      if (adjList[source].indexOf(target) === -1) adjList[source].push(target);
    }

    // Find all elementary circuits
    var cycles = johnson(adjList);

    // Sort by circuits length
    cycles.sort(function (a, b) {
      return a.length - b.length;
    });

    var circularLinks = {};
    for (i = 0; i < cycles.length; i++) {
      var cycle = cycles[i];
      var last = cycle.slice(-2);
      if (!circularLinks[last[0]]) circularLinks[last[0]] = {};
      circularLinks[last[0]][last[1]] = true;
    }

    graph.links.forEach(function (link) {
      var target = link.target.HospitalFacilities;
      var source = link.source.HospitalFacilities;
      // If self-linking or a back-edge
      if (target === source || circularLinks[source] && circularLinks[source][target]) {
        link.circular = true;
        link.circularLinkID = circularLinkID;
        circularLinkID = circularLinkID + 1;
      } else {
        link.circular = false;
      }
    });
  } else {
    graph.links.forEach(function (link) {
      if (link.source[sortNodes] < link.target[sortNodes]) {
        link.circular = false;
      } else {
        link.circular = true;
        link.circularLinkID = circularLinkID;
        circularLinkID = circularLinkID + 1;
      }
    });
  }
}

// Assign a circular link type (top or bottom), based on:
// - if the source/target node already has circular links, then use the same type
// - if not, choose the type with fewer links
function selectCircularLinkTypes(graph, id) {
  var numberOfTops = 0;
  var numberOfBottoms = 0;
  graph.links.forEach(function (link) {
    if (link.circular) {
      // if either souce or target has type already use that
      if (link.source.circularLinkType || link.target.circularLinkType) {
        // default to source type if available
        link.circularLinkType = link.source.circularLinkType ? link.source.circularLinkType : link.target.circularLinkType;
      } else {
        link.circularLinkType = numberOfTops < numberOfBottoms ? 'top' : 'bottom';
      }

      if (link.circularLinkType == 'top') {
        numberOfTops = numberOfTops + 1;
      } else {
        numberOfBottoms = numberOfBottoms + 1;
      }

      graph.nodes.forEach(function (node) {
        if (getNodeID(node, id) == getNodeID(link.source, id) || getNodeID(node, id) == getNodeID(link.target, id)) {
          node.circularLinkType = link.circularLinkType;
        }
      });
    }
  });

  //correct self-linking links to be same direction as node
  graph.links.forEach(function (link) {
    if (link.circular) {
      //if both source and target node are same type, then link should have same type
      if (link.source.circularLinkType == link.target.circularLinkType) {
        link.circularLinkType = link.source.circularLinkType;
      }
      //if link is selflinking, then link should have same type as node
      if (selfLinking(link, id)) {
        link.circularLinkType = link.source.circularLinkType;
      }
    }
  });
}

// Return the angle between a straight line between the source and target of the link, and the vertical plane of the node
function linkAngle(link) {
  var adjacent = Math.abs(link.y1 - link.y0);
  var opposite = Math.abs(link.target.x0 - link.source.x1);

  return Math.atan(opposite / adjacent);
}

// Check if two circular links potentially overlap
function circularLinksCross(link1, link2) {
  if (link1.source.column < link2.target.column) {
    return false;
  } else if (link1.target.column > link2.source.column) {
    return false;
  } else {
    return true;
  }
}

// Return the number of circular links for node, not including self linking links
function numberOfNonSelfLinkingCycles(node, id) {
  var sourceCount = 0;
  node.sourceLinks.forEach(function (l) {
    sourceCount = l.circular && !selfLinking(l, id) ? sourceCount + 1 : sourceCount;
  });

  var targetCount = 0;
  node.targetLinks.forEach(function (l) {
    targetCount = l.circular && !selfLinking(l, id) ? targetCount + 1 : targetCount;
  });

  return sourceCount + targetCount;
}

// Check if a circular link is the only circular link for both its source and target node
function onlyCircularLink(link) {
  var nodeSourceLinks = link.source.sourceLinks;
  var sourceCount = 0;
  nodeSourceLinks.forEach(function (l) {
    sourceCount = l.circular ? sourceCount + 1 : sourceCount;
  });

  var nodeTargetLinks = link.target.targetLinks;
  var targetCount = 0;
  nodeTargetLinks.forEach(function (l) {
    targetCount = l.circular ? targetCount + 1 : targetCount;
  });

  if (sourceCount > 1 || targetCount > 1) {
    return false;
  } else {
    return true;
  }
}

// creates vertical buffer values per set of top/bottom links
function calcVerticalBuffer(links, circularLinkGap, id) {
  links.sort(sortLinkColumnAscending);
  links.forEach(function (link, i) {
    var buffer = 0;

    if (selfLinking(link, id) && onlyCircularLink(link)) {
      link.circularPathData.verticalBuffer = buffer + link.width / 2;
    } else {
      var j = 0;
      for (j; j < i; j++) {
        if (circularLinksCross(links[i], links[j])) {
          var bufferOverThisLink = links[j].circularPathData.verticalBuffer + links[j].width / 2 + circularLinkGap;
          buffer = bufferOverThisLink > buffer ? bufferOverThisLink : buffer;
        }
      }

      link.circularPathData.verticalBuffer = buffer + link.width / 2;
    }
  });

  return links;
}

// calculate the optimum path for a link to reduce overlaps
function addCircularPathData(graph, circularLinkGap, y1, id) {
  //var baseRadius = 10
  var buffer = 5;
  //var verticalMargin = 25

  var minY = min$4(graph.links, function (link) {
    return link.source.y0;
  });

  // create object for circular Path Data
  graph.links.forEach(function (link) {
    if (link.circular) {
      link.circularPathData = {};
    }
  });

  // calc vertical offsets per top/bottom links
  var topLinks = graph.links.filter(function (l) {
    return l.circularLinkType == 'top';
  });
  /* topLinks = */calcVerticalBuffer(topLinks, circularLinkGap, id);

  var bottomLinks = graph.links.filter(function (l) {
    return l.circularLinkType == 'bottom';
  });
  /* bottomLinks = */calcVerticalBuffer(bottomLinks, circularLinkGap, id);

  // add the base data for each link
  graph.links.forEach(function (link) {
    if (link.circular) {
      link.circularPathData.arcRadius = link.width + baseRadius;
      link.circularPathData.leftNodeBuffer = buffer;
      link.circularPathData.rightNodeBuffer = buffer;
      link.circularPathData.sourceWidth = link.source.x1 - link.source.x0;
      link.circularPathData.sourceX = link.source.x0 + link.circularPathData.sourceWidth;
      link.circularPathData.targetX = link.target.x0;
      link.circularPathData.sourceY = link.y0;
      link.circularPathData.targetY = link.y1;

      // for self linking paths, and that the only circular link in/out of that node
      if (selfLinking(link, id) && onlyCircularLink(link)) {
        link.circularPathData.leftSmallArcRadius = baseRadius + link.width / 2;
        link.circularPathData.leftLargeArcRadius = baseRadius + link.width / 2;
        link.circularPathData.rightSmallArcRadius = baseRadius + link.width / 2;
        link.circularPathData.rightLargeArcRadius = baseRadius + link.width / 2;

        if (link.circularLinkType == 'bottom') {
          link.circularPathData.verticalFullExtent = link.source.y1 + verticalMargin + link.circularPathData.verticalBuffer;
          link.circularPathData.verticalLeftInnerExtent = link.circularPathData.verticalFullExtent - link.circularPathData.leftLargeArcRadius;
          link.circularPathData.verticalRightInnerExtent = link.circularPathData.verticalFullExtent - link.circularPathData.rightLargeArcRadius;
        } else {
          // top links
          link.circularPathData.verticalFullExtent = link.source.y0 - verticalMargin - link.circularPathData.verticalBuffer;
          link.circularPathData.verticalLeftInnerExtent = link.circularPathData.verticalFullExtent + link.circularPathData.leftLargeArcRadius;
          link.circularPathData.verticalRightInnerExtent = link.circularPathData.verticalFullExtent + link.circularPathData.rightLargeArcRadius;
        }
      } else {
        // else calculate normally
        // add left extent coordinates, based on links with same source column and circularLink type
        var thisColumn = link.source.column;
        var thisCircularLinkType = link.circularLinkType;
        var sameColumnLinks = graph.links.filter(function (l) {
          return l.source.column == thisColumn && l.circularLinkType == thisCircularLinkType;
        });

        if (link.circularLinkType == 'bottom') {
          sameColumnLinks.sort(sortLinkSourceYDescending);
        } else {
          sameColumnLinks.sort(sortLinkSourceYAscending);
        }

        var radiusOffset = 0;
        sameColumnLinks.forEach(function (l, i) {
          if (l.circularLinkID == link.circularLinkID) {
            link.circularPathData.leftSmallArcRadius = baseRadius + link.width / 2 + radiusOffset;
            link.circularPathData.leftLargeArcRadius = baseRadius + link.width / 2 + i * circularLinkGap + radiusOffset;
          }
          radiusOffset = radiusOffset + l.width;
        });

        // add right extent coordinates, based on links with same target column and circularLink type
        thisColumn = link.target.column;
        sameColumnLinks = graph.links.filter(function (l) {
          return l.target.column == thisColumn && l.circularLinkType == thisCircularLinkType;
        });
        if (link.circularLinkType == 'bottom') {
          sameColumnLinks.sort(sortLinkTargetYDescending);
        } else {
          sameColumnLinks.sort(sortLinkTargetYAscending);
        }

        radiusOffset = 0;
        sameColumnLinks.forEach(function (l, i) {
          if (l.circularLinkID == link.circularLinkID) {
            link.circularPathData.rightSmallArcRadius = baseRadius + link.width / 2 + radiusOffset;
            link.circularPathData.rightLargeArcRadius = baseRadius + link.width / 2 + i * circularLinkGap + radiusOffset;
          }
          radiusOffset = radiusOffset + l.width;
        });

        // bottom links
        if (link.circularLinkType == 'bottom') {
          link.circularPathData.verticalFullExtent = Math.max(y1, link.source.y1, link.target.y1) + verticalMargin + link.circularPathData.verticalBuffer;
          link.circularPathData.verticalLeftInnerExtent = link.circularPathData.verticalFullExtent - link.circularPathData.leftLargeArcRadius;
          link.circularPathData.verticalRightInnerExtent = link.circularPathData.verticalFullExtent - link.circularPathData.rightLargeArcRadius;
        } else {
          // top links
          link.circularPathData.verticalFullExtent = minY - verticalMargin - link.circularPathData.verticalBuffer;
          link.circularPathData.verticalLeftInnerExtent = link.circularPathData.verticalFullExtent + link.circularPathData.leftLargeArcRadius;
          link.circularPathData.verticalRightInnerExtent = link.circularPathData.verticalFullExtent + link.circularPathData.rightLargeArcRadius;
        }
      }

      // all links
      link.circularPathData.leftInnerExtent = link.circularPathData.sourceX + link.circularPathData.leftNodeBuffer;
      link.circularPathData.rightInnerExtent = link.circularPathData.targetX - link.circularPathData.rightNodeBuffer;
      link.circularPathData.leftFullExtent = link.circularPathData.sourceX + link.circularPathData.leftLargeArcRadius + link.circularPathData.leftNodeBuffer;
      link.circularPathData.rightFullExtent = link.circularPathData.targetX - link.circularPathData.rightLargeArcRadius - link.circularPathData.rightNodeBuffer;
    }

    if (link.circular) {
      link.path = createCircularPathString(link);
    } else {
      var normalPath = linkHorizontal().source(function (d) {
        var x = d.source.x0 + (d.source.x1 - d.source.x0);
        var y = d.y0;
        return [x, y];
      }).target(function (d) {
        var x = d.target.x0;
        var y = d.y1;
        return [x, y];
      });
      link.path = normalPath(link);
    }
  });
}

// create a d path using the addCircularPathData
function createCircularPathString(link) {
  var pathString = '';
  // 'pathData' is assigned a value but never used
  // var pathData = {}

  if (link.circularLinkType == 'top') {
    pathString =
    // start at the right of the source node
    'M' + link.circularPathData.sourceX + ' ' + link.circularPathData.sourceY + ' ' +
    // line right to buffer point
    'L' + link.circularPathData.leftInnerExtent + ' ' + link.circularPathData.sourceY + ' ' +
    // Arc around: Centre of arc X and  //Centre of arc Y
    'A' + link.circularPathData.leftLargeArcRadius + ' ' + link.circularPathData.leftSmallArcRadius + ' 0 0 0 ' +
    // End of arc X //End of arc Y
    link.circularPathData.leftFullExtent + ' ' + (link.circularPathData.sourceY - link.circularPathData.leftSmallArcRadius) + ' ' + // End of arc X
    // line up to buffer point
    'L' + link.circularPathData.leftFullExtent + ' ' + link.circularPathData.verticalLeftInnerExtent + ' ' +
    // Arc around: Centre of arc X and  //Centre of arc Y
    'A' + link.circularPathData.leftLargeArcRadius + ' ' + link.circularPathData.leftLargeArcRadius + ' 0 0 0 ' +
    // End of arc X //End of arc Y
    link.circularPathData.leftInnerExtent + ' ' + link.circularPathData.verticalFullExtent + ' ' + // End of arc X
    // line left to buffer point
    'L' + link.circularPathData.rightInnerExtent + ' ' + link.circularPathData.verticalFullExtent + ' ' +
    // Arc around: Centre of arc X and  //Centre of arc Y
    'A' + link.circularPathData.rightLargeArcRadius + ' ' + link.circularPathData.rightLargeArcRadius + ' 0 0 0 ' +
    // End of arc X //End of arc Y
    link.circularPathData.rightFullExtent + ' ' + link.circularPathData.verticalRightInnerExtent + ' ' + // End of arc X
    // line down
    'L' + link.circularPathData.rightFullExtent + ' ' + (link.circularPathData.targetY - link.circularPathData.rightSmallArcRadius) + ' ' +
    // Arc around: Centre of arc X and  //Centre of arc Y
    'A' + link.circularPathData.rightLargeArcRadius + ' ' + link.circularPathData.rightSmallArcRadius + ' 0 0 0 ' +
    // End of arc X //End of arc Y
    link.circularPathData.rightInnerExtent + ' ' + link.circularPathData.targetY + ' ' + // End of arc X
    // line to end
    'L' + link.circularPathData.targetX + ' ' + link.circularPathData.targetY;
  } else {
    // bottom path
    pathString =
    // start at the right of the source node
    'M' + link.circularPathData.sourceX + ' ' + link.circularPathData.sourceY + ' ' +
    // line right to buffer point
    'L' + link.circularPathData.leftInnerExtent + ' ' + link.circularPathData.sourceY + ' ' +
    // Arc around: Centre of arc X and  //Centre of arc Y
    'A' + link.circularPathData.leftLargeArcRadius + ' ' + link.circularPathData.leftSmallArcRadius + ' 0 0 1 ' +
    // End of arc X //End of arc Y
    link.circularPathData.leftFullExtent + ' ' + (link.circularPathData.sourceY + link.circularPathData.leftSmallArcRadius) + ' ' + // End of arc X
    // line down to buffer point
    'L' + link.circularPathData.leftFullExtent + ' ' + link.circularPathData.verticalLeftInnerExtent + ' ' +
    // Arc around: Centre of arc X and  //Centre of arc Y
    'A' + link.circularPathData.leftLargeArcRadius + ' ' + link.circularPathData.leftLargeArcRadius + ' 0 0 1 ' +
    // End of arc X //End of arc Y
    link.circularPathData.leftInnerExtent + ' ' + link.circularPathData.verticalFullExtent + ' ' + // End of arc X
    // line left to buffer point
    'L' + link.circularPathData.rightInnerExtent + ' ' + link.circularPathData.verticalFullExtent + ' ' +
    // Arc around: Centre of arc X and  //Centre of arc Y
    'A' + link.circularPathData.rightLargeArcRadius + ' ' + link.circularPathData.rightLargeArcRadius + ' 0 0 1 ' +
    // End of arc X //End of arc Y
    link.circularPathData.rightFullExtent + ' ' + link.circularPathData.verticalRightInnerExtent + ' ' + // End of arc X
    // line up
    'L' + link.circularPathData.rightFullExtent + ' ' + (link.circularPathData.targetY + link.circularPathData.rightSmallArcRadius) + ' ' +
    // Arc around: Centre of arc X and  //Centre of arc Y
    'A' + link.circularPathData.rightLargeArcRadius + ' ' + link.circularPathData.rightSmallArcRadius + ' 0 0 1 ' +
    // End of arc X //End of arc Y
    link.circularPathData.rightInnerExtent + ' ' + link.circularPathData.targetY + ' ' + // End of arc X
    // line to end
    'L' + link.circularPathData.targetX + ' ' + link.circularPathData.targetY;
  }

  return pathString;
}

// sort links based on the distance between the source and tartget node columns
// if the same, then use Y position of the source node
function sortLinkColumnAscending(link1, link2) {
  if (linkColumnDistance(link1) == linkColumnDistance(link2)) {
    return link1.circularLinkType == 'bottom' ? sortLinkSourceYDescending(link1, link2) : sortLinkSourceYAscending(link1, link2);
  } else {
    return linkColumnDistance(link2) - linkColumnDistance(link1);
  }
}

// sort ascending links by their source vertical position, y0
function sortLinkSourceYAscending(link1, link2) {
  return link1.y0 - link2.y0;
}

// sort descending links by their source vertical position, y0
function sortLinkSourceYDescending(link1, link2) {
  return link2.y0 - link1.y0;
}

// sort ascending links by their target vertical position, y1
function sortLinkTargetYAscending(link1, link2) {
  return link1.y1 - link2.y1;
}

// sort descending links by their target vertical position, y1
function sortLinkTargetYDescending(link1, link2) {
  return link2.y1 - link1.y1;
}

// return the distance between the link's target and source node, in terms of the nodes' column
function linkColumnDistance(link) {
  return link.target.column - link.source.column;
}

// return the distance between the link's target and source node, in terms of the nodes' X coordinate
function linkXLength(link) {
  return link.target.x0 - link.source.x1;
}

// Return the Y coordinate on the longerLink path * which is perpendicular shorterLink's source.
// * approx, based on a straight line from target to source, when in fact the path is a bezier
function linkPerpendicularYToLinkSource(longerLink, shorterLink) {
  // get the angle for the longer link
  var angle = linkAngle(longerLink);

  // get the adjacent length to the other link's x position
  var heightFromY1ToPependicular = linkXLength(shorterLink) / Math.tan(angle);

  // add or subtract from longer link1's original y1, depending on the slope
  var yPerpendicular = incline(longerLink) == 'up' ? longerLink.y1 + heightFromY1ToPependicular : longerLink.y1 - heightFromY1ToPependicular;

  return yPerpendicular;
}

// Return the Y coordinate on the longerLink path * which is perpendicular shorterLink's source.
// * approx, based on a straight line from target to source, when in fact the path is a bezier
function linkPerpendicularYToLinkTarget(longerLink, shorterLink) {
  // get the angle for the longer link
  var angle = linkAngle(longerLink);

  // get the adjacent length to the other link's x position
  var heightFromY1ToPependicular = linkXLength(shorterLink) / Math.tan(angle);

  // add or subtract from longer link's original y1, depending on the slope
  var yPerpendicular = incline(longerLink) == 'up' ? longerLink.y1 - heightFromY1ToPependicular : longerLink.y1 + heightFromY1ToPependicular;

  return yPerpendicular;
}

// Move any nodes that overlap links which span 2+ columns
function resolveNodeLinkOverlaps(graph, y0, y1, id) {

  graph.links.forEach(function (link) {
    if (link.circular) {
      return;
    }

    if (link.target.column - link.source.column > 1) {
      var columnToTest = link.source.column + 1;
      var maxColumnToTest = link.target.column - 1;

      var i = 1;
      var numberOfColumnsToTest = maxColumnToTest - columnToTest + 1;

      for (i = 1; columnToTest <= maxColumnToTest; columnToTest++, i++) {
        graph.nodes.forEach(function (node) {
          if (node.column == columnToTest) {
            var t = i / (numberOfColumnsToTest + 1);

            // Find all the points of a cubic bezier curve in javascript
            // https://stackoverflow.com/questions/15397596/find-all-the-points-of-a-cubic-bezier-curve-in-javascript

            var B0_t = Math.pow(1 - t, 3);
            var B1_t = 3 * t * Math.pow(1 - t, 2);
            var B2_t = 3 * Math.pow(t, 2) * (1 - t);
            var B3_t = Math.pow(t, 3);

            var py_t = B0_t * link.y0 + B1_t * link.y0 + B2_t * link.y1 + B3_t * link.y1;

            var linkY0AtColumn = py_t - link.width / 2;
            var linkY1AtColumn = py_t + link.width / 2;
            var dy;

            // If top of link overlaps node, push node up
            if (linkY0AtColumn > node.y0 && linkY0AtColumn < node.y1) {

              dy = node.y1 - linkY0AtColumn + 10;
              dy = node.circularLinkType == 'bottom' ? dy : -dy;

              node = adjustNodeHeight(node, dy, y0, y1);

              // check if other nodes need to move up too
              graph.nodes.forEach(function (otherNode) {
                // don't need to check itself or nodes at different columns
                if (getNodeID(otherNode, id) == getNodeID(node, id) || otherNode.column != node.column) {
                  return;
                }
                if (nodesOverlap(node, otherNode)) {
                  adjustNodeHeight(otherNode, dy, y0, y1);
                }
              });
            } else if (linkY1AtColumn > node.y0 && linkY1AtColumn < node.y1) {
              // If bottom of link overlaps node, push node down
              dy = linkY1AtColumn - node.y0 + 10;

              node = adjustNodeHeight(node, dy, y0, y1);

              // check if other nodes need to move down too
              graph.nodes.forEach(function (otherNode) {
                // don't need to check itself or nodes at different columns
                if (getNodeID(otherNode, id) == getNodeID(node, id) || otherNode.column != node.column) {
                  return;
                }
                if (otherNode.y0 < node.y1 && otherNode.y1 > node.y1) {
                  adjustNodeHeight(otherNode, dy, y0, y1);
                }
              });
            } else if (linkY0AtColumn < node.y0 && linkY1AtColumn > node.y1) {
              // if link completely overlaps node
              dy = linkY1AtColumn - node.y0 + 10;

              node = adjustNodeHeight(node, dy, y0, y1);

              graph.nodes.forEach(function (otherNode) {
                // don't need to check itself or nodes at different columns
                if (getNodeID(otherNode, id) == getNodeID(node, id) || otherNode.column != node.column) {
                  return;
                }
                if (otherNode.y0 < node.y1 && otherNode.y1 > node.y1) {
                  adjustNodeHeight(otherNode, dy, y0, y1);
                }
              });
            }
          }
        });
      }
    }
  });
}

// check if two nodes overlap
function nodesOverlap(nodeA, nodeB) {
  // test if nodeA top partially overlaps nodeB
  if (nodeA.y0 > nodeB.y0 && nodeA.y0 < nodeB.y1) {
    return true;
  } else if (nodeA.y1 > nodeB.y0 && nodeA.y1 < nodeB.y1) {
    // test if nodeA bottom partially overlaps nodeB
    return true;
  } else if (nodeA.y0 < nodeB.y0 && nodeA.y1 > nodeB.y1) {
    // test if nodeA covers nodeB
    return true;
  } else {
    return false;
  }
}

// update a node, and its associated links, vertical positions (y0, y1)
function adjustNodeHeight(node, dy, sankeyY0, sankeyY1) {
  if (node.y0 + dy >= sankeyY0 && node.y1 + dy <= sankeyY1) {
    node.y0 = node.y0 + dy;
    node.y1 = node.y1 + dy;

    node.targetLinks.forEach(function (l) {
      l.y1 = l.y1 + dy;
    });

    node.sourceLinks.forEach(function (l) {
      l.y0 = l.y0 + dy;
    });
  }
  return node;
}

// sort and set the links' y0 for each node
function sortSourceLinks(graph, y1, id, moveNodes) {
  graph.nodes.forEach(function (node) {
    // move any nodes up which are off the bottom
    if (moveNodes && node.y + (node.y1 - node.y0) > y1) {
      node.y = node.y - (node.y + (node.y1 - node.y0) - y1);
    }

    var nodesSourceLinks = graph.links.filter(function (l) {
      return getNodeID(l.source, id) == getNodeID(node, id);
    });

    var nodeSourceLinksLength = nodesSourceLinks.length;

    // if more than 1 link then sort
    if (nodeSourceLinksLength > 1) {
      nodesSourceLinks.sort(function (link1, link2) {
        // if both are not circular...
        if (!link1.circular && !link2.circular) {
          // if the target nodes are the same column, then sort by the link's target y
          if (link1.target.column == link2.target.column) {
            return link1.y1 - link2.y1;
          } else if (!sameInclines(link1, link2)) {
            // if the links slope in different directions, then sort by the link's target y
            return link1.y1 - link2.y1;

            // if the links slope in same directions, then sort by any overlap
          } else {
            if (link1.target.column > link2.target.column) {
              var link2Adj = linkPerpendicularYToLinkTarget(link2, link1);
              return link1.y1 - link2Adj;
            }
            if (link2.target.column > link1.target.column) {
              var link1Adj = linkPerpendicularYToLinkTarget(link1, link2);
              return link1Adj - link2.y1;
            }
          }
        }

        // if only one is circular, the move top links up, or bottom links down
        if (link1.circular && !link2.circular) {
          return link1.circularLinkType == 'top' ? -1 : 1;
        } else if (link2.circular && !link1.circular) {
          return link2.circularLinkType == 'top' ? 1 : -1;
        }

        // if both links are circular...
        if (link1.circular && link2.circular) {
          // ...and they both loop the same way (both top)
          if (link1.circularLinkType === link2.circularLinkType && link1.circularLinkType == 'top') {
            // ...and they both connect to a target with same column, then sort by the target's y
            if (link1.target.column === link2.target.column) {
              return link1.target.y1 - link2.target.y1;
            } else {
              // ...and they connect to different column targets, then sort by how far back they
              return link2.target.column - link1.target.column;
            }
          } else if (link1.circularLinkType === link2.circularLinkType && link1.circularLinkType == 'bottom') {
            // ...and they both loop the same way (both bottom)
            // ...and they both connect to a target with same column, then sort by the target's y
            if (link1.target.column === link2.target.column) {
              return link2.target.y1 - link1.target.y1;
            } else {
              // ...and they connect to different column targets, then sort by how far back they
              return link1.target.column - link2.target.column;
            }
          } else {
            // ...and they loop around different ways, the move top up and bottom down
            return link1.circularLinkType == 'top' ? -1 : 1;
          }
        }
      });
    }

    // update y0 for links
    var ySourceOffset = node.y0;

    nodesSourceLinks.forEach(function (link) {
      link.y0 = ySourceOffset + link.width / 2;
      ySourceOffset = ySourceOffset + link.width;
    });

    // correct any circular bottom links so they are at the bottom of the node
    nodesSourceLinks.forEach(function (link, i) {
      if (link.circularLinkType == 'bottom') {
        var j = i + 1;
        var offsetFromBottom = 0;
        // sum the widths of any links that are below this link
        for (j; j < nodeSourceLinksLength; j++) {
          offsetFromBottom = offsetFromBottom + nodesSourceLinks[j].width;
        }
        link.y0 = node.y1 - offsetFromBottom - link.width / 2;
      }
    });
  });
}

// sort and set the links' y1 for each node
function sortTargetLinks(graph, y1, id) {
  graph.nodes.forEach(function (node) {
    var nodesTargetLinks = graph.links.filter(function (l) {
      return getNodeID(l.target, id) == getNodeID(node, id);
    });

    var nodesTargetLinksLength = nodesTargetLinks.length;

    if (nodesTargetLinksLength > 1) {
      nodesTargetLinks.sort(function (link1, link2) {
        // if both are not circular, the base on the source y position
        if (!link1.circular && !link2.circular) {
          if (link1.source.column == link2.source.column) {
            return link1.y0 - link2.y0;
          } else if (!sameInclines(link1, link2)) {
            return link1.y0 - link2.y0;
          } else {
            // get the angle of the link to the further source node (ie the smaller column)
            if (link2.source.column < link1.source.column) {
              var link2Adj = linkPerpendicularYToLinkSource(link2, link1);

              return link1.y0 - link2Adj;
            }
            if (link1.source.column < link2.source.column) {
              var link1Adj = linkPerpendicularYToLinkSource(link1, link2);

              return link1Adj - link2.y0;
            }
          }
        }

        // if only one is circular, the move top links up, or bottom links down
        if (link1.circular && !link2.circular) {
          return link1.circularLinkType == 'top' ? -1 : 1;
        } else if (link2.circular && !link1.circular) {
          return link2.circularLinkType == 'top' ? 1 : -1;
        }

        // if both links are circular...
        if (link1.circular && link2.circular) {
          // ...and they both loop the same way (both top)
          if (link1.circularLinkType === link2.circularLinkType && link1.circularLinkType == 'top') {
            // ...and they both connect to a target with same column, then sort by the target's y
            if (link1.source.column === link2.source.column) {
              return link1.source.y1 - link2.source.y1;
            } else {
              // ...and they connect to different column targets, then sort by how far back they
              return link1.source.column - link2.source.column;
            }
          } else if (link1.circularLinkType === link2.circularLinkType && link1.circularLinkType == 'bottom') {
            // ...and they both loop the same way (both bottom)
            // ...and they both connect to a target with same column, then sort by the target's y
            if (link1.source.column === link2.source.column) {
              return link1.source.y1 - link2.source.y1;
            } else {
              // ...and they connect to different column targets, then sort by how far back they
              return link2.source.column - link1.source.column;
            }
          } else {
            // ...and they loop around different ways, the move top up and bottom down
            return link1.circularLinkType == 'top' ? -1 : 1;
          }
        }
      });
    }

    // update y1 for links
    var yTargetOffset = node.y0;

    nodesTargetLinks.forEach(function (link) {
      link.y1 = yTargetOffset + link.width / 2;
      yTargetOffset = yTargetOffset + link.width;
    });

    // correct any circular bottom links so they are at the bottom of the node
    nodesTargetLinks.forEach(function (link, i) {
      if (link.circularLinkType == 'bottom') {
        var j = i + 1;
        var offsetFromBottom = 0;
        // sum the widths of any links that are below this link
        for (j; j < nodesTargetLinksLength; j++) {
          offsetFromBottom = offsetFromBottom + nodesTargetLinks[j].width;
        }
        link.y1 = node.y1 - offsetFromBottom - link.width / 2;
      }
    });
  });
}

// test if links both slope up, or both slope down
function sameInclines(link1, link2) {
  return incline(link1) == incline(link2);
}

// returns the slope of a link, from source to target
// up => slopes up from source to target
// down => slopes down from source to target
function incline(link) {
  return link.y0 - link.y1 > 0 ? 'up' : 'down';
}

// check if link is self linking, ie links a node to the same node
function selfLinking(link, id) {
  return getNodeID(link.source, id) == getNodeID(link.target, id);
}

function fillHeight(graph, y0, y1) {

  var nodes = graph.nodes;
  var links = graph.links;

  var top = false;
  var bottom = false;

  links.forEach(function (link) {
    if (link.circularLinkType == "top") {
      top = true;
    } else if (link.circularLinkType == "bottom") {
      bottom = true;
    }
  });

  if (top == false || bottom == false) {
    var minY0 = min$4(nodes, function (node) {
      return node.y0;
    });
    var maxY1 = max$5(nodes, function (node) {
      return node.y1;
    });
    var currentHeight = maxY1 - minY0;
    var chartHeight = y1 - y0;
    var ratio = chartHeight / currentHeight;

    nodes.forEach(function (node) {
      var nodeHeight = (node.y1 - node.y0) * ratio;
      node.y0 = (node.y0 - minY0) * ratio;
      node.y1 = node.y0 + nodeHeight;
    });

    links.forEach(function (link) {
      link.y0 = (link.y0 - minY0) * ratio;
      link.y1 = (link.y1 - minY0) * ratio;
      link.width = link.width * ratio;
    });
  }
}

function ascending$8(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}

function bisector$4(compare) {
  if (compare.length === 1) compare = ascendingComparator$4(compare);
  return {
    left: function(a, x, lo, hi) {
      if (lo == null) lo = 0;
      if (hi == null) hi = a.length;
      while (lo < hi) {
        var mid = lo + hi >>> 1;
        if (compare(a[mid], x) < 0) lo = mid + 1;
        else hi = mid;
      }
      return lo;
    },
    right: function(a, x, lo, hi) {
      if (lo == null) lo = 0;
      if (hi == null) hi = a.length;
      while (lo < hi) {
        var mid = lo + hi >>> 1;
        if (compare(a[mid], x) > 0) hi = mid;
        else lo = mid + 1;
      }
      return lo;
    }
  };
}

function ascendingComparator$4(f) {
  return function(d, x) {
    return ascending$8(f(d), x);
  };
}

var ascendingBisect$4 = bisector$4(ascending$8);

function range$1(start, stop, step) {
  start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;

  var i = -1,
      n = Math.max(0, Math.ceil((stop - start) / step)) | 0,
      range = new Array(n);

  while (++i < n) {
    range[i] = start + i * step;
  }

  return range;
}

var cos$2 = Math.cos;
var sin$2 = Math.sin;
var pi$3 = Math.PI;
var halfPi$2 = pi$3 / 2;
var tau$3 = pi$3 * 2;
var max$6 = Math.max;

function compareValue(compare) {
  return function(a, b) {
    return compare(
      a.source.value + a.target.value,
      b.source.value + b.target.value
    );
  };
}

function chord() {
  var padAngle = 0,
      sortGroups = null,
      sortSubgroups = null,
      sortChords = null;

  function chord(matrix) {
    var n = matrix.length,
        groupSums = [],
        groupIndex = range$1(n),
        subgroupIndex = [],
        chords = [],
        groups = chords.groups = new Array(n),
        subgroups = new Array(n * n),
        k,
        x,
        x0,
        dx,
        i,
        j;

    // Compute the sum.
    k = 0, i = -1; while (++i < n) {
      x = 0, j = -1; while (++j < n) {
        x += matrix[i][j];
      }
      groupSums.push(x);
      subgroupIndex.push(range$1(n));
      k += x;
    }

    // Sort groups…
    if (sortGroups) groupIndex.sort(function(a, b) {
      return sortGroups(groupSums[a], groupSums[b]);
    });

    // Sort subgroups…
    if (sortSubgroups) subgroupIndex.forEach(function(d, i) {
      d.sort(function(a, b) {
        return sortSubgroups(matrix[i][a], matrix[i][b]);
      });
    });

    // Convert the sum to scaling factor for [0, 2pi].
    // TODO Allow start and end angle to be specified?
    // TODO Allow padding to be specified as percentage?
    k = max$6(0, tau$3 - padAngle * n) / k;
    dx = k ? padAngle : tau$3 / n;

    // Compute the start and end angle for each group and subgroup.
    // Note: Opera has a bug reordering object literal properties!
    x = 0, i = -1; while (++i < n) {
      x0 = x, j = -1; while (++j < n) {
        var di = groupIndex[i],
            dj = subgroupIndex[di][j],
            v = matrix[di][dj],
            a0 = x,
            a1 = x += v * k;
        subgroups[dj * n + di] = {
          index: di,
          subindex: dj,
          startAngle: a0,
          endAngle: a1,
          value: v
        };
      }
      groups[di] = {
        index: di,
        startAngle: x0,
        endAngle: x,
        value: groupSums[di]
      };
      x += dx;
    }

    // Generate chords for each (non-empty) subgroup-subgroup link.
    i = -1; while (++i < n) {
      j = i - 1; while (++j < n) {
        var source = subgroups[j * n + i],
            target = subgroups[i * n + j];
        if (source.value || target.value) {
          chords.push(source.value < target.value
              ? {source: target, target: source}
              : {source: source, target: target});
        }
      }
    }

    return sortChords ? chords.sort(sortChords) : chords;
  }

  chord.padAngle = function(_) {
    return arguments.length ? (padAngle = max$6(0, _), chord) : padAngle;
  };

  chord.sortGroups = function(_) {
    return arguments.length ? (sortGroups = _, chord) : sortGroups;
  };

  chord.sortSubgroups = function(_) {
    return arguments.length ? (sortSubgroups = _, chord) : sortSubgroups;
  };

  chord.sortChords = function(_) {
    return arguments.length ? (_ == null ? sortChords = null : (sortChords = compareValue(_))._ = _, chord) : sortChords && sortChords._;
  };

  return chord;
}

var slice$6 = Array.prototype.slice;

function constant$d(x) {
  return function() {
    return x;
  };
}

function defaultSource(d) {
  return d.source;
}

function defaultTarget(d) {
  return d.target;
}

function defaultRadius$1(d) {
  return d.radius;
}

function defaultStartAngle(d) {
  return d.startAngle;
}

function defaultEndAngle(d) {
  return d.endAngle;
}

function ribbon() {
  var source = defaultSource,
      target = defaultTarget,
      radius = defaultRadius$1,
      startAngle = defaultStartAngle,
      endAngle = defaultEndAngle,
      context = null;

  function ribbon() {
    var buffer,
        argv = slice$6.call(arguments),
        s = source.apply(this, argv),
        t = target.apply(this, argv),
        sr = +radius.apply(this, (argv[0] = s, argv)),
        sa0 = startAngle.apply(this, argv) - halfPi$2,
        sa1 = endAngle.apply(this, argv) - halfPi$2,
        sx0 = sr * cos$2(sa0),
        sy0 = sr * sin$2(sa0),
        tr = +radius.apply(this, (argv[0] = t, argv)),
        ta0 = startAngle.apply(this, argv) - halfPi$2,
        ta1 = endAngle.apply(this, argv) - halfPi$2;

    if (!context) context = buffer = path();

    context.moveTo(sx0, sy0);
    context.arc(0, 0, sr, sa0, sa1);
    if (sa0 !== ta0 || sa1 !== ta1) { // TODO sr !== tr?
      context.quadraticCurveTo(0, 0, tr * cos$2(ta0), tr * sin$2(ta0));
      context.arc(0, 0, tr, ta0, ta1);
    }
    context.quadraticCurveTo(0, 0, sx0, sy0);
    context.closePath();

    if (buffer) return context = null, buffer + "" || null;
  }

  ribbon.radius = function(_) {
    return arguments.length ? (radius = typeof _ === "function" ? _ : constant$d(+_), ribbon) : radius;
  };

  ribbon.startAngle = function(_) {
    return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant$d(+_), ribbon) : startAngle;
  };

  ribbon.endAngle = function(_) {
    return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant$d(+_), ribbon) : endAngle;
  };

  ribbon.source = function(_) {
    return arguments.length ? (source = _, ribbon) : source;
  };

  ribbon.target = function(_) {
    return arguments.length ? (target = _, ribbon) : target;
  };

  ribbon.context = function(_) {
    return arguments.length ? ((context = _ == null ? null : _), ribbon) : context;
  };

  return ribbon;
}

const topologicalSort = (nodesArray, edgesArray) => {
  // adapted from https://simplapi.wordpress.com/2015/08/19/detect-graph-cycle-in-javascript/
  const nodes = [];
  const nodeHash = {};
  edgesArray.forEach(edge => {
    if (!edge.source.id || !edge.target.id) {
      return false;
    }

    if (!nodeHash[edge.source.id]) {
      nodeHash[edge.source.id] = {
        _id: edge.source.id,
        links: []
      };
      nodes.push(nodeHash[edge.source.id]);
    }

    if (!nodeHash[edge.target.id]) {
      nodeHash[edge.target.id] = {
        _id: edge.target.id,
        links: []
      };
      nodes.push(nodeHash[edge.target.id]);
    }

    nodeHash[edge.source.id].links.push(edge.target.id);
  }); // Test if a node got any icoming edge

  function hasIncomingEdge(list, node) {
    for (let i = 0, l = list.length; i < l; ++i) {
      if (list[i].links.indexOf(node._id) !== -1) {
        return true;
      }
    }

    return false;
  } // Kahn Algorithm


  const L = [],
        S = nodes.filter(node => !hasIncomingEdge(nodes, node));
  let n = null;

  while (S.length) {
    // Remove a node n from S
    n = S.pop(); // Add n to tail of L

    L.push(n);
    let i = n.links.length;

    while (i--) {
      // Getting the node associated to the current stored id in links
      const m = nodes[nodes.map(d => d._id).indexOf(n.links[i])]; // Remove edge e from the graph

      n.links.pop();

      if (!hasIncomingEdge(nodes, m)) {
        S.push(m);
      }
    }
  } // If any of them still got links, there is cycle somewhere


  const nodeWithEdge = nodes.find(node => node.links.length !== 0);
  return nodeWithEdge ? null : L;
};

const curvature = 0.5;

const areaLink = d => {
  let x0, x1, x2, x3, y0, y1, xi, y2, y3;

  if (d.direction === 'down') {
    x0 = d.y0 - d.sankeyWidth / 2;
    x1 = d.y1 - d.sankeyWidth / 2;
    x2 = d.y1 + d.sankeyWidth / 2;
    x3 = d.y0 + d.sankeyWidth / 2;
    y0 = d.source.y1;
    y1 = d.target.y0;
    xi = interpolateNumber(y0, y1);
    y2 = xi(curvature);
    y3 = xi(1 - curvature);
    return `M${x0},${y0}C${x0},${y2} ${x1},${y3} ${x1},${y1}L${x2},${y1}C${x2},${y3} ${x3},${y2} ${x3},${y0}Z`;
  }

  x0 = d.source.x1, // eslint-disable-line no-sequences
  x1 = d.target.x0, xi = interpolateNumber(x0, x1), x2 = xi(curvature), x3 = xi(1 - curvature), y0 = d.y0 - d.sankeyWidth / 2, y1 = d.y1 - d.sankeyWidth / 2, y2 = d.y1 + d.sankeyWidth / 2, y3 = d.y0 + d.sankeyWidth / 2;
  return `M${x0},${y0}C${x2},${y0} ${x3},${y1} ${x1},${y1}L${x1},${y2}C${x3},${y2} ${x2},${y3} ${x0},${y3}Z`;
};

const ribbonLink = d => {
  const diff = d.direction === 'down' ? Math.abs(d.target.y - d.source.y) : Math.abs(d.source.x - d.target.x); // const halfWidth = d.width / 2

  const testCoordinates = d.direction === 'down' ? [{
    x: d.y0,
    y: d.source.y
  }, {
    x: d.y0,
    y: d.source.y + diff / 3
  }, {
    x: d.y1,
    y: d.target.y - diff / 3
  }, {
    x: d.y1,
    y: d.target.y
  }] : [{
    x: d.source.x0,
    y: d.y0
  }, {
    x: d.source.x0 + diff / 3,
    y: d.y0
  }, {
    x: d.target.x0 - diff / 3,
    y: d.y1
  }, {
    x: d.target.x0,
    y: d.y1
  }];
  const linkGenerator = linearRibbon();
  linkGenerator.x(d => d.x);
  linkGenerator.y(d => d.y);
  linkGenerator.r(() => d.sankeyWidth / 2);
  return linkGenerator(testCoordinates);
};

const circularAreaLink = link => {
  const linkGenerator = linearRibbon();
  linkGenerator.x(d => d.x);
  linkGenerator.y(d => d.y);
  linkGenerator.r(() => link.sankeyWidth / 2);
  const xyForLink = link.direction === 'down' ? [{
    x: link.circularPathData.sourceY,
    y: link.circularPathData.sourceX
  }, {
    x: link.circularPathData.sourceY,
    y: link.circularPathData.leftFullExtent
  }, {
    x: link.circularPathData.verticalFullExtent,
    y: link.circularPathData.leftFullExtent
  }, {
    x: link.circularPathData.verticalFullExtent,
    y: link.circularPathData.rightFullExtent
  }, {
    x: link.circularPathData.targetY,
    y: link.circularPathData.rightFullExtent
  }, {
    x: link.circularPathData.targetY,
    y: link.circularPathData.targetX
  }] : [{
    x: link.circularPathData.sourceX,
    y: link.circularPathData.sourceY
  }, {
    x: link.circularPathData.leftFullExtent,
    y: link.circularPathData.sourceY
  }, {
    x: link.circularPathData.leftFullExtent,
    y: link.circularPathData.verticalFullExtent
  }, {
    x: link.circularPathData.rightFullExtent,
    y: link.circularPathData.verticalFullExtent
  }, {
    x: link.circularPathData.rightFullExtent,
    y: link.circularPathData.targetY
  }, {
    x: link.circularPathData.targetX,
    y: link.circularPathData.targetY
  }];
  return linkGenerator(xyForLink);
};

const radialLabelGenerator = (node, nodei, nodeIDAccessor, size) => {
  const anglePct = (node.x1 + node.x0) / 2 / size[0];
  const nodeLabel = nodeIDAccessor(node, nodei);
  const labelRotate = anglePct > 0.5 ? anglePct * 360 + 90 : anglePct * 360 - 90;
  return React$1.createElement("g", {
    transform: `rotate(${labelRotate})`
  }, typeof nodeLabel === 'string' ? React$1.createElement("text", {
    textAnchor: "middle",
    y: 5
  }, nodeLabel) : nodeLabel);
};

const hierarchyDecorator = (hierarchy, hashEntries, nodeIDAccessor, nodes) => {
  if (hierarchy.children) {
    hierarchy.children.forEach(child => {
      const theseEntries = hashEntries.filter(entry => entry[1] === child.id);
      theseEntries.forEach(entry => {
        const idNode = nodes.find(node => nodeIDAccessor(node) === entry[0]) || {};
        child.childHash[entry[0]] = {
          id: entry[0],
          children: [],
          childHash: {},
          ...idNode
        };
        child.children.push(child.childHash[entry[0]]);
      });

      if (child.children.length > 0) {
        hierarchyDecorator(child, hashEntries, nodeIDAccessor, nodes);
      }
    });
  }
};

const softStack = (edges, nodes, sourceAccessor, targetAccessor, nodeIDAccessor) => {
  let hierarchy = {
    id: 'root-generated',
    children: [],
    childHash: {}
  };
  const discoveredHierarchyHash = {};
  const targetToSourceHash = {};
  let hasLogicalRoot = true;
  let isHierarchical = true;

  for (let i = 0; i < edges.length; i++) {
    const edge = edges[i];
    const source = sourceAccessor(edge);
    const target = targetAccessor(edge);
    const sourceID = typeof source === 'object' ? nodeIDAccessor(source) : source;
    const targetID = typeof target === 'object' ? nodeIDAccessor(target) : target;
    targetToSourceHash[targetID] = sourceID;

    if (!discoveredHierarchyHash[sourceID]) {
      discoveredHierarchyHash[sourceID] = targetID;
    } else {
      isHierarchical = false;
      break;
    }
  }

  if (isHierarchical) {
    const hashEntries = Object.values(discoveredHierarchyHash);
    hashEntries.forEach(entry => {
      const target = entry;

      if (!discoveredHierarchyHash[target]) {
        discoveredHierarchyHash[target] = 'root-generated';
        const idNode = nodes.find(node => nodeIDAccessor(node) === target) || {};
        hierarchy.childHash[target] = {
          id: target,
          children: [],
          childHash: {},
          ...idNode
        };
        hierarchy.children.push(hierarchy.childHash[target]);
      }
    });
    hierarchyDecorator(hierarchy, hashEntries, nodeIDAccessor, nodes);
    nodes.forEach(node => {
      const nodeID = nodeIDAccessor(node);

      if (!discoveredHierarchyHash[nodeID] && !targetToSourceHash[nodeID]) {
        hierarchy.children.push({
          id: nodeID,
          children: [],
          childHash: {},
          ...node
        });
      }
    });

    if (hierarchy.children.length === 1) {
      hierarchy = hierarchy.children[0];
      hasLogicalRoot = false;
    }

    return {
      hierarchy,
      isHierarchical: true,
      hasLogicalRoot
    };
  }

  return {
    hierarchy: {},
    isHierarchical: false,
    hasLogicalRoot: false
  };
};

function recursiveIDAccessor(idAccessor, node, accessorString) {
  if (node.parent) {
    accessorString = `${accessorString}-${recursiveIDAccessor(idAccessor, { ...node.parent,
      ...node.parent.data
    }, accessorString)}`;
  }

  return `${accessorString}-${idAccessor({ ...node,
    ...node.data
  })}`;
}

const nodesEdgesFromHierarchy = (baseRootNode, idAccessor = d => d.id || d.descendantIndex) => {
  const edges = [];
  const nodes = [];
  const rootNode = baseRootNode.descendants ? baseRootNode : hierarchy(baseRootNode);
  const descendants = rootNode.descendants();
  descendants.forEach((d, i) => {
    d.descendantIndex = i;
  });
  descendants.forEach((node, i) => {
    const generatedID = `${idAccessor({ ...node,
      ...node.data
    })}-${node.parent && recursiveIDAccessor(idAccessor, { ...node.parent,
      ...node.parent.data
    }, '') || 'root'}`;
    const dataD = Object.assign(node, node.data || {}, {
      hierarchicalID: generatedID
    });
    nodes.push(dataD);

    if (node.parent !== null) {
      const dataParent = Object.assign(node.parent, node.parent.data || {});
      edges.push({
        source: dataParent,
        target: dataD,
        depth: node.depth,
        weight: 1,
        value: 1,
        _NWFEdgeKey: generatedID
      });
    }
  });
  return {
    edges,
    nodes
  };
};

function arrowHead(d, nodeTargetSize, bodySize, headSize) {
    var diffX = d.target.y - d.source.y;
    var diffY = d.target.x - d.source.x;

    var headDistance = headSize * 3;

    var angle0 = ( Math.atan2( diffY, diffX ) + ( Math.PI / 2 ) );
    var angle1 = angle0 - ( Math.PI / 2 );
    var angle2 = angle0 + ( Math.PI / 2 );

    var x1 = d.source.x + (headSize * Math.cos(angle1));
    var y1 = d.source.y - (headSize * Math.sin(angle1));
    var x2 = d.source.x + (headSize * Math.cos(angle2));
    var y2 = d.source.y - (headSize * Math.sin(angle2));

    var x3 = d.target.x - (headSize * Math.cos(angle1));
    var y3 = d.target.y + (headSize * Math.sin(angle1));
    var x4 = d.target.x - (headSize * Math.cos(angle2));
    var y4 = d.target.y + (headSize * Math.sin(angle2));

    var mx1 = d.source.x + (bodySize * Math.cos(angle1));
    var my1 = d.source.y - (bodySize * Math.sin(angle1));
    var mx2 = d.source.x + (bodySize * Math.cos(angle2));
    var my2 = d.source.y - (bodySize * Math.sin(angle2));

    var mx3 = d.target.x + (bodySize * Math.cos(angle1));
    var my3 = d.target.y - (bodySize * Math.sin(angle1));
    var mx4 = d.target.x + (bodySize * Math.cos(angle2));
    var my4 = d.target.y - (bodySize * Math.sin(angle2));

    var dY = d.source.y - d.target.y;
    var dX = d.source.x - d.target.x;

    var midDiffY1 = my1 - my3;
    var midDiffX1 = mx1 - mx3;
    var midDiffY2 = my2 - my4;
    var midDiffX2 = mx2 - mx4;

    var diffY1 = y1 - y3;
    var diffX1 = x1 - x3;
    var diffY2 = y2 - y4;
    var diffX2 = x2 - x4;

    var pythag = Math.sqrt((midDiffX1 * midDiffX1) + (midDiffY1 * midDiffY1));
    var pythag2 = Math.sqrt((dX * dX) + (dY * dY));

    var adjX1 = mx2 - ((midDiffX1 * (pythag - headDistance - nodeTargetSize)) / pythag);
    var adjY1 = my2 - ((midDiffY1 * (pythag - headDistance - nodeTargetSize)) / pythag);
    var adjX2 = mx1 - ((midDiffX2 * (pythag - headDistance - nodeTargetSize)) / pythag);
    var adjY2 = my1 - ((midDiffY2 * (pythag - headDistance - nodeTargetSize)) / pythag);

    var headX2 = x1 - ((diffX2 * (pythag - headDistance - nodeTargetSize)) / pythag);
    var headY2 = y1 - ((diffY2 * (pythag - headDistance - nodeTargetSize)) / pythag);
    var headX1 = x2 - ((diffX1 * (pythag - headDistance - nodeTargetSize)) / pythag);
    var headY1 = y2 - ((diffY1 * (pythag - headDistance - nodeTargetSize)) / pythag);

    var tipX = d.source.x - ((dX * (pythag2 - nodeTargetSize)) / pythag2);
    var tipY = d.source.y - ((dY * (pythag2 - nodeTargetSize)) / pythag2);

    return "M" + mx2 + "," + my2 + "L" + adjX1 + "," + adjY1 + "L" + headX1 + "," + headY1 + "L" + tipX + "," + tipY + "L" + headX2 + "," + headY2 + "L" + adjX2 + "," + adjY2 + "L" + mx1 + "," + my1 + "z";
}

function comet(d, nodeSize) {
    var diffX = d.target.y - d.source.y;
    var diffY = d.target.x - d.source.x;

    var angle0 = ( Math.atan2( diffY, diffX ) + ( Math.PI / 2 ) );
    var angle1 = angle0 - ( Math.PI / 2 );
    var angle2 = angle0 + ( Math.PI / 2 );

    var x1 = d.target.x + (nodeSize * Math.cos(angle1));
    var y1 = d.target.y - (nodeSize * Math.sin(angle1));
    var x2 = d.target.x + (nodeSize * Math.cos(angle2));
    var y2 = d.target.y - (nodeSize * Math.sin(angle2));

    return "M" + x1 + "," + y1 + "L" + x2 + "," + y2 + " L " + d.source.x + "," + d.source.y + "z";
}

function nail(d, nodeSize) {
    var diffX = d.target.y - d.source.y;
    var diffY = d.target.x - d.source.x;

    var angle0 = ( Math.atan2( diffY, diffX ) + ( Math.PI / 2 ) );
    var angle1 = angle0 - ( Math.PI / 2 );
    var angle2 = angle0 + ( Math.PI / 2 );

    var x1 = d.source.x + (nodeSize * Math.cos(angle1));
    var y1 = d.source.y - (nodeSize * Math.sin(angle1));
    var x2 = d.source.x + (nodeSize * Math.cos(angle2));
    var y2 = d.source.y - (nodeSize * Math.sin(angle2));

    return "M" + x1 + "," + y1 + "L" + x2 + "," + y2 + " L " + d.target.x + "," + d.target.y + "z";
}

function taffy(d, nodeSourceSize, nodeTargetSize, midpointSize) {
    var diffX = d.target.y - d.source.y;
    var diffY = d.target.x - d.source.x;

    var angle0 = ( Math.atan2( diffY, diffX ) + ( Math.PI / 2 ) );
    var angle1 = angle0 - ( Math.PI / 2 );
    var angle2 = angle0 + ( Math.PI / 2 );

    var x1 = d.source.x + (nodeSourceSize * Math.cos(angle1));
    var y1 = d.source.y - (nodeSourceSize * Math.sin(angle1));
    var x2 = d.source.x + (nodeSourceSize * Math.cos(angle2));
    var y2 = d.source.y - (nodeSourceSize * Math.sin(angle2));

    var x3 = d.target.x + (nodeTargetSize * Math.cos(angle2));
    var y3 = d.target.y - (nodeTargetSize * Math.sin(angle2));
    var x4 = d.target.x + (nodeTargetSize * Math.cos(angle1));
    var y4 = d.target.y - (nodeTargetSize * Math.sin(angle1));

    var mx1 = d.source.x + (midpointSize * Math.cos(angle1));
    var my1 = d.source.y - (midpointSize * Math.sin(angle1));
    var mx2 = d.source.x + (midpointSize * Math.cos(angle2));
    var my2 = d.source.y - (midpointSize * Math.sin(angle2));

    var mx3 = d.target.x + (midpointSize * Math.cos(angle1));
    var my3 = d.target.y - (midpointSize * Math.sin(angle1));
    var mx4 = d.target.x + (midpointSize * Math.cos(angle2));
    var my4 = d.target.y - (midpointSize * Math.sin(angle2));

    var midY2 = (my1 + my3) / 2;
    var midX2 = (mx1 + mx3) / 2;
    var midY1 = (my2 + my4) / 2;
    var midX1 = (mx2 + mx4) / 2;

    return "M" + x1 + "," + y1 + "L" + x2 + "," + y2 + " L " + midX1 + "," + midY1 + " L " + x3 + "," + y3 + " L " + x4 + "," + y4 + " L " + midX2 + "," + midY2 + "z";
}

function ribbon$1(d, bodySize) {
        var diffX = d.target.y - d.source.y;
        var diffY = d.target.x - d.source.x;

        var angle0 = ( Math.atan2( diffY, diffX ) + ( Math.PI / 2 ) );
        var angle1 = angle0 - ( Math.PI / 2 );
        var angle2 = angle0 + ( Math.PI / 2 );

        var mx1 = d.source.x + (bodySize * Math.cos(angle1));
        var my1 = d.source.y - (bodySize * Math.sin(angle1));
        var mx2 = d.source.x + (bodySize * Math.cos(angle2));
        var my2 = d.source.y - (bodySize * Math.sin(angle2));

        var mx3 = d.target.x - (bodySize * Math.cos(angle1));
        var my3 = d.target.y + (bodySize * Math.sin(angle1));
        var mx4 = d.target.x - (bodySize * Math.cos(angle2));
        var my4 = d.target.y + (bodySize * Math.sin(angle2));

        return "M" + mx1 + "," + my1 + "L" + mx2 + "," + my2 + "L" + mx3 + "," + my3 + "L" + mx4 + "," + my4 + "z";
}

function lineArc(d) {
  var dx = d.target.x - d.source.x,
      dy = d.target.y - d.source.y,
      dr = Math.sqrt(dx * dx + dy * dy);
  return "M" + d.source.x + "," + d.source.y + "A" + dr + "," + dr + " 0 0,1 " + d.target.x + "," + d.target.y;
}

function halfArrow(d, nodeTargetSize, bodySize, headSize) {
    var diffX = d.target.y - d.source.y;
    var diffY = d.target.x - d.source.x;

    var headDistance = headSize * 3;

    var angle0 = ( Math.atan2( diffY, diffX ) + ( Math.PI / 2 ) );
    var angle1 = angle0 - ( Math.PI / 2 );
    var angle2 = angle0 + ( Math.PI / 2 );

    var x1 = d.source.x + (headSize * Math.cos(angle1));
    var y1 = d.source.y - (headSize * Math.sin(angle1));
    var x2 = d.source.x + (headSize * Math.cos(angle2));
    var y2 = d.source.y - (headSize * Math.sin(angle2));
    var x3 = d.target.x - (headSize * Math.cos(angle1));
    var y3 = d.target.y + (headSize * Math.sin(angle1));

    var mx1 = d.source.x + (bodySize * Math.cos(angle1));
    var my1 = d.source.y - (bodySize * Math.sin(angle1));
    var mx2 = d.source.x + (bodySize * Math.cos(angle2));
    var my2 = d.source.y - (bodySize * Math.sin(angle2));

    var mx3 = d.target.x + (bodySize * Math.cos(angle1));
    var my3 = d.target.y - (bodySize * Math.sin(angle1));

    var dY = d.source.y - d.target.y;
    var dX = d.source.x - d.target.x;

    var midDiffY1 = my1 - my3;
    var midDiffX1 = mx1 - mx3;

    var diffY1 = y1 - y3;
    var diffX1 = x1 - x3;

    var pythag = Math.sqrt((midDiffX1 * midDiffX1) + (midDiffY1 * midDiffY1));
    var pythag2 = Math.sqrt((dX * dX) + (dY * dY));

    var adjX1 = mx2 - ((midDiffX1 * (pythag - headDistance - nodeTargetSize)) / pythag);
    var adjY1 = my2 - ((midDiffY1 * (pythag - headDistance - nodeTargetSize)) / pythag);

    var headX1 = x2 - ((diffX1 * (pythag - headDistance - nodeTargetSize)) / pythag);
    var headY1 = y2 - ((diffY1 * (pythag - headDistance - nodeTargetSize)) / pythag);

    var tipX = d.source.x - ((dX * (pythag2 - nodeTargetSize)) / pythag2);
    var tipY = d.source.y - ((dY * (pythag2 - nodeTargetSize)) / pythag2);

    return "M" + d.source.x + "," + d.source.y + "L" + mx2 + "," + my2 + "L" + adjX1 + "," + adjY1 + "L" + headX1 + "," + headY1 + "L" + tipX + "," + tipY + "L" + d.source.x + "," + d.source.y + "z";
}

var d = {
  arrowHead: arrowHead,
  comet: comet,
  nail: nail,
  taffy: taffy,
  ribbon: ribbon$1,
  lineArc: lineArc,
  halfArrow: halfArrow
};

const sigmoidLinks = {
  horizontal: linkHorizontal().x(d => d.x).y(d => d.y),
  vertical: linkVertical().x(d => d.x).y(d => d.y),
  radial: d.lineArc
};

const genericLineGenerator = d => `M${d.source.x},${d.source.y}L${d.target.x},${d.target.y}`;

function sankeyEdgeSort(a, b, direction) {
  if (a.circular && !b.circular) return -1;
  if (b.circular && !a.circular) return 1;
  const first = direction === 'down' ? 'y' : 'x';
  const second = direction === 'down' ? 'x' : 'y';
  return a.source[first] === b.source[first] ? a.sankeyWidth === b.sankeyWidth ? a.source[second] - b.source[second] : b.sankeyWidth - a.sankeyWidth : a.source[first] - b.source[first];
}

const customEdgeHashD = {
  curve: (d, projection = 'vertical') => sigmoidLinks[projection](d),
  linearc: d$1 => d.lineArc(d$1),
  ribbon: d$1 => d.ribbon(d$1, d$1.width),
  arrowhead: d$1 => d.arrowHead(d$1, d$1.target.nodeSize, d$1.width, d$1.width * 1.5),
  halfarrow: d$1 => d.halfArrow(d$1, d$1.target.nodeSize, d$1.width, d$1.width * 1.5),
  nail: d$1 => d.nail(d$1, d$1.source.nodeSize),
  comet: d$1 => d.comet(d$1, d$1.target.nodeSize),
  taffy: d$1 => d.taffy(d$1, d$1.source.nodeSize / 2, d$1.target.nodeSize / 2, (d$1.source.nodeSize + d$1.target.nodeSize) / 4)
};

const drawEdges = ({
  data: baseData,
  renderKeyFn,
  customMark,
  styleFn,
  classFn,
  renderMode,
  useCanvas,
  type,
  baseMarkProps,
  networkType,
  direction,
  projection
}) => {
  const data = networkType === 'sankey' ? baseData.sort((a, b) => sankeyEdgeSort(a, b, direction)) : baseData;
  let dGenerator = genericLineGenerator;
  const svgPipeline = [];
  const canvasPipeline = [];

  if (customMark) {
    // CUSTOM MARK IMPLEMENTATION
    data.forEach((d, i) => {
      const renderedCustomMark = customMark({
        d,
        i,
        renderKeyFn,
        styleFn,
        classFn,
        renderMode,
        key: renderKeyFn ? renderKeyFn(d, i) : `edge-${i}`,
        className: `${classFn(d, i)} edge`,
        transform: `translate(${d.x},${d.y})`,
        baseMarkProps
      });

      if (renderedCustomMark && renderedCustomMark.props && (renderedCustomMark.props.markType !== 'path' || renderedCustomMark.props.d)) {
        svgPipeline.push(renderedCustomMark);
      }
    });
  } else {
    if (type) {
      if (typeof type === 'function') {
        dGenerator = type;
      } else if (customEdgeHashD[type]) {
        dGenerator = d => customEdgeHashD[type](d, projection);
      }
    }

    data.forEach((d, i) => {
      const renderedD = dGenerator(d);

      if (renderedD && useCanvas === true) {
        const canvasEdge = {
          baseClass: 'frame-piece',
          tx: d.x,
          ty: d.y,
          d,
          i,
          markProps: {
            markType: 'path',
            d: renderedD
          },
          styleFn,
          renderFn: renderMode,
          classFn
        };
        canvasPipeline.push(canvasEdge);
      } else if (renderedD) {
        svgPipeline.push(React$1.createElement(lib_2, _extends({}, baseMarkProps, {
          key: renderKeyFn ? renderKeyFn(d, i) : `edge-${i}`,
          markType: "path",
          renderMode: renderMode ? renderMode(d, i) : undefined,
          className: `${classFn(d)} edge`,
          d: renderedD,
          style: styleFn(d, i),
          tabIndex: -1,
          role: "img",
          "aria-label": `connection from ${d.source.id} to ${d.target.id}`
        })));
      }
    });
  }

  return {
    svgPipeline,
    canvasPipeline
  };
};

const drawNodes = ({
  data,
  renderKeyFn,
  customMark,
  styleFn,
  classFn,
  renderMode,
  useCanvas,
  baseMarkProps
}) => {
  const svgPipeline = [];
  const canvasPipeline = [];

  if (customMark && useCanvas) {
    console.error('canvas rendering currently only supports generic circle nodes based on nodeSize');
  }

  data.forEach((d, i) => {
    if (useCanvas === true) {
      const canvasNode = {
        baseClass: 'frame-piece',
        tx: d.x,
        ty: d.y,
        d,
        i,
        markProps: {
          markType: 'circle',
          r: d.nodeSize
        },
        styleFn,
        renderFn: renderMode,
        classFn
      };
      canvasPipeline.push(canvasNode);
    } else {
      // CUSTOM MARK IMPLEMENTATION
      if (customMark) {
        svgPipeline.push(customMark({
          d,
          i,
          renderKeyFn,
          styleFn,
          classFn,
          renderMode,
          key: renderKeyFn ? renderKeyFn(d, i) : d.id || `node-${i}`,
          className: `node ${classFn(d, i)}`,
          transform: `translate(${d.x},${d.y})`,
          baseMarkProps
        }));
      }
    }
  });
  return {
    svgPipeline,
    canvasPipeline
  };
};

const toPipeline$2 = ({
  projectedEdges,
  projectedNodes,
  edgeStyle,
  edgeClass,
  edgeRenderMode,
  edgeUseCanvas,
  edgeRenderKey,
  projection,
  edgeType,
  customEdgeIcon,
  networkType,
  direction,
  nodeStyle,
  nodeClass,
  nodeRenderMode,
  nodeUseCanvas,
  customNodeIcon,
  nodeRenderKey
}) => {
  const {
    svgPipeline: edgeSvg,
    canvasPipeline: edgeCanvas
  } = drawEdges({
    data: projectedEdges,
    renderKeyFn: edgeRenderKey,
    customMark: customEdgeIcon,
    styleFn: edgeStyle,
    classFn: edgeClass,
    renderMode: edgeRenderMode,
    useCanvas: edgeUseCanvas,
    type: edgeType,
    networkType,
    direction,
    projection
  });
  const {
    svgPipeline: nodeSvg,
    canvasPipeline: nodeCanvas
  } = drawNodes({
    data: projectedNodes,
    renderKeyFn: nodeRenderKey,
    customMark: customNodeIcon,
    styleFn: nodeStyle,
    classFn: nodeClass,
    renderMode: nodeRenderMode,
    useCanvas: nodeUseCanvas,
    networkType,
    direction,
    projection
  });
  const svgPipe = [...edgeSvg, ...nodeSvg];
  const canvasPipe = [...edgeCanvas, ...nodeCanvas];
  return {
    svgPipe,
    canvasPipe
  };
};

const emptyArray = [];

const genericFunction$1 = value => () => value;

const baseNodeProps = {
  id: undefined,
  degree: 0,
  inDegree: 0,
  outDegree: 0,
  x: 0,
  y: 0,
  x1: 0,
  x0: 0,
  y1: 0,
  y0: 0,
  height: 0,
  width: 0,
  radius: 0,
  r: 0,
  direction: undefined,
  textHeight: 0,
  textWidth: 0,
  fontSize: 0,
  scale: 1,
  nodeSize: 0,
  component: -99,
  shapeNode: false
};
const baseGraphSettings = {
  nodeHash: new Map(),
  edgeHash: new Map(),
  nodes: [],
  edges: [],
  hierarchicalNetwork: false,
  type: 'force'
};

const basicMiddle = d => ({
  edge: d,
  x: (d.source.x + d.target.x) / 2,
  y: (d.source.y + d.target.y) / 2
});

const edgePointHash = {
  sankey: d => ({
    edge: d,
    x: (d.source.x1 + d.target.x0) / 2,
    y: d.circularPathData ? d.circularPathData.verticalFullExtent : ((d.y0 + d.y1) / 2 + (d.y0 + d.y1) / 2) / 2
  }),
  force: basicMiddle,
  tree: basicMiddle,
  cluster: basicMiddle
};
const hierarchicalTypeHash = {
  dendrogram: tree,
  tree,
  circlepack: pack,
  cluster,
  treemap,
  partition
};
const hierarchicalProjectable = {
  partition: true,
  cluster: true,
  tree: true,
  dendrogram: true
};
const radialProjectable = {
  partition: true,
  cluster: true,
  tree: true,
  dendrogram: true
};

function breadthFirstCompontents(baseNodes, hash) {
  const componentHash = {
    '0': {
      componentNodes: [],
      componentEdges: []
    }
  };
  const components = [componentHash['0']];
  let componentID = 0;
  traverseNodesBF(baseNodes, true);

  function traverseNodesBF(nodes, top) {
    nodes.forEach(node => {
      const hashNode = hash.get(node);

      if (!hashNode) {
        componentHash['0'].componentNodes.push(node);
      } else if (hashNode.component === -99) {
        if (top === true) {
          componentID++;
          componentHash[componentID] = {
            componentNodes: [],
            componentEdges: []
          };
          components.push(componentHash[componentID]);
        }

        hashNode.component = componentID;
        componentHash[componentID].componentNodes.push(node);
        componentHash[componentID].componentEdges.push(...hashNode.edges);
        const traversibleNodes = [...hashNode.connectedNodes];
        traverseNodesBF(traversibleNodes, hash);
      }
    });
  }

  return components.sort((a, b) => b.componentNodes.length - a.componentNodes.length);
}

const sankeyOrientHash = {
  left: left,
  right: right,
  center: center,
  justify: justify
};

const matrixify = ({
  edgeHash,
  nodes,
  edgeWidthAccessor,
  nodeIDAccessor
}) => {
  const matrix = [];
  nodes.forEach(nodeSource => {
    const nodeSourceID = nodeIDAccessor(nodeSource);
    const sourceRow = [];
    matrix.push(sourceRow);
    nodes.forEach(nodeTarget => {
      const nodeTargetID = nodeIDAccessor(nodeTarget);
      const theEdge = edgeHash.get(`${nodeSourceID}|${nodeTargetID}`);

      if (theEdge) {
        sourceRow.push(edgeWidthAccessor(theEdge));
      } else {
        sourceRow.push(0);
      }
    });
  });
  return matrix;
};

const computeNetworkFrameData = props => {
  const [frameData, updateFrameData] = React$1.useState({
    nodeData: [],
    edgeData: [],
    adjustedPosition: [],
    adjustedSize: [],
    backgroundGraphics: null,
    foregroundGraphics: null,
    projectedNodes: [],
    projectedEdges: [],
    renderNumber: 0,
    nodeLabelAnnotations: [],
    graphSettings: {
      type: 'empty-start',
      nodes: [],
      edges: [],
      nodeHash: new Map(),
      edgeHash: new Map(),
      hierarchicalNetwork: false
    },
    edgeWidthAccessor: stringToFn('weight'),
    margin: {
      top: 0,
      left: 0,
      right: 0,
      bottom: 0
    },
    nodeIDAccessor: stringToFn('id'),
    nodeSizeAccessor: genericFunction$1(5),
    overlay: [],
    screenCoordinates: [],
    sourceAccessor: stringToFn('source'),
    targetAccessor: stringToFn('target'),
    svgPipeline: [],
    canvasPipeline: [],
    marginGraphic: null
  });

  const computeFrame = props => {
    const {
      margin: baseMargin,
      width,
      height,
      matte,
      hoverAnnotation,
      name,
      plotChildren
    } = props;
    const singlePlot = plotChildren[0];
    const {
      graph,
      nodes = Array.isArray(graph) || typeof graph === 'function' ? emptyArray : graph && graph.nodes || emptyArray,
      edges = typeof graph === 'function' ? emptyArray : Array.isArray(graph) ? graph : graph && graph.edges || emptyArray,
      nodeStyle,
      nodeClass,
      edgeStyle,
      edgeClass,
      nodeRenderMode,
      edgeRenderMode,
      nodeLabels,
      customNodeIcon: baseCustomNodeIcon,
      customEdgeIcon: baseCustomEdgeIcon,
      filterRenderedNodes,
      nodeUseCanvas,
      edgeUseCanvas,
      edgeRenderKey,
      nodeRenderKey,
      nodeIDAccessor: baseNodeIDAccessor,
      sourceAccessor: baseSourceAccessor,
      targetAccessor: baseTargetAccessor,
      nodeSizeAccessor: baseNodeSizeAccessor,
      edgeWidthAccessor: baseEdgeWidthAccessor,
      nodeSize,
      hierarchyChildren,
      hierarchySum,
      barLayout,
      nodePadding,
      angleRange
    } = singlePlot.props;
    let {
      edgeType,
      projection,
      direction
    } = singlePlot.props;
    const {
      nodeGenerator,
      edgeGenerator
    } = singlePlot.type;
    const size = [width, height];
    const center = [size[0] / 2, size[1] / 2];
    const margin = typeof baseMargin !== 'object' ? {
      top: baseMargin,
      bottom: baseMargin,
      left: baseMargin,
      right: baseMargin
    } : Object.assign({
      top: 0,
      bottom: 0,
      left: 0,
      right: 0
    }, baseMargin);
    const marginGraphic = toMarginGraphic({
      matte,
      size,
      margin,
      name
    });
    const {
      adjustedPosition,
      adjustedSize
    } = getAdjustedPositionSize({
      size: [width, height],
      margin
    });
    const nodeHierarchicalIDFill = {};
    const networkSettings = {
      type: singlePlot.type.name.toLowerCase(),
      graphSettings: baseGraphSettings
    };

    if (projection === 'vertical' && networkSettings.type === 'sankey') {
      direction = 'down';
    }

    networkSettings.graphSettings.nodes = nodes;
    networkSettings.graphSettings.edges = edges;
    let {
      edgeHash,
      nodeHash
    } = networkSettings.graphSettings;
    const createPointLayer = networkSettings.type === 'treemap' || networkSettings.type === 'partition' || networkSettings.type === 'sankey';
    const nodeIDAccessor = stringToFn(baseNodeIDAccessor, d => d.id);
    const sourceAccessor = stringToFn(baseSourceAccessor, d => d.source);
    const targetAccessor = stringToFn(baseTargetAccessor, d => d.target);
    const nodeSizeAccessor = typeof baseNodeSizeAccessor === 'number' ? genericFunction$1(baseNodeSizeAccessor) : stringToFn(baseNodeSizeAccessor, d => d.r || 5);
    const edgeWidthAccessor = stringToFn(baseEdgeWidthAccessor, d => d.weight || 1);
    let projectedNodes = [];
    let projectedEdges = [];
    const isHierarchical = hierarchicalTypeHash[networkSettings.type] !== undefined;
    const changedData = !frameData.projectedNodes || !frameData.projectedEdges || frameData.graphSettings.nodes !== nodes || frameData.graphSettings.edges !== edges || isHierarchical;

    if (networkSettings.type === 'dagre') {
      const dagreGraph = graph;
      const dagreNodeHash = {};
      projectedNodes = dagreGraph.nodes().map(n => {
        const baseNode = dagreGraph.node(n);
        dagreNodeHash[n] = { ...baseNode,
          x0: baseNode.x - baseNode.width / 2,
          x1: baseNode.x + baseNode.width / 2,
          y0: baseNode.y - baseNode.height / 2,
          y1: baseNode.y + baseNode.height / 2,
          id: n,
          shapeNode: true,
          sourceLinks: [],
          targetLinks: []
        };
        return dagreNodeHash[n];
      });
      projectedEdges = dagreGraph.edges().map(e => {
        const dagreEdge = dagreGraph.edge(e);
        const baseEdge = { ...dagreEdge,
          points: dagreEdge.points.map(d => ({ ...d
          }))
        };
        baseEdge.source = projectedNodes.find(p => p.id === e.v);
        baseEdge.target = projectedNodes.find(p => p.id === e.w);
        baseEdge.points.unshift({
          x: baseEdge.source.x,
          y: baseEdge.source.y
        });
        baseEdge.points.push({
          x: baseEdge.target.x,
          y: baseEdge.target.y
        });
        dagreNodeHash[e.v].targetLinks.push(baseEdge);
        dagreNodeHash[e.w].sourceLinks.push(baseEdge);
        return baseEdge;
      });
    } else if (changedData) {
      edgeHash = new Map();
      nodeHash = new Map();
      networkSettings.graphSettings.edgeHash = edgeHash;
      networkSettings.graphSettings.nodeHash = nodeHash;
      projectedNodes = [];
      projectedEdges = [];
      nodes.forEach(node => {
        const projectedNode = { ...node
        };
        const id = nodeIDAccessor(projectedNode);
        nodeHash.set(id, projectedNode);
        nodeHash.set(node, projectedNode);
        projectedNodes.push(projectedNode);
        projectedNode.id = id;
        projectedNode.inDegree = 0;
        projectedNode.outDegree = 0;
        projectedNode.degree = 0;
      });
      let operationalEdges = edges;
      let baseEdges = edges;

      if (isHierarchical && Array.isArray(edges)) {
        const createdHierarchicalData = softStack(edges, projectedNodes, sourceAccessor, targetAccessor, nodeIDAccessor);

        if (createdHierarchicalData.isHierarchical) {
          baseEdges = createdHierarchicalData.hierarchy;
          projectedNodes = [];
        } else {
          console.error("You've sent an edge list that is not strictly hierarchical (there are nodes with multiple parents) defaulting to force-directed network layout");
          networkSettings.type = 'force';
        }
      }

      if (!Array.isArray(baseEdges)) {
        networkSettings.hierarchicalNetwork = true;
        const rootNode = hierarchy(baseEdges, hierarchyChildren);
        rootNode.sum(hierarchySum || (d => d.value));

        if (isHierarchical) {
          const layout = barLayout || isHierarchical;
          const hierarchicalLayout = layout();
          const networkSettingKeys = Object.keys(networkSettings);

          if ((networkSettings.type === 'dendrogram' || networkSettings.type === 'tree' || networkSettings.type === 'cluster') && hierarchicalLayout.separation) {
            hierarchicalLayout.separation((a, b) => (nodeSizeAccessor({ ...a,
              ...a.data
            }) || 1) + (nodePadding || 0) + (nodeSizeAccessor({ ...b,
              ...b.data
            }) || 1));
          }

          networkSettingKeys.forEach(key => {
            if (hierarchicalLayout[key]) {
              hierarchicalLayout[key](networkSettings[key]);
            }
          });
          const layoutSize = projection === 'horizontal' && isHierarchical ? [adjustedSize[1], adjustedSize[0]] : adjustedSize;

          if (!nodeSize && hierarchicalLayout.size) {
            hierarchicalLayout.size(layoutSize);
          }

          hierarchicalLayout(rootNode);
        }

        operationalEdges = nodesEdgesFromHierarchy(rootNode, nodeIDAccessor).edges;
      }

      baseNodeProps.shapeNode = createPointLayer;

      if (Array.isArray(operationalEdges)) {
        operationalEdges.forEach(edge => {
          const source = sourceAccessor(edge);
          const target = targetAccessor(edge);
          const sourceTarget = [source, target];
          sourceTarget.forEach(nodeDirection => {
            if (!nodeHash.get(nodeDirection)) {
              const nodeObject = typeof nodeDirection === 'object' ? { ...baseNodeProps,
                ...nodeDirection
              } : { ...baseNodeProps,
                id: nodeDirection,
                createdByFrame: true
              };
              const nodeIDValue = nodeObject.id || nodeIDAccessor(nodeObject);
              nodeHierarchicalIDFill[nodeIDValue] ? nodeHierarchicalIDFill[nodeIDValue] += 1 : nodeHierarchicalIDFill[nodeIDValue] = 1;

              if (!nodeObject.id) {
                const nodeSuffix = nodeHierarchicalIDFill[nodeIDValue] === 1 ? '' : `-${nodeHierarchicalIDFill[nodeIDValue]}`;
                nodeObject.id = `${nodeIDValue}${nodeSuffix}`;
              }

              nodeHash.set(nodeDirection, nodeObject);
              projectedNodes.push(nodeObject);
            }
          });
          const edgeWeight = edge.weight || 1;
          const sourceNode = nodeHash.get(source);
          const targetNode = nodeHash.get(target);
          targetNode.inDegree += edgeWeight;
          sourceNode.outDegree += edgeWeight;
          targetNode.degree += edgeWeight;
          sourceNode.degree += edgeWeight;
          const edgeKey = `${nodeIDAccessor(sourceNode) || source}|${nodeIDAccessor(targetNode) || target}`;
          const newEdge = Object.assign({}, edge, {
            source: nodeHash.get(source),
            target: nodeHash.get(target)
          });
          edgeHash.set(edgeKey, newEdge);
          projectedEdges.push(newEdge);
        });
      }
    } else {
      edgeHash = new Map();
      networkSettings.graphSettings.edgeHash = edgeHash;
      projectedEdges.forEach(edge => {
        const edgeSource = typeof edge.source === 'string' ? edge.source : nodeIDAccessor(edge.source);
        const edgeTarget = typeof edge.target === 'string' ? edge.target : nodeIDAccessor(edge.target);
        const edgeKey = `${edgeSource}|${edgeTarget}`;
        edgeHash.set(edgeKey, edge);
      });
    }

    const customNodeIcon = baseCustomNodeIcon ? baseCustomNodeIcon : nodeGenerator ? nodeGenerator({
      center,
      angleRange,
      projection,
      direction,
      size: adjustedSize,
      nodes: projectedNodes
    }) : circleNodeGenerator();
    const customEdgeIcon = baseCustomEdgeIcon ? baseCustomEdgeIcon : edgeGenerator ? edgeGenerator({
      direction,
      size: adjustedSize,
      nodes: projectedNodes,
      graph
    }) : null;

    if ((networkSettings.type === 'sankey' || networkSettings.type === 'flowchart') && topologicalSort(projectedNodes, projectedEdges) === null) {
      networkSettings.customSankey = sankeyCircular;
    }

    networkSettings.width = size[0];
    networkSettings.height = size[1];
    let networkSettingsChanged = false;
    ['type', 'height', 'width'].forEach(key => {
      if (key !== 'edgeType' && key !== 'graphSettings' && networkSettings[key] !== frameData.graphSettings[key]) {
        networkSettingsChanged = true;
      }
    }); //Support bubble chart with circle pack and with force

    if (networkSettings.type === 'sankey') {
      edgeType = d => d.circular ? circularAreaLink(d) : edgeType === 'angled' ? ribbonLink(d) : areaLink(d);
    } else if (isHierarchical) {
      projectedNodes.forEach(node => {
        if (createPointLayer) {
          node.x = (node.x0 + node.x1) / 2;
          node.y = (node.y0 + node.y1) / 2;
        }

        if (typeof networkSettings.type === 'string' && hierarchicalProjectable[networkSettings.type] && projection === 'horizontal') {
          const ox = node.x;
          node.x = node.y;
          node.y = ox;

          if (createPointLayer) {
            const ox0 = node.x0;
            const ox1 = node.x1;
            node.x0 = node.y0;
            node.x1 = node.y1;
            node.y0 = ox0;
            node.y1 = ox1;
          }
        } else if (typeof networkSettings.type === 'string' && radialProjectable[networkSettings.type] && projection === 'radial') {
          const radialPoint = node.depth === 0 ? [adjustedSize[0] / 2, adjustedSize[1] / 2] : pointOnArcAtAngle([adjustedSize[0] / 2, adjustedSize[1] / 2], node.x / adjustedSize[0], node.y / 2);
          node.x = radialPoint[0];
          node.y = radialPoint[1];
        } else {
          node.x = node.x;
          node.y = node.y;

          if (createPointLayer) {
            node.x0 = node.x0;
            node.x1 = node.x1;
            node.y0 = node.y0;
            node.y1 = node.y1;
          }
        }
      });
    }

    if (networkSettings.type !== 'static' && (changedData || networkSettingsChanged)) {
      let components = [{
        componentNodes: projectedNodes,
        componentEdges: projectedEdges
      }];

      if (networkSettings.type === 'chord') {
        const radius = adjustedSize[1] / 2;
        const {
          groupWidth = 20,
          padAngle = 0.01,
          sortGroups
        } = singlePlot.props;
        const arcGenerator = arc$2().innerRadius(radius - groupWidth).outerRadius(radius);
        const ribbonGenerator = ribbon().radius(radius - groupWidth);
        const matrixifiedNetwork = matrixify({
          edgeHash: edgeHash,
          nodes: projectedNodes,
          edgeWidthAccessor,
          nodeIDAccessor
        });
        const chordLayout = chord().padAngle(padAngle);

        if (sortGroups) {
          chordLayout.sortGroups(sortGroups);
        }

        const chords = chordLayout(matrixifiedNetwork);
        const groups = chords.groups;
        groups.forEach(group => {
          const groupCentroid = arcGenerator.centroid(group);
          const groupD = arcGenerator(group);
          const groupNode = projectedNodes[group.HospitalFacilities];
          groupNode.d = groupD;
          groupNode.index = group.HospitalFacilities;
          groupNode.x = groupCentroid[0] + adjustedSize[0] / 2;
          groupNode.y = groupCentroid[1] + adjustedSize[1] / 2;
        });
        chords.forEach(generatedChord => {
          const chordD = ribbonGenerator(generatedChord); //this is incorrect should use edgeHash

          const nodeSourceID = nodeIDAccessor(projectedNodes[generatedChord.source.HospitalFacilities]);
          const nodeTargetID = nodeIDAccessor(projectedNodes[generatedChord.target.HospitalFacilities]);
          const chordEdge = edgeHash.get(`${nodeSourceID}|${nodeTargetID}`);
          chordEdge.d = chordD;
          const chordBounds = svgPathBoundingBox(chordD);
          chordEdge.x = adjustedSize[0] / 2 + (chordBounds.x1 + chordBounds.x2) / 2;
          chordEdge.y = adjustedSize[1] / 2 + (chordBounds.y1 + chordBounds.y2) / 2;
        });
      } else if (networkSettings.type === 'sankey' || networkSettings.type === 'flowchart') {
        const {
          orient = 'center',
          iterations = 100,
          nodePadding,
          nodePaddingRatio = nodePadding ? undefined : 0.5,
          nodeWidth = networkSettings.type === 'flowchart' ? 2 : 24,
          customSankey,
          direction = 'right'
        } = singlePlot.props;
        const sankeyOrient = sankeyOrientHash[orient];
        const actualSankey = customSankey || sankeyCircular;
        let frameExtent = [[0, 0], adjustedSize];

        if (direction === 'up' || direction === 'down') {
          frameExtent = [[0, 0], [adjustedSize[1], adjustedSize[0]]];
        }

        const frameSankey = actualSankey().extent(frameExtent).links(projectedEdges).nodes(projectedNodes).nodeAlign(sankeyOrient).nodeId(nodeIDAccessor).nodeWidth(nodeWidth).iterations(iterations);

        if (frameSankey.nodePaddingRatio && nodePaddingRatio) {
          frameSankey.nodePaddingRatio(nodePaddingRatio);
        } else if (nodePadding) {
          frameSankey.nodePadding(nodePadding);
        }

        frameSankey();
        projectedNodes.forEach(d => {
          d.height = d.y1 - d.y0;
          d.width = d.x1 - d.x0;
          d.x = d.x0 + d.width / 2;
          d.y = d.y0 + d.height / 2;
          d.radius = d.height / 2;
          d.direction = direction;
        });
        projectedEdges.forEach(d => {
          d.sankeyWidth = d.width;
          d.direction = direction;
          d.width = undefined;
        });
      } else if (networkSettings.type === 'force') {
        const {
          iterations = 500,
          edgeStrength = 0.1,
          distanceMax = Infinity,
          edgeDistance
        } = singlePlot.props;
        const linkForce = forceLink().strength(d => Math.min(2.5, d.weight ? d.weight * edgeStrength : edgeStrength));

        if (edgeDistance) {
          linkForce.distance(edgeDistance);
        }

        const simulation = networkSettings.simulation || forceSimulation().force('charge', forceManyBody().distanceMax(distanceMax).strength(networkSettings.forceManyBody || (d => -25 * nodeSizeAccessor(d)))); //        simulation.force("link", linkForce).nodes(projectedNodes)

        simulation.nodes(projectedNodes);
        const forceMod = adjustedSize[1] / adjustedSize[0];

        if (!simulation.force('x')) {
          simulation.force('x', forceX(adjustedSize[0] / 2).strength(forceMod * 0.1));
        }

        if (!simulation.force('y')) {
          simulation.force('y', forceY(adjustedSize[1] / 2).strength(0.1));
        }

        if (projectedEdges.length !== 0 && !simulation.force('link')) {
          simulation.force('link', linkForce);
          simulation.force('link').links(projectedEdges);
        } //reset alpha if it's too cold


        if (simulation.alpha() < 0.1) {
          simulation.alpha(1);
        }

        simulation.stop();

        for (let i = 0; i < iterations; ++i) simulation.tick();
      } else if (networkSettings.type === 'motifs') {
        const componentHash = new Map();
        projectedEdges.forEach(edge => {
          [edge.source, edge.target].forEach(node => {
            if (!componentHash.get(node)) {
              componentHash.set(node, {
                node,
                component: -99,
                connectedNodes: [],
                edges: []
              });
            }
          });
          componentHash.get(edge.source).connectedNodes.push(edge.target);
          componentHash.get(edge.target).connectedNodes.push(edge.source);
          componentHash.get(edge.source).edges.push(edge);
        });
        components = breadthFirstCompontents(projectedNodes, componentHash);
        const largestComponent = Math.max(projectedNodes.length / 3, components[0].componentNodes.length);
        const layoutSize = size[0] > size[1] ? size[1] : size[0];
        const layoutDirection = size[0] > size[1] ? 'horizontal' : 'vertical';
        const {
          iterations = 500,
          edgeStrength = 0.1,
          edgeDistance,
          padding = 0
        } = networkSettings;
        let currentX = padding;
        let currentY = padding;
        components.forEach(({
          componentNodes,
          componentEdges
        }) => {
          const linkForce = forceLink().strength(d => Math.min(2.5, d.weight ? d.weight * edgeStrength : edgeStrength));

          if (edgeDistance) {
            linkForce.distance(edgeDistance);
          }

          const componentLayoutSize = Math.max(componentNodes.length / largestComponent, 0.2) * layoutSize;
          const xBound = componentLayoutSize + currentX;
          const yBound = componentLayoutSize + currentY;

          if (layoutDirection === 'horizontal') {
            if (yBound > size[1]) {
              currentX = componentLayoutSize + currentX + padding;
              currentY = componentLayoutSize + padding;
            } else {
              currentY = componentLayoutSize + currentY + padding;
            }
          } else {
            if (xBound > size[0]) {
              currentY = componentLayoutSize + currentY + padding;
              currentX = componentLayoutSize + padding;
            } else {
              currentX = componentLayoutSize + currentX + padding;
            }
          }

          const xCenter = currentX - componentLayoutSize / 2;
          const yCenter = currentY - componentLayoutSize / 2;
          const simulation = forceSimulation().force('charge', forceManyBody().strength(networkSettings.forceManyBody || (d => -25 * nodeSizeAccessor(d)))).force('link', linkForce);
          simulation.force('x', forceX(xCenter)).force('y', forceY(yCenter)).nodes(componentNodes);
          simulation.force('link').links(componentEdges);
          simulation.stop();

          for (let i = 0; i < iterations; ++i) simulation.tick();

          const maxX = max(componentNodes.map(d => d.x));
          const maxY = max(componentNodes.map(d => d.y));
          const minX = min(componentNodes.map(d => d.x));
          const minY = min(componentNodes.map(d => d.y));
          const resetX = linear$1().domain([minX, maxX]).range([currentX - componentLayoutSize, currentX - 20]);
          const resetY = linear$1().domain([minY, maxY]).range([currentY - componentLayoutSize, currentY - 20]);
          componentNodes.forEach(node => {
            node.x = resetX(node.x);
            node.y = resetY(node.y);
          });
        });
      } else if (networkSettings.type === 'matrix') {
        if (networkSettings.sort) {
          projectedNodes = projectedNodes.sort(networkSettings.sort);
        }

        const gridSize = Math.min(...adjustedSize);
        const stepSize = gridSize / (projectedNodes.length + 1);
        projectedNodes.forEach((node, index) => {
          node.x = 0;
          node.y = (index + 1) * stepSize;
        });
      } else if (networkSettings.type === 'arc') {
        if (networkSettings.sort) {
          projectedNodes = projectedNodes.sort(networkSettings.sort);
        }

        const stepSize = adjustedSize[0] / (projectedNodes.length + 2);
        projectedNodes.forEach((node, index) => {
          node.x = (index + 1) * stepSize;
          node.y = adjustedSize[1] / 2;
        });
      } else if (typeof networkSettings.type === 'function') {
        networkSettings.type({
          nodes: projectedNodes,
          edges: projectedEdges
        });
      } else {
        projectedNodes.forEach(node => {
          node.x = node.x === undefined ? (node.x0 + node.x1) / 2 : node.x;
          node.y = node.y === undefined ? node.y0 : node.y;
        });
      }

      updateFrameData({ ...frameData,
        graphSettings: { ...frameData.graphSettings,
          nodes: singlePlot.props.nodes,
          edges: singlePlot.props.edges
        }
      });
    } //filter out user-defined nodes


    projectedNodes = projectedNodes.filter(filterRenderedNodes);
    projectedEdges = projectedEdges.filter(d => projectedNodes.indexOf(d.target) !== -1 && projectedNodes.indexOf(d.source) !== -1);

    if (networkSettings.direction === 'flip') {
      projectedNodes.forEach(node => {
        // const ox = node.x
        // const oy = node.y
        node.x = adjustedSize[0] - node.x;
        node.y = adjustedSize[1] - node.y;
      });
    } else if (networkSettings.direction === 'up' || networkSettings.direction === 'down') {
      const mod = networkSettings.direction === 'up' ? value => adjustedSize[1] - value : value => value;
      projectedNodes.forEach(node => {
        const ox = node.x;
        const ox0 = node.x0;
        const ox1 = node.x1;
        node.x = mod(node.y);
        node.x0 = mod(node.y0);
        node.x1 = mod(node.y1);
        node.y = ox;
        node.y0 = ox0;
        node.y1 = ox1;
      });
    } else if (networkSettings.direction === 'left') {
      projectedNodes.forEach(node => {
        node.x = adjustedSize[0] - node.x;
        node.x0 = adjustedSize[0] - node.x0;
        node.x1 = adjustedSize[0] - node.x1;
      });
    }

    if (typeof networkSettings.zoom === 'function') {
      networkSettings.zoom(projectedNodes, adjustedSize);
    } else if (networkSettings.zoom !== false && networkSettings.type !== 'matrix' && networkSettings.type !== 'chord' && networkSettings.type !== 'sankey' && networkSettings.type !== 'partition' && networkSettings.type !== 'treemap' && networkSettings.type !== 'circlepack' && networkSettings.type !== 'dagre') {
      // ZOOM SHOULD MAINTAIN ASPECT RATIO, ADD "stretch" to fill whole area
      const xMin = min(projectedNodes.map(p => p.x - nodeSizeAccessor(p)));
      const xMax = max(projectedNodes.map(p => p.x + nodeSizeAccessor(p)));
      const yMin = min(projectedNodes.map(p => p.y - nodeSizeAccessor(p)));
      const yMax = max(projectedNodes.map(p => p.y + nodeSizeAccessor(p)));
      const xSize = Math.abs(xMax - xMin);
      const ySize = Math.abs(yMax - yMin);
      const networkAspectRatio = xSize / ySize;
      const baseAspectRatio = adjustedSize[0] / adjustedSize[1];
      let yMod, xMod;

      if (networkSettings.zoom === 'stretch') {
        yMod = 0;
        xMod = 0;
      } else if (xSize > ySize) {
        if (networkAspectRatio > baseAspectRatio) {
          xMod = 0;
          yMod = (adjustedSize[1] - adjustedSize[0] / xSize * ySize) / 2;
        } else {
          yMod = 0;
          xMod = (adjustedSize[0] - adjustedSize[1] / ySize * xSize) / 2;
        }
      } else {
        if (networkAspectRatio > baseAspectRatio) {
          xMod = 0;
          yMod = (adjustedSize[1] - adjustedSize[0] / xSize * ySize) / 2;
        } else {
          yMod = 0;
          xMod = (adjustedSize[0] - adjustedSize[1] / ySize * xSize) / 2;
        }
      }

      const projectionScaleX = linear$1().domain([xMin, xMax]).range([xMod, adjustedSize[0] - xMod]);
      const projectionScaleY = linear$1().domain([yMin, yMax]).range([yMod, adjustedSize[1] - yMod]);
      projectedNodes.forEach(node => {
        node.x = projectionScaleX(node.x);
        node.y = projectionScaleY(node.y);
      });
    } else if (networkSettings.zoom !== false && networkSettings.projection !== 'radial' && (networkSettings.type === 'partition' || networkSettings.type === 'treemap' || networkSettings.type === 'dagre')) {
      const xMin = min(projectedNodes.map(p => p.x0));
      const xMax = max(projectedNodes.map(p => p.x1));
      const yMin = min(projectedNodes.map(p => p.y0));
      const yMax = max(projectedNodes.map(p => p.y1));
      const projectionScaleX = linear$1().domain([xMin, xMax]).range([margin.left, adjustedSize[0] - margin.right]);
      const projectionScaleY = linear$1().domain([yMin, yMax]).range([margin.top, adjustedSize[1] - margin.bottom]);
      projectedNodes.forEach(node => {
        node.x = projectionScaleX(node.x);
        node.y = projectionScaleY(node.y);
        node.x0 = projectionScaleX(node.x0);
        node.y0 = projectionScaleY(node.y0);
        node.x1 = projectionScaleX(node.x1);
        node.y1 = projectionScaleY(node.y1);
        node.zoomedHeight = node.y1 - node.y0;
        node.zoomedWidth = node.x1 - node.x0;
      });
      projectedEdges.forEach(edge => {
        if (edge.points) {
          edge.points.forEach(p => {
            p.x = projectionScaleX(p.x);
            p.y = projectionScaleY(p.y);
          });
        }
      });
    }

    projectedNodes.forEach(node => {
      node.nodeSize = nodeSizeAccessor(node);
    });
    projectedEdges.forEach(edge => {
      edge.width = edgeWidthAccessor(edge);
    });
    let legendSettings;

    if (props.legend) {
      legendSettings = props.legend;

      if (!legendSettings.legendGroups) {
        ///Something auto for networks
        const legendGroups = [{
          styleFn: nodeStyle,
          type: 'fill',
          items: []
        }];
        legendSettings.legendGroups = legendGroups;
      }
    }

    const nodeLabelAnnotations = [];

    if (nodeLabels && projectedNodes) {
      projectedNodes.forEach((node, nodei) => {
        const feasibleLabel = nodeLabels && nodeLabels !== true && nodeLabels(node);

        if (nodeLabels === true || feasibleLabel) {
          const actualLabel = networkSettings.projection === 'radial' && node.depth !== 0 ? radialLabelGenerator(node, nodei, nodeLabels === true ? nodeIDAccessor : nodeLabels, adjustedSize) : nodeLabels === true ? nodeIDAccessor(node, nodei) : feasibleLabel;
          let nodeLabel;

          if (React$1__default.isValidElement(actualLabel)) {
            nodeLabel = {
              key: `node-label-${nodei}`,
              type: 'basic-node-label',
              x: node.x,
              y: node.y,
              element: actualLabel
            };
          } else {
            nodeLabel = {
              key: `node-label-${nodei}`,
              className: 'node-label',
              dx: 0,
              dy: 0,
              x: node.x,
              y: node.y,
              note: {
                label: actualLabel
              },
              connector: {
                end: 'none'
              },
              type: AnnotationLabel,
              subject: {
                radius: nodeSizeAccessor(node) + 2
              }
            };
          }

          nodeLabelAnnotations.push(nodeLabel);
        }
      });
    }

    let screenCoordinates;
    const overlay = [];
    const areaBasedTypes = ['circlepack', 'treemap', 'partition', 'chord'];

    if (hoverAnnotation && areaBasedTypes.find(d => d === networkSettings.type) || hoverAnnotation === 'area') {
      if (hoverAnnotation !== 'edge') {
        const renderedNodeOverlays = projectedNodes.map((d, i) => ({
          overlayData: d,
          ...customNodeIcon({
            d,
            i,
            transform: `translate(${d.x},${d.y})`,
            styleFn: () => ({
              fill: 'pink',
              opacity: 0
            })
          }).props
        }));
        overlay.push(...renderedNodeOverlays);
      }

      if (hoverAnnotation !== 'node') {
        projectedEdges.forEach((d, i) => {
          const generatedIcon = customEdgeIcon({
            d,
            i,
            transform: `translate(${d.x},${d.y})`,
            styleFn: () => ({
              fill: 'pink',
              opacity: 0
            })
          });

          if (generatedIcon) {
            overlay.push({
              overlayData: { ...d,
                x: d.x || (d.source.x + d.target.x) / 2,
                y: d.y || (d.source.y + d.target.y) / 2,
                edge: true
              },
              ...generatedIcon.props
            });
          }
        });
      }
    } else if (hoverAnnotation === 'edge' && typeof networkSettings.type === 'string' && edgePointHash[networkSettings.type]) {
      screenCoordinates = projectedEdges.map(edgePointHash[networkSettings.type]);
    } else if (Array.isArray(hoverAnnotation) || hoverAnnotation === true || hoverAnnotation === 'node') {
      screenCoordinates = projectedNodes;
      if (changedData || networkSettingsChanged) screenCoordinates = [...projectedNodes];
    } else if (hoverAnnotation === 'all' && typeof networkSettings.type === 'string') {
      screenCoordinates = [...projectedEdges.map(edgePointHash[networkSettings.type]), ...projectedNodes];
    }

    const {
      svgPipe,
      canvasPipe
    } = toPipeline$2({
      projectedEdges,
      projectedNodes,
      edgeStyle: stringToFn(edgeStyle, () => ({}), true),
      edgeClass: stringToFn(edgeClass, () => '', true),
      edgeRenderMode: stringToFn(edgeRenderMode, undefined, true),
      edgeUseCanvas,
      edgeRenderKey: edgeRenderKey ? edgeRenderKey : d => d._NWFEdgeKey || `${d.source.id}-${d.target.id}`,
      projection: networkSettings.projection,
      edgeType,
      customEdgeIcon,
      networkType: networkSettings.type,
      direction: networkSettings.direction,
      nodeStyle: stringToFn(nodeStyle, () => ({}), true),
      nodeClass: stringToFn(nodeClass, () => '', true),
      nodeRenderMode: stringToFn(nodeRenderMode, undefined, true),
      nodeUseCanvas,
      customNodeIcon,
      nodeRenderKey
    });
    const svgPipeline = [...svgPipe];
    const canvasPipeline = canvasPipe.slice();
    updateFrameData({
      marginGraphic,
      adjustedPosition: adjustedPosition,
      adjustedSize: adjustedSize,
      renderNumber: frameData.renderNumber + 1,
      projectedNodes,
      projectedEdges,
      screenCoordinates,
      overlay,
      nodeIDAccessor,
      sourceAccessor,
      targetAccessor,
      nodeSizeAccessor,
      edgeWidthAccessor,
      margin,
      nodeLabelAnnotations,
      svgPipeline,
      canvasPipeline,
      graphSettings: { ...networkSettings.graphSettings,
        ...networkSettings,
        direction,
        projection
      }
    });
  };

  React$1.useEffect(() => {
    computeFrame(props);
  }, []);
  return frameData;
};

const isAxis = type => [Axis, XAxis, YAxis].includes(type);

const isXY = type => [Hexbin, Contour, Heatmap, Line, Scatter, Trendline].includes(type);

const isOrdinal = type => [Timeline, OrdinalPoint, Bar, ClusterBar, BarPercent, Swarm].includes(type);

const isNetwork = type => [Arc, Chord, CirclePack, Cluster, Dagre, Force, Matrix$1, Motifs, Partition, Sankey, Tree$1, Treemap].includes(type);

const Paper = props => {
  const {
    children
  } = props;
  const axesDefs = React$1__default.Children.toArray(children).filter(d => isAxis(d.type)).map(d => Object.assign({}, d.props));
  const xyChildren = React$1__default.Children.toArray(children).filter(d => isXY(d.type));
  const ordinalChildren = React$1__default.Children.toArray(children).filter(d => isOrdinal(d.type));
  const networkChildren = React$1__default.Children.toArray(children).filter(d => isNetwork(d.type));
  let frameData = null;
  let plotChildren = null;
  let generateSVGAnnotations = null;
  let generateHTMLAnnotations = null;

  if (xyChildren.length > 0) {
    plotChildren = xyChildren;
    const frameProps = { ...props,
      axesDefs,
      plotChildren
    };
    frameData = computeXYFrameData(frameProps);
    generateSVGAnnotations = generateXYSVGAnnotations({
      frameProps,
      frameData
    });
    generateHTMLAnnotations = generateXYHtmlAnnotations({
      frameProps,
      frameData
    });
  } else if (ordinalChildren.length > 0) {
    if (ordinalChildren.length !== 1) {
      console.error('Only 1 Orindal plot is allowed');
    }

    plotChildren = ordinalChildren;
    const frameProps = { ...props,
      axesDefs,
      plotChildren
    };
    frameData = computeOrdinalFrameData(frameProps);
    generateSVGAnnotations = generateOrdinalSVGAnnotations({
      frameProps,
      frameData
    });
    generateHTMLAnnotations = generateOrdinalHTMLAnnotations({
      frameProps,
      frameData
    });
  } else if (networkChildren.length > 0) {
    if (networkChildren.length !== 1) {
      console.error('Only 1 network plot is allowed');
    }

    plotChildren = networkChildren;
    const frameProps = { ...props,
      axesDefs,
      plotChildren
    };
    frameData = computeNetworkFrameData(frameProps);
    generateSVGAnnotations = defaultNetworkSVGRule({
      frameProps,
      frameData
    });
    generateHTMLAnnotations = defaultNetworkHTMLRule({
      frameProps,
      frameData
    });
  }

  const frameProps = { ...props,
    ...frameData,
    plotChildren,
    generateSVGAnnotations,
    generateHTMLAnnotations
  };
  return React$1__default.createElement(Frame, frameProps, children);
};

Paper.propTypes = { ...BaseProps
};
Paper.defaultProps = { ...BaseDefaultProps
};

exports.Annotation = Annotation;
exports.Arc = Arc;
exports.Bar = Bar;
exports.BarPercent = BarPercent;
exports.Chord = Chord;
exports.CirclePack = CirclePack;
exports.Cluster = Cluster;
exports.ClusterBar = ClusterBar;
exports.Contour = Contour;
exports.Dagre = Dagre;
exports.Force = Force;
exports.Heatmap = Heatmap;
exports.Hexbin = Hexbin;
exports.Line = Line;
exports.Matrix = Matrix$1;
exports.Motifs = Motifs;
exports.OrdinalPoint = OrdinalPoint;
exports.Paper = Paper;
exports.Partition = Partition;
exports.Sankey = Sankey;
exports.Scatter = Scatter;
exports.Swarm = Swarm;
exports.Timeline = Timeline;
exports.Tree = Tree$1;
exports.Treemap = Treemap;
exports.Trendline = Trendline;
exports.XAxis = XAxis;
exports.YAxis = YAxis;
